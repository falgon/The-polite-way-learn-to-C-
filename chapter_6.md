# 第 6 章 関数、制御区域、名前空間

本章では、関数と制御区域、名前空間の概念について説明します。関数はプログラミング言語の基本的概念でありC++のプログラムは関数の集合であるとも言えます。制御区域と名前空間は、どちらもプログラムを組む上で大切な概念です。全てマスターしていきましょう。
この章では以下のような流れで説明していきます。

1. 関数
2. グローバルスコープとローカルスコープ
3. namespace
    * ADL

## 6.1 関数
まず始めに文法を述べてしまいましょう。関数の文法は以下のようになっています。
```cpp
キーワード1 戻り値の型 関数名(仮引数型 仮引数名...)キーワード2{ 関数の内容 }
```
実際に使ってみましょう。

```cpp
#include<iostream>
int func(){return 42;}
int main()
{
    int a=func();
    std::cout << a << std::endl;
}
```
実行結果は以下となります。

```cpp
42
```
まず、以下の関数
```cpp
int func(){return 42;}
```
が、それぞれ文法どこにに対応しているのかを説明します。

* キーワード1はこの場合、無しです。キーワードについてはまた再度説明する内容となるのですが、必要でない場合省く事ができます。
* 戻り値の型は`int`の部分です。関数の内容で`return 42;`として`42`を返しています。`42`は整数値のため、戻り値の型の指定は`int`が良いでしょう。
* 関数名は`func`の部分です。この場合、「`int`型の値を戻す関数名func」という意味になります。関数名には「2.2.7 識別子へ名付けてはならない名前」にて扱った名前以外は何でも付ける事ができます。
* 仮引数型と仮引数名は、この場合無しです。仮引数名は、その関数が引数を取らない場合、記述する必要はありません。
* キーワード2もこの場合指定していませんので無しです。
* 関数の内容は、先ほども述べた通り`return 42;`の部分となります。

...と一気に述べてしまいましたが、大丈夫です。一つずつ説明していきます。

### 6.1.1 return文
return文は関数からの戻り値を指定する文です。文法は以下のようになります。
```cpp
return リターンする値、変数/オブジェクト;
```
例えば先ほどの`func`関数では`return`文に`42`という値を指定していました。
```cpp
int func(){return 42;}
```
変数を指定することもできます。
```cpp
int func()
{
    int a=42;
    return a;
}
```
この場合、`a`はコピーされて、関数の呼び出し元へ値が返されます。返される値、`a`は宣言段階で`42`に初期化していますので、`42`ですね。コピーなどの概念については、また後ほどに説明します。

#### 返却値における暗黙の変換

ところで、例えばこのような記述であった場合、実行結果はどのようになるでしょうか。
```cpp
#include<iostream>
int func(){return 42.5;}
int main()
{
    std::cout<<func()<<std::endl;
}
```
コンパイラによっては警告を出力してくれるかもしれません。実行結果は以下になります。
```cpp
42
```
`42.5`を戻すと記述したはずなのに、出力結果は`42`となっていますね。これは、2.2.4で述べたのと同じように、浮動小数点数値を`int`で返しているため、小数点以下の数値の切り捨てが行われます。そのため`42`が返ってくるのです。では、以下のようにするとどうなるでしょうか。
```cpp
#include<iostream>
char func(){return 65;}
int main()
{
    std::cout<<func()<<std::endl;
}
```
実行結果は以下となります。
```cpp
A
```
`65`を返すとしているのに、`A`と出力されました。これも同様、`char`型で返すとしているために行われる暗黙の変換がされているからです。`char`型で`65`は、丁度文字`A`に該当する数値のため、文字`A`が返るのです。

#### 何も返さない関数

ここまでは戻り値の型として指定した型は、全て値を返す関数として定義するため、`int`や`double`、`char`などを例題に使いましたが、戻り値がない関数を記述する事もできます。そのような場合、戻り値の型に`void`を指定します。
```cpp
void f(){std::cout<<"call f"<<std::endl;}
```
この関数`f`は`void`、つまり、何も返さない関数ですので、`return`文は不要という事になります。

### 6.1.2 引数
関数の章の冒頭で述べた関数`func`には、仮引数型と仮引数名が無いと述べました。
```cpp
int func(){return 42;}
```
では、仮引数型と仮引数名があるとは、どういう状態を言うのでしょうか。それは以下のような場合です。
```cpp
int func(int x){return x;}
```
関数の文法には、その関数内でただただ内容を実行するだけではなく、その関数に対して値を渡したりする機能があります。上記の関数の場合、仮引数型と仮引数名の部分に、`int x`と記述されていますので、「この関数は整数値を受け取りその整数値はxである」という意味になります。それでは関数を使って、整数値を渡してみましょう。
```cpp
#include<iostream>
int func(int x){return x;}
int main()
{
    std::cout<<func(42)<<std::endl;
}
```
実行結果は以下となります。
```cpp
42
```
`func`に`int x`として仮引数名を指定しました。このように記述する事で、int型を受け取る関数として宣言/定義することができます。この関数を呼び出すためには、
```cpp
func( 値/オブジェクト );`
```
と記述します。今回は`func(42);`としていますので`func`関数には`42`という値が渡されます。その値は関数`func`内で`x`という変数で扱われます。それを、そのまま`return`によって返していますので、出力結果は`42`となります。理解を深めるため別のサンプルも見て見ましょう。
```cpp
#include<iostream>
int plus(int x,int y){return x+y;}
int main()
{
    std::cout<<plus(10,10)<<std::endl;
}
```
出力結果は以下となります。
```cpp
20
```
引数として渡された`10`と`10`が、それぞれ関数`plus`内で`x`、`y`変数として扱われます。それらが`+`演算子によって加算されています。`x + y`は`10 + 10`となりますので、`20`という演算結果が得られます。その値を返し、それをそのまま出力しろとしているので、`20`が出力されます。

### 6.1.3 宣言と定義

変数/オブジェクトにも変数の宣言と定義があったように、関数にも宣言と定義があります。例えば以下のように書いた場合、
```cpp
int main()
{
    f(42);
}
```
このコードはコンパイルエラーとなります。当然です、関数`f`に`42`という値を渡しているように読み取れはしますが、肝心な関数`f`の宣言も定義もないからです。C++は、全て何かを使おうとする場合、あらかじめ宣言/定義を済ませて置かなければなりません。このコードは以下のように宣言/定義してあげる事でコンパイルが通ります。
```cpp
void f(int x){}
int main()
{
    f(42);
}
```
これを、もしこのように書いた場合、どうなるでしょうか。
```cpp
int main()
{
    f(42);
}
void f(int x){}
```
これはコンパイルエラーとなります。関数`f`の呼び出しが`main`関数内で行われていますが、呼び出された時点では関数`f`についての宣言が全くないため、コンパイラはその存在を知り得る事ができません。
関数を呼び出すためには、宣言が事前にあれば良いのです。関数の宣言は、以下のように記述します。
```cpp
void f(int x);
int main()
{
    f(42);
}
```
関数の内容部分の記述がなく、`;`で終わっていますね。これを、**プロトタイプ宣言**と言います。しかし、実はこの記述だけだと、コンパイラはエラーを吐きます。なぜでしょうか。確かに、関数`f`を宣言するという事はコンパイラに伝わりました。しかしそれだけだと、関数`f`が何をするのかが定義されていないため、その関数を実行する事はできないのです。つまり、その関数が何をする関数なのかを記述する必要があります。
```cpp
void f(int x); // 宣言
int main()
{
    f(42);
}
void f(int x){} // 実装
```
これで、コンパイルが通るようになりました。このように、**実際に関数が呼び出される前に宣言さえされていれば**、その内部実装(関数の内容部分)はどの部分にあってもコンパイルする事ができます。今回は関数の内容部分に何も記述していないので、この関数`f`は何もしません。因みに、宣言部分では、仮引数名を省略する事ができます。
```cpp
void f(int);
int main()
{
    f(42);
}
void f(int x){}
```
宣言時の記述では、`int`とだけしか記述されていませんが、コンパイラーとしては**何が戻り値でどういう名前の関数で、どういう型の引数がくるのか**さえ事前に分かっていれば良いので、仮引数名は省略する事ができます。
...ここまで読んでみて、宣言と定義を同時に行う方法と、それぞれを分離する方法、なぜこの二つの記述法があるのかと疑問に思うかもしれません。勿論分離する事による利点があるからこのような機能があるのですが、それについては関数とはまた違うカテゴリーの説明となりますので、後述する事とします。

### 6.1.4 デフォルト引数
デフォルトの引数を設定する事ができます。例えば、以下のように記述できます。
```cpp
#include<iostream>
void f(int x=42)
{
    std::cout<<x<<std::endl;
}
int main()
{
    f();
}
```
実行結果は以下となります。
```cpp
42
```
関数`f`の定義部分で仮引数`x`に対して`42`をデフォルト指定しています。この場合、関数`f`の呼び出し時に、引数として何も設定しなければ(`f();`の部分)、`x`は`42`として処理されます。宣言と定義を分離した場合は、以下のように記述します。
```cpp
#include<iostream>
void f(int=42);
int main()
{
    f();
}
void f(int x)
{
    std::cout<<x<<std::endl;
}
```
実行結果は変わらず、`42`と出力されます。宣言部分にデフォルト引数を指定して、定義部分には指定していません。これは、デフォルト引数を指定する場合は宣言部分に指定し、定義部分には記述しないという文法的な決まりです。
最後に、これはどのような出力結果となるでしょうか。
```cpp
#include<iostream>
void f(int x=42)
{
    std::cout<<x<<std::endl;
}
int main()
{
    f(10);
}
```
実行結果は以下となります。
```cpp
10
```
デフォルト引数は`42`と指定されていますが、呼び出し時に関数`f`に対して`10`を渡していますので、その出力結果は`10`となります。
逆に、このような記述はできるのでしょうか。
```cpp
void f(){}
int main()
{
    f(42);
}
```
これはコンパイルエラーとなります。仮引数型と仮引数名が定義されていない関数に対して値を指定して呼び出す事はできません。
### 6.1.5 inline関数
先ほどからの説明で戻り値の型の前に指定できる、キーワードの部分を一切指定せず宣言/定義してきましたが、指定できるキーワードの一つとして、`inline`というキーワードがあります。
まず前提として、関数呼び出しは通常処理としてはあまり高速ではありません。これには諸々の理由があるのですが、それは後述するとして、例えば、以下の二つのプログラムであれば文脈としては前者の方が高速に動作します。(最適化によって処理速度は変わらない可能性もある)
```cpp
#include<iostream>
int main()
{
    std::cout<<42<<std::endl;
}
```
```cpp
#include<iostream>
void f(int x){std::cout<<x<<std::endl;}
int main()
{
    f(42);
}
```
実行結果はどちらも変わりません。しかし、後者の方が遅い記述です。何故ならば、**関数呼び出しは高速ではないからです**。
しかし、書き方として、`main`関数に全ての処理内容を書かず、機能ごとに関数として分離したいという要望もあるのです。その要望に応えて関数として分けた結果、`main`関数に直接記述したよりも処理が遅くなってしまうというのは困ります。そのような時に、`inline`キーワードを指定します。
```cpp
#include<iostream>
inline void f(int x){std::cout<<x<<std::endl;}
int main()
{
    f(42);
}
```
戻り値の型の前に指定していますね。このように`inline`を指定する事で、コンパイルの段階で、内部処理として関数の内容をその呼び出し部分で展開**してほしい**とコンパイラに伝える事ができます。つまり、コンパイルの最適化の段階で、先ほどのコードを以下のような**感じ**に**してほしい**とコンパイラに訴えかけられるという事です。
```cpp
#include<iostream>
int main()
{
    std::cout<<42<<std::endl;
}
```
関数`f`の内容を、呼び出し元である`main`関数内に完全に展開して関数呼び出しさえなくなっています。これは一番初めに示した最も高速な記述であるプログラムと同じコードですね。
**感じ**と曖昧にしているのは、コンパイラによってinline展開の解釈が異なるためです。また、**してほしい**と太文字にしているのは、コンパイラに対する単なる要望だからです。
実際にinline展開されるかどうかは、実は分かりません。コンパイラがinline展開段階でその利点と欠点をどのように判断するかによって処理が異なるからです。

ここでinline展開される事による利点と欠点を整理しましょう。まず利点は、先ほども述べた通り、関数呼び出しの遅さを無くす事ができます。では欠点はなんでしょうか。それはプログラムサイズが増えてしまうという点です。
インライン展開をする事と、呼び出しの元の関数内に処理を埋め込むわけ事となります。つまり、プログラムサイズが増えてしまうのです。

そこで、大抵のコンパイラは、インライン展開する事でプログラムサイズが肥大化してしまうかどうかを判定します。そしてその判定結果に応じて、インライン展開を行うかどうか判断します。`inline`展開されなかった場合、`inline`指定していない関数と同じように、通常の関数としてそのまま定義されます。これはコンパイラが自動的に判断しますので、自分で制御することはできません。
以上の点から、最近のコンパイラであれば、わざわざ`inline`キーワードを指定しなくても勝手に高速に動くように最適化してくれるという点から、あまり意図的に指定する必要も現代ではないかもしれません。

### 6.1.6 関数の動的再起呼び出し
関数を再起的に呼び出すこともできます。
```cpp
#include<iostream>
void f(int i)
{
    if(i<5){
        std::cout<<i<<" ";
        f(i+1);
    }
}
int main()
{
    int a=0;
    f(a);
    std::cout<<std::endl;
}
```
実行結果は以下となります。
```cpp
0 1 2 3 4
```
main関数で`0`で初期化された変数aが定義されています。それを関数`f`に渡します。`if`文で`i<5`の時実行すると分岐しています。渡された変数`a`は関数`f`では仮引数によって`i`とされています。つまり`i`は`0`ですから`i<5`はtrueのため`if`文中のコードは実行されます。そこでは`i`の内容を出力し、その後自分自身である関数`f`に`i`に`1`を加算した値を渡し呼び出しています。このように自分自身を呼び出すループを再起呼び出しと言います。しかし、このように動的に関数を再起的に呼び出すの事はとても非効率的ですからあまり用いるべきではありません。(動的とは、プログラム実行時に行う事を言います。それに対照的なのが静的です。これは、実行時に処理を行うのではなく、実行時には既に決まっているもの全般を普遍的に言います。これについては後の章で説明します。)なぜならば先ほども述べた通り、**関数呼び出しは決して高速ではないから**です。同じような処理、結果を求めるのであれば、解決方法は様々ですが、例えば以下のように書くべきです。
```cpp
#include<iostream>
void f(int i)
{
    for(; i<5; ++i)std::cout<<i<<" ";
}
int main()
{
    int a=0;
    f(a);
    std::cout<<std::endl;
}
```
関数を再起的に呼び出すのではなく、`for`ループで同機能を実現しています。関数呼び出しそのものは遅いですから、それを何度も連続的に行わせる動的な再起処理は、特別な理由で必要がない限り、用いるべきではありません。

### 6.1.7 オーバーロード
C++には、同じ第2章でも説明した通り、One Definition Ruleというルールがあります。これは、同じ識別子を二つ以上同スコープ内で宣言/定義する事は許されないという決まりです。しかし、例えばこのような事がしたいと思うかもしれません。
```cpp
#include<iostream>
int plus_int(int x,int y){return x+y;}
double plus_double(double x,double y){return x+y;}
int main()
{
    std::cout<<plus_int(10,20)<<std::endl;
    std::cout<<plus_double(10.5,20.4)<<std::endl;
}
```
実行結果は以下となります。
```cpp
30
30.9
```
関数名も一つの識別子です。そこで、ODRを意識して`int`型用の`plus_int`という関数と、`double`型用の`plus_double`という関数を作りました。これは、規格に一切違反していませんから正しいコードと言えます。しかし、渡す値が`int`型であるか`double`型であるかだけで、一々関数名を変えるというのはあまりユーザーとしては使いやすいものではありません。ユーザーからすれば、何の型の値を加算するのかを意識するのではなく、やりたい事はただとにかく加算がしたいわけですから、渡された値の型が`int`だろうが`double`だろうが関数呼び出しには`plus`だけで統一したいものです。オーバーロードは、それを叶える機能です。
```cpp
#include<iostream>
int plus(int x,int y){return x+y;}
double plus(double x,double y){return x+y;}

int main()
{
    std::cout<<plus(10,20)<<std::endl;
    std::cout<<plus(10.5,20.4)<<std::endl;
}
```
実行結果は先ほどと同じです。なんとODRというルールがありながら、`plus`という名前の関数を二つも定義しています。これは違反ではなく正しいコードです。実は**コンパイラが関数を識別する際に使っているのは、関数名だけではなく、それに加えて関数の仮引数型らを含めて識別している**のです。(仮引数の並び、それらをシグネチャと言ったりします。)
つまり確かに、`plus`という関数名は同じです。しかし、`int`を受け取るのか、`double`を受け取るのか、その部分が双方で異なりますのでコンパイラは別の関数として捉える事ができるのです。理解を深めるため、また少し違うサンプルを見て見ましょう。
```cpp
#include<iostream>
int plus(int x){return x;}
int plus(int x,int y){return x+y;}
int plus(int x,int y,int z){return x+y+z;}

int main()
{
    std::cout<<plus(10)<<std::endl;
    std::cout<<plus(10,20)<<std::endl;
    std::cout<<plus(10,20,30)<<std::endl;
}
```
実行結果は以下となります。
```cpp
10
30
60
```
関数名は全て`plus`で、仮引数の型も全て`int`ですが、仮引数の数が違うので、これはオーバーロードする事ができます。単純ですね。その調子で、次のサンプルを見て見ます。
```cpp
#include<iostream>
int plus(int x,int y){return x+y;}
int plus(int y,int x){return y+x;}

int main()
{
    std::cout<<plus(10,20)<<std::endl;
    std::cout<<plus(10,20)<<std::endl;
}
```
これはコンパイルに成功するでしょうか。答えはNOです。何故ならば、ODRを違反しているからです。確かに、仮引数名の並びは`int x,int y`と、`int y,int x`で双方ともに異なります。しかし、コンパイラが識別に見ているのは仮引数名ではなく、仮引数の型です。そう見ると、どちらも`int`型のデータを2つ受け取る関数`plus`ですから、全く同じ定義となります。全く同じ定義はODRに違反しますので、コンパイルエラーとなるのです。
どんどん行きましょう。以下の場合はどうなるでしょうか。
```cpp
int func(int){return 42;}
double func(int){return 42.5;}
int main()
{
    func(10);
}
```
関数の戻り値型がそれぞれ違います。...が、残念ながら、戻り値型のみ違う関数もODR違反となります。別の関数として識別するのには関数名とそのシグネチャのみですから文法的に正しくないコードとなります。...しかし、実は戻り値だけが違う関数のオーバーロードをシミュレートできる機能がC++には備わっています。それについては「第11章テンプレート」にて説明しますので、楽しみにしていてください。

#### 関数とリテラル

少しここで、リテラルという概念に触れておきます。以下のような場合、コンパイラはどのように動くでしょうか。
```cpp
#include<iostream>

void func(unsigned int)
{
    std::cout<<"the argument type is unsigned int !"<<std::endl;
}
void func(int)
{
    std::cout<<"the argument type is signed int !"<<std::endl;
}
int main()
{
    func(10);
}
```
実行結果は以下となります。
```cpp
the argument type is signed int !
```
`10`という数値は、`unsigned int`にも`signed int`にも互換性のある値です。しかし、しっかりと呼び分ける事ができています。これを感覚的に捉えるには、まず`10`という値は、要するに`+10`であるのだ、と捉えると良いでしょう。`+`というsignが付いているので、`signed int`を取る関数`func`が呼ばれるのです。では、`10`を`unsigned`な`int`として表記するにはどうすれば良いのでしょうか。それは、以下のように記述します。
```cpp
10u
```
では関数`func`の呼び出しに`10u`を渡して見ましょう。
```cpp
#include<iostream>
void func(unsigned int)
{
    std::cout<<"the argument type is unsigned int !"<<std::endl;
}

void func(int)
{
    std::cout<<"the argument type is signed int !"<<std::endl;
}
int main()
{
    func(10u);
}
```
実行結果は以下となります。
```cpp
the argument type is unsigned int !
```
`unsigned int`を受け取る関数`func`が無事呼び出されました。しかしまだ`signed`と`unsigned`以外にも、例えば`double`と`float`が同じ問題を抱えています。
```cpp
#include<iostream>
void func(float)
{
    std::cout<<"the argument type is float !"<<std::endl;
}
void func(double)
{
    std::cout<<"the argument type is double !"<<std::endl;
}
int main()
{
    func(10.5);
}
```
実行結果は以下となります。
```cpp
the argument type is double !
```
`10.5`を渡しています。しかし`double`型も`float`型もどちらも小数点を扱う事のできる型です。それでいて`double`型を受け取る関数`func`が呼び出されました。`float`としての数値を表したいのに！...ご安心ください。float用にも、その機能は備えられています。
```cpp
#include<iostream>
void func(float)
{
    std::cout<<"the argument type is float !"<<std::endl;
}
void func(double)
{
    std::cout<<"the argument type is double !"<<std::endl;
}
int main()
{
    func(10.5f);
}
```
このような`u`、`f`をリテラルと言います。リテラルはまだ少し奥深いところがありますので、後ほどまた詳しく解説します。

## 6.2 グローバルスコープとローカルスコープ

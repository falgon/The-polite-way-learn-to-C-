# 第 6 章 関数、制御区域、名前空間

本章では、関数と制御区域、名前空間の概念について説明します。関数はプログラミング言語の基本的概念でありC++のプログラムは関数の集合であるとも言えます。制御区域と名前空間は、どちらもプログラムを組む上で大切な概念です。全てマスターしていきましょう。
この章では以下のような流れで説明していきます。

1. 関数
2. グローバルスコープとローカルスコープ、static変数
3. Namespace


## 6.2 グローバルスコープとローカルスコープ、static変数

この項ではスコープという概念について説明します。今まで変数を宣言/定義する時、全て関数の中に記述をしてきました。
```cpp
int main()
{
    int x;
}
```
実は、関数外にも変数を宣言する事ができるのです。
```cpp
int x;

int main(){}
```
この時、変数`x`はグローバルスコープにあると言えます。ではローカルスコープとはどのような事を言うのでしょうか。それは、以下のような時を言います。
```cpp
int main()
{
    int x;
}
```
変数`x`は`main`関数というローカルスコープにあると言えます。たったこれだけの事です。たったこれだけの事なのですが、実は両者は全くの別物なのです。

### 6.2.1 ローカルスコープ
まず、グローバルスコープの理解のためにローカルスコープを説明します。前述した通りローカルスコープとは、例えば以下のような事を言います。
```cpp
int main()
{
    int x=10;
}
```
この場合、他のスコープからは`main`関数内の変数`x`を見つける事はできません。
```cpp
int f();
int main()
{
    int x=10;
}
int f()
{
    return x+1; // エラー。関数fのスコープでxは定義されていない
}
```
通常、別のスコープへ値を渡したい場合は、関数の引数として渡す事で実現できます。
```cpp
int f(int);
int main()
{
    int x=10;
    f(x);
}
int f(int x)
{
    return x+1;
}
```
このようなスコープ内の領域を**ローカルスコープ**と言います。

### 6.2.2 グローバルスコープ
グローバルスコープに変数を宣言/定義しそれを使って見ます。
```cpp
int x=10;
void func(){x=20;}
int main()
{
    func();
    std::cout<<x<<std::endl;
}
```
実行結果は以下となります。
```cpp
20
```
このコードから分かる事は、グローバル領域に宣言/定義された変数はどのスコープからでも見えるという事です。このようなスコープ外の領域を**グローバルスコープ**と言います。ローカルスコープの変数はその内包している関数の終端で破棄されますが、グローバル変数はプログラムが完全に終了するまで破棄されないため、グローバルスコープに宣言された変数はローカル変数よりも寿命が長いと言えます。

### 6.2.3 メモリ領域
メモリ領域の観点から見ると、グローバルスコープとローカルスコープの違いは歴然です。その違いを理解するために、まずメモリ領域について説明します。以下は、C++言語で扱うメモリの論理的な模式図です。
![](/assets/memory.jpg)
各領域の役割は、以下の通りです。
* テキスト領域：機械語に翻訳されたプログラム本体が格納されます。
* 静的領域：グローバル変数、static変数などの静的変数が置かれる。
* ヒープ領域：メモリの動的管理 (malloc関数、new 演算子によってメモリを確保する事) に利用されます。
* スタック領域：CPUのレジスタの内容を一時的に退避させたり、自動変数 (多くのローカル変数) の格納、管理に用いられます。

各領域の役割の内には、まだ現時点では説明していない概念が含まれていますが、後々全て説明していきますので、今は分からなくても大丈夫です。
このようにメモリ領域の観点から考えると、グローバル変数とローカル変数は格納される領域がそれぞれ異なります。それでは、実際のC++コードからそれぞれがどの領域に格納されるのかを見て見ましょう。
```cpp
int plus(int x,int y){return x+y;}
int global_variable; // グローバル変数
int main()
{
    int x=10,y=20;
    int result=plus(x,y);
}   
```
それぞれ、以下のように各領域が格納されています。(関数アドレスについては、また後に説明します。)

| 静的領域(グローバルスコープ) | スタック領域(ローカルスコープ) |
| -- | -- | 
| plus関数アドレス | plus関数内変数x | 
| main関数アドレス | plus関数内変数y |
| 変数global_variable | main関数内変数x | 
| | main関数内変数y |
| | main関数内変数result |

### 6.2.4 領域毎のOne Definition
ところで、グローバル領域とローカル領域で同じ名前の識別子を使用する事はできるでしょうか。
```cpp
int x;
int main()
{
    int x;
}
```
これは、できます。グローバル領域の`x`とローカル領域の`x`は、領域がそれぞれ違うので別物として扱う事ができます。これは「5.1 スコープ」で説明した内容と同じです。

### 6.2.5 static変数
例えば、ある関数があったとします。その関数は呼ばれる度に、自身が何回呼ばれたのかを出力する関数だとします。
```cpp
void func()
{
    int i=1;
    std::cout<< i++ <<std::endl;
}
int main()
{
    for(unsigned int a=0; a<5; ++a)func();
}
```
実行結果は以下となります。
```cpp
1
1
1
1
1
```
これは失敗ですね。`for`文で`func`関数を5度呼び出していますが、うまくカウントできていません。理由は単純です。カウントする関数`func`内の変数`i`は、`func`内のローカル変数だからです。何か哲学的な事を言っているように聞こえるかもしれませんが、これは事実です。要するに、カウントするための変数`i`は`func`関数が実行されると`0`で初期化され、その後、後置インクリメントによって遅延的に`i`の値は`1`となりますが、そこで関数が終了してしまうため、変数`i`は破棄されてしまうのです。その後、また関数`f`が呼ばれ、同じ事を繰り返すのですから、永遠に0から変わらないのは当然です。これを解決する一つの方法として、プログラムが終了するまで、確保した領域が破棄されない変数を使うという方法がありますね。まずは、先ほどから紹介している、**グローバル変数**を用いる方法があるでしょう。
```cpp
int i=1;
void func()
{
    std::cout<< i++ <<std::endl;
}
int main()
{
    for(unsigned int a=0; a<5; ++a)func();
}
```
実行結果は以下となります。
```cpp
1
2
3
4
5
```
グローバル領域に変数を宣言したため、プログラムが終了するまでその変数は破棄されません。また、どこからでもその変数を見る事ができます。その結果、意図した通りの処理を行う事ができました。
しかし、グローバル変数とは別の手段で、プログラムが終了するまで破棄されない変数を定義する方法があるのです。それが、**static変数**です。
```cpp
void func()
{
    static int i=1;
    std::cout<< i++ <<std::endl;
}
int main()
{
    for(unsigned int a=0; a<5; ++a)func();
}
```
実行結果は以下となります。
```cpp
1
2
3
4
5
```
`static`指定子を変数宣言時の型の前に付与する事で、その変数をstatic変数とする事ができます。`static`変数は、グローバル変数と同様、プログラムが終了するまでその変数は破棄されません。しかし、グローバル変数とは違ってスコープは`func`関数内にありますので、例えば上記コードの場合、`main`関数から変数`i`を見つける事はできません。
因みに、ローカル変数は初期化も代入もせずその変数を参照しようとすると、どんな値が入っているかは分かりませんでしたが、
```cpp
#include<iostream>
int main()
{
    int x;
    std::cout<<x<<std::endl; // 何が出力されるか未定義
}
```
グローバル変数やstatic変数は初期化時に勝手に値0で初期化される事が決まっています。
```cpp
#include<iostream>
int a;
int main()
{
    static int b;
    std::cout<<a<<std::endl; // 0
    std::cout<<b<<std::endl; // 0
}
```

### 6.2.6 static指定子の別のセマンティック
セマンティックとはかなり簡潔に述べると意味論といったところです。実は、static指定子には別の意味合いもあります。それは、**そのファイル内でしかそのデータにアクセスする事はできない**という意味合いです。例えば以下のように記述されているファイルがあったとします。それは`test.hpp`という名前だとします。
```cpp
// test.hpp
static int data;
```
これをインクルードして変数`data`を使って見ましょう。
```cpp
#include"test.hpp"
int main()
{
    data=10;
}
```
...という事ができないようにする事ができるます。つまり、変数`data`にアクセスできるのは`test.hpp`というファイルの中だけで、インクルードした先でその変数に対してアクセスする事はできません。これは、ファイルごとの動作の安全性を確立するためにある機能であり、例えば変数をそのファイル内のグローバルスコープには起きたいが、他のファイルからはその変数を使えないようにしたいといった時に効力を発揮します。これは関数などでも同じです。しかしこの機能は、`static`変数とはまた異なって`static`というキーワードに異なる機能/意味合いを持たせていることからあまり分かりやすいとは言えません。staticキーワードは、本来は記憶クラスを静的にする意味の修飾子です。しかしこのように特例として、宣言した時点で最初から記憶クラスが静的なものにstaticをつけた場合、名前をファイルスコープに制限する意味となります。このように変則的に意味が変わるのはあまり分かりやすいとは言えません。

そこで、そのファイル中でしかアクセスする事ができないようにするという機能は、別の方法で実現する事ができるようになっています。それは後ほど、名前空間の項で説明します。

### 6.2.7 領域の概念から考察する設計デザイン
このようにグローバル領域に宣言されたデータと`static`指定子が付与されたデータはプログラムが終了するまで破棄されません。しかし逆を言えば、両者ともプログラムが終了するまで破棄されないで欲しいという必要性に迫られない限り、静的領域にデータを確保しても意味がなく、無駄であるとも言えるのです。更に特にグローバル領域に関して言えば、プログラムのどこからでも見えてしまうというそのあまりにも広い自由度から、バグの温床になってしまう事も考えられるため、グローバル変数自体の使用を禁止するというプロジェクトルールを掲げるチームも中には存在します。実際のところ、機能を理解している上で本当に必要であれば、使うべきです。しかし、単に単純だからといった無意味な理由でその機能を使うのは、辞めるべきです（領域の概念以外でも全てにおいて言える事ですが）。

## 6.3 Namespace
C++には名前空間(namespace)という概念があります。名前空間は、これまたスコープなどに関する概念です。まず、名前空間は以下のように使います。
```cpp
namespace Nm{
    int a;
}
int main()
{
    Nm::a=10;
}
```
`namespace 任意の名前空間名{}`とする事で名前空間を定義する事ができます。そしてその名前空間内に定義されたデータには`Nm::`と記述しなければアクセスする事はできません。関数も同様です。
```cpp
namespace Nm{
    void func(){}
}
int main()
{
    Nm::func();
}
```
たった、それだけです。これは一体何に役立つのでしょうか？

### 6.3.1 名前空間の役割
名前空間を定義する事によって、例えば以下のような定義が可能です。
```cpp
namespace Nm1{
    void func(){}
}
namespace Nm2{
    void func(){}
}
int main()
{
    Nm1::func();
    Nm2::func();
}
```
このように名前空間さえ異なれば、関数名とそのシグネチャが同じでも、定義する事ができるのです。また名前空間を名前空間で囲う事も可能です。
```cpp
namespace Nm1{
    namespace Nm2{
        void func(){}
    }
}
int main()
{
    Nm1::Nm2::func();
}
```
この場合、`func`関数を使いたければ、上記のようにそのデータまでのパスを`::`で明示的に示す事でその機能を使う事ができます。また、上記のように名前空間を何重にも内包(ネスト)している名前空間は、以下のように省略して宣言する事もできます。
```cpp
namespace Nm1::Nm2{
    void func(){}
}
int main()
{
    Nm1::Nm2::func();
}
```
この記述法は、Nested Namespace definitionと呼ばれます。
これら名前空間の機能により、例えば自分以外の誰かが作ったライブラリなどを使う際に、自分の定義した識別子がたまたまそのライブラリ内にある識別子名と重なってしまい、自分がその識別子を使う事ができない...といった事を防ぐ事ができます(たまたま同じ名前空間を定義していた場合はダメ)。実はこの機能、今まで触れてきていませんでしたが何気なく使ってきていました。
値を標準出力させるためには、以下のようなコードを書いてきましたね。
```cpp
#include<iostream>
int main()
{
    std::cout<<"hoge"<<std::endl;
}
```
これはつまり、`std`という名前空間に`cout`と`endl`が予め定義されており、それを使っているがための記述だったのです。そしてこれらは、`iostream`ヘッダに定義されています。

### 6.3.2 using宣言
以下のコードで関数`func`を使うためには
```cpp
namespace Nm{
    void func(){}
}
```
以下のように明示的に指定する必要があると述べました。
```cpp
int main()
{
    Nm::func();
}
```
しかし、初めから`Nm`という名前空間内の機能を使うつもりで、識別子の衝突も有り得ないと分かっているようであれば、`Nm::`というように一々明示的に記述するのも面倒です。
そういった場合はusing宣言をすると便利です。
```cpp
namespace Nm{
    void func(){}
}
using namespace Nm;
int main()
{
    func();
}
```
`using namespace 名前空間名`とする事でその名前空間内の全ての宣言/定義を**associated namespace**に加えます。associated namespaceは、直訳すると関連する名前空間という意味です。つまり、明示的に`::`で名前空間を示さなくてもその名前空間内を探索するという事です。名前空間全体ではなく、その名前空間の一部のデータのみを使うというようであれば、以下のように記述します。
```cpp
namespace Nm{
    void func(){}
    void func1(){}
}
using Nm::func;
int main()
{
    func();
    Nm::func1();
}
```
`using Nm::func;`とする事によって、`Nm`名前空間の`func`という関数だけを非修飾的に(名前空間を明示的に示さない事)呼べるようにしています。この時`func1`は`using`宣言されていないため、明示的に名前空間を修飾した記述が必要になります。

### 6.3.3 スコープごとのusing宣言
using宣言にも、スコープという概念はそのまま適用されます。以下のコードを見て見ましょう。
```cpp
namespace Nm{
    void f(){}
}
void func()
{
    using namespace Nm;
    f();
}
int main()
{
    func();
    f();
}   
```
`Nm`名前空間の関数`f`を使うために、`func`関数内で`using namespace`宣言をしました。そして`f()`として関数を呼んでいます。しかし、その後`main`関数内で再度名前空間の明示的な修飾なしに関数`f`を呼んでいます。このコードは正しいでしょうか？残念ながら、このコードはコンパイルエラーとなります。何故かというと、簡単です。`using namespace`宣言がされたのは、関数`func`のスコープ内だけだからです。`main`関数のスコープ内では`using namespace`が適用されませんので、非修飾的に呼び出す事はできません。この場合、グローバル空間に`using namespace`宣言をしてあげる事で動きます。
```cpp
namespace Nm{
    void f(){}
}
using namespace Nm; // グローバル空間でusing namespace宣言
void func()
{
    f();
}
int main()
{
    func();
    f();
}
```
または明示的に修飾します。
```cpp
namespace Nm{
    void f(){}
}
void func()
{
    using namespace Nm;
    f();
}
int main()
{
    Nm::func(); // 明示的に修飾
    f();
}
```
これは、`using namespace`の他に、`using`宣言でも同様です。

### 6.3.4 using宣言による衝突
このコードは文法的に正しいでしょうか。
```cpp
namespace Nm{
    void f(){}
}
using namespace Nm; // or using Nm::f;
void f(){}
int main()
{
    f();
}
```
正解は正しくない、です。何故ならば`using namespace Nm;`とした事で、名前空間`Nm`をassociated namespaceに加えました。しかし、グローバルスコープにも同名、同シグネチャの関数`f`が既に定義されているのです。この場合、同じスコープに全く同じ定義が二つある事になってしまいますのでどちらの関数`f`を呼び出すべきなのか判別する事ができません。当然ですね。
このような事から、あまり不必要に`using`宣言を多用するべきではないと考えられます。あるプロジェクトの中にも、`using`宣言を禁止とするチームも存在しました。しかし、筆者としては全ての機能において言える事ですが、その機能による作用を完全に理解しているのであれば、それを利用する事自体、特に悪い事ではないと考えます。本書では、何の機能を使っているのか視覚的に理解しやすくするため、予め名前空間が設定されている機能を用いる場合は、明示的に完全修飾をした上でその機能を利用するスタイルのサンプルコードが書かれていますが、全ての事象において、名前空間の完全修飾をしなければならないというようには思いません。

### 6.3.5 inline namespace
`inline`キーワードには、関数に`inline`をキーワードを付与する事でインライン展開してほしい旨をコンパイラに伝えられる機能がありましたが、`inline`というキーワード自体は同じであるものの、これはそれとは全く別の機能です。inline namespaceはまず、以下のように使う事ができます。
```cpp
inline namespace Nm{
    void f(){}
}
int main()
{
    f();
}
```
非修飾的に関数`f`を呼び出せています。`inline namespace`は、その名前空間をassociated namespaceに含めるという意味を持ちます。そのため、非修飾的にその内部機能を呼び出す事ができるのです。しかし、これではグローバル定義されたものとなんら変わらないのでは？と思うかもしれません。実はまさにその通りで、このように`inline namespace`をグローバル領域に宣言した場合は機能として全くの意味を持ちません。`inline namespace`の機能が発揮されるのは、名前空間が二重以上にネストされた場合です。
```cpp
namespace Awesome_Lib{
    inline namespace feautures{
        void f(){}
    }
    void g(){}
}

int main()
{
    {
        using namespace Awesome_Lib; // Awesome_Lib名前空間の全ての機能を非修飾的に呼び出す
        f();
        g();
    }
    {
        using namespace Awesome_Lib::feautures; // Awesome_Lib::feautures名前空間のみを非修飾的に呼び出す
        f();
        Awesome_Lib::g(); // 修飾が必要
    }
}
```
`Awesome_Lib`という名前空間内に、`feautures`という名前空間がinline指定されています。このように機能ごとにどこまでを非修飾的に呼び出せるようにするのかをユーザーに指定させる事ができます。またその他に、バージョンマネージメントなどに利用する事ができます。
```cpp
namespace Awesome_Lib{
    inline namespace release{
        void f(){}
    }
    namespace experimental{
        void f(){}
    }
}
int main()
{
    Awesome_Lib::f(); // releaseバージョンを使用する。
    Awesome_Lib::experimental::f(); // 実験的バージョンを使用する。
}
```
`release`名前空間を`inline namespace`にする事で、単に`Awesome_Lib`名前空間だけを修飾すると、`release`をデフォルト設定として機能を使うように出来、明示的に`experimental`名前空間を指定した場合のみ、まだ実験的なバージョンを使えるようにするというような、バージョンごとのマネージメントをする事ができます。


### 6.3.6 名付けてはならない名前空間名
名前空間にも名付けてはならない名前が存在します。基本的には識別子につけてはならない名前と同等ですが、名前空間名を名付けるにおいてはそれに一つ条件が加わります。それは、`std`名前空間を独自に定義してはならないという要件です。`std`名前空間には、規格で厳密に定められた言語機能のみが定義されていなければなりません。`std`名前空間に、独自に機能を追加した場合は規格の保証外(未定義)となりますので絶対にしてはならないのです。しかし、ある条件の場合のみ、新たに`std`名前空間に機能を追加して良い事ともなっています。それについては、「第11章テンプレート」にて説明します。


### 6.3.7 無名名前空間
無名の名前空間を定義する事もできます。
```cpp
namespace{
    void f(){}
}
int main()
{
    ::f();
    f();
}
```
無名の名前空間にアクセスするためには`::`を記述する事で無名名前空間を明記する事ができます。この機能は「6.2.6 static指定子の別のセマンティック」で紹介した機能と同じです。無名名前空間内に定義されたオブジェクトなどへはそのファイル外からアクセスする事はできなくなります。
```cpp
// test.hpp
namespace{
    void f(){}
}
```
```cpp
#include"test.hpp"
int main()
{
    f(); // 不可
    ::f(); // 不可
}
```

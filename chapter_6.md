# 第 6 章 関数、制御区域、名前空間

本章では、関数と制御区域、名前空間の概念について説明します。関数はプログラミング言語の基本的概念でありC++のプログラムは関数の集合であるとも言えます。制御区域と名前空間は、どちらもプログラムを組む上で大切な概念です。全てマスターしていきましょう。
この章では以下のような流れで説明していきます。

1. 関数の概念
    * 記述法
    * 呼び出し
    * inline関数
    * 動的再帰
2. グローバルスコープとローカルスコープ
3. namespace
    * ADL

## 6.1 関数
まず始めに文法を述べてしまいましょう。関数の文法は以下のようになっています。
```cpp
キーワード 戻り値の型 関数名(仮引数名...)キーワード{ 関数の内容 }
```
実際に使ってみましょう。

```cpp
#include<iostream>
int func(){return 42;}
int main()
{
    int a=func();
    std::cout << a << std::endl;
}
```
実行結果は以下となります。

```cpp
42
```
まず、
```cpp
int func(){return 42;}
```
で、文法のどこがどこにに対応しているのか説明します。
まずキーワードですが、これは無しです。キーワードについてはまた再度説明する内容となるのですが、必要でない場合省く事ができます。
戻り値の型というのは`int`の部分です。関数の内容で`return 42;`として`42`を返しています。`42`は整数値のため、戻り値の型の指定は`int`が良いでしょう。
関数名というのは`func`の部分です。この場合、「`int`型の値を戻す関数名func」という意味になります。関数名には「2.2.7 識別子へ名付けてはならない名前」にて扱った名前以外は何でも付ける事ができます。
次に仮引数名ですが、この場合は無しです。仮引数名は必要なければこのように省略することができます。
そして再度キーワードですが、これも今回は指定していません。
最後に関数の内容ですが、先ほども述べた通り`return 42;`の部分となります。
...と一気に述べてしまいましたが、大丈夫です。一つずつ説明していきます。まず、return文について触れておきます。

### 6.1.1 return文
return文は関数からの戻り値を指定する文です。文法は以下のようになります。
```cpp
return リターンする値、変数/オブジェクト;
```
例えば先ほどのfunc関数では`return`文に`42`という値を指定していました。
```cpp
int func(){return 42;}
```
変数を指定することもできます。
```cpp
int func()
{
    int a=42;
    return a;
}
```
この場合、aがコピー/ムーブされて関数の呼び出し元へ値が返されます。返される値はaは42として初期化していますので、42ですね。コピー/ムーブの概念については、また後ほどに説明します。
ところで、例えばこのような記述であった場合、実行結果はどのようになるでしょうか。
```cpp
#include<iostream>
int func(){return 42.5;}
int main()
{
    std::cout<<func()<<std::endl;
}
```
コンパイラによっては警告を出力してくれるかもしれません。実行結果は以下になります。
```cpp
42
```
`42.5`を戻すと記述したはずなのに、出力結果は`42`となっていますね。これは、2.2.4で述べたのと同じように、浮動小数点数値を`int`で返しているため、小数点以下が切り捨てられるためです。では、以下のようにするとどうなるでしょうか。
```cpp
#include<iostream>
char func(){return 65;}
int main()
{
    std::cout<<func()<<std::endl;
}
```
実行結果は以下となります。
```cpp
A
```
`65`を返すとしているのに、`A`と出力されました。これは先ほどと同様、`char`型で返すとしているために行われる暗黙の変換がされているためです。`char`型で65は、丁度文字`A`に該当する数値のため、このように出力されるのです。
因みに、ここまでは戻り値の型として指定した型は全て値を返す関数として定義するため、`int`や`double`、`char`などを使っていましたが、戻り値がない関数を記述する事もできます。そのような場合、戻り値の型に`void`を指定します。
```cpp
void f(){std::cout<<"call f"<<std::endl;}
```
この関数`f`は`void`、つまり、何も返さない関数ですので、`return`文は不要という事になります。

### 6.1.2 引数
先ほど述べた関数`func`には引数がなしであると述べました。
```cpp
int func(){return 42;}
```
関数にはただただ内容を実行するだけでなく、値を渡したりする事ができるのです。では、この関数に対して例えば整数値を渡してみる事としましょう。
```cpp
int func(int x){return x;}
```
これを使って見ます。
```cpp
#include<iostream>
int func(int x){return x;}
int main()
{
    std::cout<<func(42)<<std::endl;
}
```
実行結果は以下となります。
```cpp
42
```
`func`に`int x`として仮引数名を指定しました。このように記述する事で、int型を受け取る関数として宣言/定義することができます。この関数を呼び出すためには、`func(値/変数/オブジェクト)`と記述します。今回は`func(42)`としていますので`func`関数には`42`が渡ります。その値が仮引数である`x`に渡りそれをそのまま`return`によって返していますので、出力結果は`42`となります。引数を受け取れる関数を使えれば、例えばこのような事ができます。
```cpp
#include<iostream>
int plus(int x,int y){return x+y;}
int main()
{
    std::cout<<plus(10,10)<<std::endl;
}
```
出力結果は以下となります。
```cpp
20
```
引数として渡された`x`と`y`が、`+`演算子によって加算処理が行われます。関数`plus`の第一引数`x`に指定した値は`10`、第二引数`y`に指定した値も`10`ですので、`x+y`では`20`という演算結果が得られます。それを返し、その結果をそのまま出力しろとしているので`20`が出力されます。

### 6.1.3 宣言と定義

変数/オブジェクトにも変数の宣言と定義があったように、関数にも宣言と定義があります。例えば以下のように書いた場合、
```
int main()
{
    f(42);
}
```
このコードはコンパイルエラーとなります。当然です、関数`f`に`42`という値を渡しているように読み取れはしますが、肝心な関数`f`の宣言も定義もないからです。C++は、全て何かを使おうとする場合、あらかじめ宣言/定義を済ませて置かなければなりません。このコードは以下のように宣言/定義してあげる事でコンパイルが通ります。
```cpp
void f(int x){}
int main()
{
    f(42);
}
```
これを、もしこのように書いた場合、どうなるでしょうか。
```cpp
int main()
{
    f(42);
}
void f(int x){}
```
これはコンパイルエラーとなります。関数`f`の呼び出しが`main`関数内で行われていますが、呼び出された時点では関数`f`についての宣言が全くないため、コンパイラとしては知り得る事ができません。
関数を呼び出すためには、宣言が事前にあれば良いのです。関数の宣言は、以下のように記述します。
```cpp
void f(int x);
int main()
{
    f(42);
}
```
関数の内容部分の記述がなく、`;`で終わっていますね。これを、**プロトタイプ宣言**と言います。しかし、実はこの記述だけだと、コンパイラはエラーを吐きます。なぜでしょうか。確かに、関数`f`を定義するという事はコンパイラに伝わりました。しかしこの記述だけだと、関数`f`が何をするのかが定義されていないため、その関数を実行する事はできないのです。つまり、その関数が何をする関数なのかを記述する必要があります。
```cpp
void f(int x); // 宣言
int main()
{
    f(42);
}
void f(int x){} // 実装
```
これで、コンパイルが通るようになりました。このように、**実際に関数が呼び出される前に宣言さえされていれば**、その内部実装(関数の内容部分)はどの部分にあってもコンパイルする事ができます。今回は関数の内容部分に何も記述していないので、この関数`f`は何もしません。因みに、宣言部分では、仮引数名を省略する事ができます。
```cpp
void f(int);
int main()
{
    f(42);
}
void f(int x){}
```
宣言時の記述では、`int`とだけしか記述されていませんが、コンパイラーとしては**何が戻り値でどういう名前の関数で、どういう型の引数がくるのか**さえ事前に分かっていれば良いので、仮引数名は省略する事ができます。
...ここまで読んでみて、宣言と定義を同時に行う方法と、それぞれを分離する方法、なぜこの二つの記述法があるのかと疑問に思うかもしれません。勿論分離する事による利点があるからこのような機能があるのですが、それについては関数とはまた違うカテゴリーの説明となりますので後述する事とします。

### 6.1.4 デフォルト引数
デフォルトの引数を設定する事ができます。例えば、以下のように記述できます。
```cpp
#include<iostream>
void f(int x=42)
{
    std::cout<<x<<std::endl;
}
int main()
{
    f();
}
```
実行結果は以下となります。
```cpp
42
```
関数`f`の定義部分で仮引数`x`に対して`42`をデフォルト指定しています。この場合、関数`f`の呼び出し時に、引数として何も設定しなければ(`f();`の部分)、`x`は`42`として処理されます。宣言と定義を分離した場合は、以下のように記述します。
```cpp
#include<iostream>
void f(int=42);
int main()
{
    f();
}
void f(int x)
{
    std::cout<<x<<std::endl;
}
```
実行結果は変わらず、`42`と出力されます。宣言部分にデフォルト引数を指定して、定義部分には指定していません。これは、デフォルト引数を指定する場合は宣言部分に指定し、定義部分には記述しないという文法的な決まりです。

### 6.1.5 inline関数
先ほどからの説明で戻り値の型の前に指定できる、キーワードの部分を一切指定せず宣言/定義してきましたが、指定できるキーワードの一つとして、`inline`というキーワードがありますので説明します。例えば、以下のように記述します。
```cpp
#include<iostream>
inline void f(int x){std::cout<<x<<std::endl;}
int main()
{
    f(42);
}
```
戻り値の型の前に指定していますね。関数に`inline`キーワードを付与すると、どのような事が起きるのか、それはC++コードと実行結果だけでは視覚的に違いを確認できません。しかし、勿論意味はあります。意味は、コンパイルの段階で、内部処理として関数の内容をその呼び出し部分で展開**してほしい**という意味になります。つまり、コンパイルの最適化の段階で、先ほどのコードを以下のように**してほしい**とコンパイラに訴えかけるキーワードなのです。
```cpp
#include<iostream>
int main()
{
    std::cout<<42<<std::endl;
}
```
関数`f`の内容を、呼び出し元である`main`関数内に完全に展開して関数呼び出しさえなくなっています。ただこれは一例であってコンパイラによってinline展開の解釈は異なります。また、先ほどから**してほしい**と太文字にしている通り、これはコンパイラに対する単なる要望なので、実際にinline展開されるかどうかはこれまた分かりません。また、最近のコンパイラであれば、わざわざ`inline`キーワードを指定しなくても勝手に高速に動くように最適化してくれる事もあるので、あまり意図的に指定する必要もないかもしれません。
ところで、inline展開される事によってどのような利点があるのでしょうか。それは、関数呼び出しのオーバーヘッドがなくなるという点で利点があるのです。これについては、また後述します。しかし、欠点もあります。それは、
# 第 6 章 関数、制御区域、名前空間

本章では、関数と制御区域、名前空間の概念について説明します。関数はプログラミング言語の基本的概念でありC++のプログラムは関数の集合であるとも言えます。制御区域と名前空間は、どちらもプログラムを組む上で大切な概念です。全てマスターしていきましょう。
この章では以下のような流れで説明していきます。

1. 関数
2. グローバルスコープとローカルスコープ、static変数
3. Namespace

## 6.1 関数
まず始めに文法を述べてしまいましょう。関数の文法は以下のようになっています。
```cpp
キーワード1 戻り値の型 関数名(仮引数型 仮引数名...)キーワード2{ 関数の内容 }
```
実際に使ってみましょう。

```cpp
#include<iostream>
int func(){return 42;}
int main()
{
    int a=func();
    std::cout << a << std::endl;
}
```
実行結果は以下となります。

```cpp
42
```
まず、以下の関数
```cpp
int func(){return 42;}
```
が、それぞれ文法どこにに対応しているのかを説明します。

* キーワード1はこの場合、無しです。キーワードについてはまた再度説明する内容となるのですが、必要でない場合省く事ができます。
* 戻り値の型は`int`の部分です。関数の内容で`return 42;`として`42`を返しています。`42`は整数値のため、戻り値の型の指定は`int`が良いでしょう。
* 関数名は`func`の部分です。この場合、「`int`型の値を戻す関数名func」という意味になります。関数名には「2.2.7 識別子へ名付けてはならない名前」にて扱った名前以外は何でも付ける事ができます。
* 仮引数型と仮引数名は、この場合無しです。仮引数名は、その関数が引数を取らない場合、記述する必要はありません。
* キーワード2もこの場合指定していませんので無しです。
* 関数の内容は、先ほども述べた通り`return 42;`の部分となります。

...と一気に述べてしまいましたが、大丈夫です。一つずつ説明していきます。

### 6.1.1 return文
return文は関数からの戻り値を指定する文です。文法は以下のようになります。
```cpp
return リターンする値、変数/オブジェクト;
```
例えば先ほどの`func`関数では`return`文に`42`という値を指定していました。
```cpp
int func(){return 42;}
```
変数を指定することもできます。
```cpp
int func()
{
    int a=42;
    return a;
}
```
この場合、`a`はコピーされて、関数の呼び出し元へ値が返されます。返される値、`a`は宣言段階で`42`に初期化していますので、`42`ですね。コピーなどの概念については、また後ほどに説明します。

#### 返却値における暗黙の変換

ところで、例えばこのような記述であった場合、実行結果はどのようになるでしょうか。
```cpp
#include<iostream>
int func(){return 42.5;}
int main()
{
    std::cout<<func()<<std::endl;
}
```
コンパイラによっては警告を出力してくれるかもしれません。実行結果は以下になります。
```cpp
42
```
`42.5`を戻すと記述したはずなのに、出力結果は`42`となっていますね。これは、2.2.4で述べたのと同じように、浮動小数点数値を`int`で返しているため、小数点以下の数値の切り捨てが行われます。そのため`42`が返ってくるのです。では、以下のようにするとどうなるでしょうか。
```cpp
#include<iostream>
char func(){return 65;}
int main()
{
    std::cout<<func()<<std::endl;
}
```
実行結果は以下となります。
```cpp
A
```
`65`を返すとしているのに、`A`と出力されました。これも同様、`char`型で返すとしているために行われる暗黙の変換がされているからです。`char`型で`65`は、丁度文字`A`に該当する数値のため、文字`A`が返るのです。

#### 何も返さない関数

ここまでは戻り値の型として指定した型は、全て値を返す関数として定義するため、`int`や`double`、`char`などを例題に使いましたが、戻り値がない関数を記述する事もできます。そのような場合、戻り値の型に`void`を指定します。
```cpp
void f(){std::cout<<"call f"<<std::endl;}
```
この関数`f`は`void`、つまり、何も返さない関数ですので、`return`文は不要という事になります。

### 6.1.2 引数
関数の章の冒頭で述べた関数`func`には、仮引数型と仮引数名が無いと述べました。
```cpp
int func(){return 42;}
```
では、仮引数型と仮引数名があるとは、どういう状態を言うのでしょうか。それは以下のような場合です。
```cpp
int func(int x){return x;}
```
関数の文法には、その関数内でただただ内容を実行するだけではなく、その関数に対して値を渡したりする機能があります。上記の関数の場合、仮引数型と仮引数名の部分に、`int x`と記述されていますので、「この関数は整数値を受け取りその整数値はxである」という意味になります。それでは関数を使って、整数値を渡してみましょう。
```cpp
#include<iostream>
int func(int x){return x;}
int main()
{
    std::cout<<func(42)<<std::endl;
}
```
実行結果は以下となります。
```cpp
42
```
`func`に`int x`として仮引数名を指定しました。このように記述する事で、int型を受け取る関数として宣言/定義することができます。この関数を呼び出すためには、
```cpp
func( 値/オブジェクト );`
```
と記述します。今回は`func(42);`としていますので`func`関数には`42`という値が渡されます。その値は関数`func`内で`x`という変数で扱われます。それを、そのまま`return`によって返していますので、出力結果は`42`となります。理解を深めるため別のサンプルも見て見ましょう。
```cpp
#include<iostream>
int plus(int x,int y){return x+y;}
int main()
{
    std::cout<<plus(10,10)<<std::endl;
}
```
出力結果は以下となります。
```cpp
20
```
引数として渡された`10`と`10`が、それぞれ関数`plus`内で`x`、`y`変数として扱われます。それらが`+`演算子によって加算されています。`x + y`は`10 + 10`となりますので、`20`という演算結果が得られます。その値を返し、それをそのまま出力しろとしているので、`20`が出力されます。

### 6.1.3 宣言と定義

変数/オブジェクトにも変数の宣言と定義があったように、関数にも宣言と定義があります。例えば以下のように書いた場合、
```cpp
int main()
{
    f(42);
}
```
このコードはコンパイルエラーとなります。当然です、関数`f`に`42`という値を渡しているように読み取れはしますが、肝心な関数`f`の宣言も定義もないからです。C++は、全て何かを使おうとする場合、あらかじめ宣言/定義を済ませて置かなければなりません。このコードは以下のように宣言/定義してあげる事でコンパイルが通ります。
```cpp
void f(int x){}
int main()
{
    f(42);
}
```
これを、もしこのように書いた場合、どうなるでしょうか。
```cpp
int main()
{
    f(42);
}
void f(int x){}
```
これはコンパイルエラーとなります。関数`f`の呼び出しが`main`関数内で行われていますが、呼び出された時点では関数`f`についての宣言が全くないため、コンパイラはその存在を知り得る事ができません。
関数を呼び出すためには、宣言が事前にあれば良いのです。関数の宣言は、以下のように記述します。
```cpp
void f(int x);
int main()
{
    f(42);
}
```
関数の内容部分の記述がなく、`;`で終わっていますね。これを、**プロトタイプ宣言**と言います。しかし、実はこの記述だけだと、コンパイラはエラーを吐きます。なぜでしょうか。確かに、関数`f`を宣言するという事はコンパイラに伝わりました。しかしそれだけだと、関数`f`が何をするのかが定義されていないため、その関数を実行する事はできないのです。つまり、その関数が何をする関数なのかを記述する必要があります。
```cpp
void f(int x); // 宣言
int main()
{
    f(42);
}
void f(int x){} // 実装
```
これで、コンパイルが通るようになりました。このように、**実際に関数が呼び出される前に宣言さえされていれば**、その内部実装(関数の内容部分)はどの部分にあってもコンパイルする事ができます。今回は関数の内容部分に何も記述していないので、この関数`f`は何もしません。因みに、宣言部分では、仮引数名を省略する事ができます。
```cpp
void f(int);
int main()
{
    f(42);
}
void f(int x){}
```
宣言時の記述では、`int`とだけしか記述されていませんが、コンパイラーとしては**何が戻り値でどういう名前の関数で、どういう型の引数がくるのか**さえ事前に分かっていれば良いので、仮引数名は省略する事ができます。
...ここまで読んでみて、宣言と定義を同時に行う方法と、それぞれを分離する方法、なぜこの二つの記述法があるのかと疑問に思うかもしれません。勿論分離する事による利点があるからこのような機能があるのですが、それについては関数とはまた違うカテゴリーの説明となりますので、後述する事とします。

### 6.1.4 デフォルト引数
デフォルトの引数を設定する事ができます。例えば、以下のように記述できます。
```cpp
#include<iostream>
void f(int x=42)
{
    std::cout<<x<<std::endl;
}
int main()
{
    f();
}
```
実行結果は以下となります。
```cpp
42
```
関数`f`の定義部分で仮引数`x`に対して`42`をデフォルト指定しています。この場合、関数`f`の呼び出し時に、引数として何も設定しなければ(`f();`の部分)、`x`は`42`として処理されます。宣言と定義を分離した場合は、以下のように記述します。
```cpp
#include<iostream>
void f(int=42);
int main()
{
    f();
}
void f(int x)
{
    std::cout<<x<<std::endl;
}
```
実行結果は変わらず、`42`と出力されます。宣言部分にデフォルト引数を指定して、定義部分には指定していません。これは、デフォルト引数を指定する場合は宣言部分に指定し、定義部分には記述しないという文法的な決まりです。
最後に、これはどのような出力結果となるでしょうか。
```cpp
#include<iostream>
void f(int x=42)
{
    std::cout<<x<<std::endl;
}
int main()
{
    f(10);
}
```
実行結果は以下となります。
```cpp
10
```
デフォルト引数は`42`と指定されていますが、呼び出し時に関数`f`に対して`10`を渡していますので、その出力結果は`10`となります。
逆に、このような記述はできるのでしょうか。
```cpp
void f(){}
int main()
{
    f(42);
}
```
これはコンパイルエラーとなります。仮引数型と仮引数名が定義されていない関数に対して値を指定して呼び出す事はできません。
### 6.1.5 inline関数
先ほどからの説明で戻り値の型の前に指定できる、キーワードの部分を一切指定せず宣言/定義してきましたが、指定できるキーワードの一つとして、`inline`というキーワードがあります。
まず前提として、関数呼び出しは通常処理としてはあまり高速ではありません。これには諸々の理由があるのですが、それは後述するとして、例えば、以下の二つのプログラムであれば文脈としては前者の方が高速に動作します。(最適化によって処理速度は変わらない可能性もある)
```cpp
#include<iostream>
int main()
{
    std::cout<<42<<std::endl;
}
```
```cpp
#include<iostream>
void f(int x){std::cout<<x<<std::endl;}
int main()
{
    f(42);
}
```
実行結果はどちらも変わりません。しかし、後者の方が遅い記述です。何故ならば、**関数呼び出しは高速ではないからです**。
しかし、書き方として、`main`関数に全ての処理内容を書かず、機能ごとに関数として分離したいという要望もあるのです。その要望に応えて関数として分けた結果、`main`関数に直接記述したよりも処理が遅くなってしまうというのは困ります。そのような時に、`inline`キーワードを指定します。
```cpp
#include<iostream>
inline void f(int x){std::cout<<x<<std::endl;}
int main()
{
    f(42);
}
```
戻り値の型の前に指定していますね。このように`inline`を指定する事で、コンパイルの段階で、内部処理として関数の内容をその呼び出し部分で展開**してほしい**とコンパイラに伝える事ができます。つまり、コンパイルの最適化の段階で、先ほどのコードを以下のような**感じ**に**してほしい**とコンパイラに訴えかけられるという事です。
```cpp
#include<iostream>
int main()
{
    std::cout<<42<<std::endl;
}
```
関数`f`の内容を、呼び出し元である`main`関数内に完全に展開して関数呼び出しさえなくなっています。これは一番初めに示した最も高速な記述であるプログラムと同じコードですね。
**感じ**と曖昧にしているのは、コンパイラによってinline展開の解釈が異なるためです。また、**してほしい**と太文字にしているのは、コンパイラに対する単なる要望だからです。
実際にinline展開されるかどうかは、実は分かりません。コンパイラがinline展開段階でその利点と欠点をどのように判断するかによって処理が異なるからです。

ここでinline展開される事による利点と欠点を整理しましょう。まず利点は、先ほども述べた通り、関数呼び出しの遅さを無くす事ができます。では欠点はなんでしょうか。それはプログラムサイズが増えてしまうという点です。
インライン展開をする事と、呼び出しの元の関数内に処理を埋め込むわけ事となります。つまり、プログラムサイズが増えてしまうのです。

そこで、大抵のコンパイラは、インライン展開する事でプログラムサイズが肥大化してしまうかどうかを判定します。そしてその判定結果に応じて、インライン展開を行うかどうか判断します。`inline`展開されなかった場合、`inline`指定していない関数と同じように、通常の関数としてそのまま定義されます。これはコンパイラが自動的に判断しますので、自分で制御することはできません。
以上の点から、最近のコンパイラであれば、わざわざ`inline`キーワードを指定しなくても勝手に高速に動くように最適化してくれるという点から、あまり意図的に指定する必要も現代ではないかもしれません。

### 6.1.6 関数の動的再起呼び出し
関数を再起的に呼び出すこともできます。
```cpp
#include<iostream>
void f(int i)
{
    if(i<5){
        std::cout<<i<<" ";
        f(i+1);
    }
}
int main()
{
    int a=0;
    f(a);
    std::cout<<std::endl;
}
```
実行結果は以下となります。
```cpp
0 1 2 3 4
```
main関数で`0`で初期化された変数aが定義されています。それを関数`f`に渡します。`if`文で`i<5`の時実行すると分岐しています。渡された変数`a`は関数`f`では仮引数によって`i`とされています。つまり`i`は`0`ですから`i<5`はtrueのため`if`文中のコードは実行されます。そこでは`i`の内容を出力し、その後自分自身である関数`f`に`i`に`1`を加算した値を渡し呼び出しています。このように自分自身を呼び出すループを再起呼び出しと言います。しかし、このように動的に関数を再起的に呼び出すの事はとても非効率的ですからあまり用いるべきではありません。(動的とは、プログラム実行時に行う事を言います。それに対照的なのが静的です。これは、実行時に処理を行うのではなく、実行時には既に決まっているもの全般を普遍的に言います。これについては後の章で説明します。)なぜならば先ほども述べた通り、**関数呼び出しは決して高速ではないから**です。同じような処理、結果を求めるのであれば、解決方法は様々ですが、例えば以下のように書くべきです。
```cpp
#include<iostream>
void f(int i)
{
    for(; i<5; ++i)std::cout<<i<<" ";
}
int main()
{
    int a=0;
    f(a);
    std::cout<<std::endl;
}
```
関数を再起的に呼び出すのではなく、`for`ループで同機能を実現しています。関数呼び出しそのものは遅いですから、それを何度も連続的に行わせる動的な再起処理は、特別な理由で必要がない限り、用いるべきではありません。

### 6.1.7 オーバーロード
C++には、同じ第2章でも説明した通り、One Definition Ruleというルールがあります。これは、同じ識別子を二つ以上同スコープ内で宣言/定義する事は許されないという決まりです。しかし、例えばこのような事がしたいと思うかもしれません。
```cpp
#include<iostream>
int plus_int(int x,int y){return x+y;}
double plus_double(double x,double y){return x+y;}
int main()
{
    std::cout<<plus_int(10,20)<<std::endl;
    std::cout<<plus_double(10.5,20.4)<<std::endl;
}
```
実行結果は以下となります。
```cpp
30
30.9
```
関数名も一つの識別子です。そこで、ODRを意識して`int`型用の`plus_int`という関数と、`double`型用の`plus_double`という関数を作りました。これは、規格に一切違反していませんから正しいコードと言えます。しかし、渡す値が`int`型であるか`double`型であるかだけで、一々関数名を変えるというのはあまりユーザーとしては使いやすいものではありません。ユーザーからすれば、何の型の値を加算するのかを意識するのではなく、やりたい事はただとにかく加算がしたいわけですから、渡された値の型が`int`だろうが`double`だろうが関数呼び出しには`plus`だけで統一したいものです。オーバーロードは、それを叶える機能です。
```cpp
#include<iostream>
int plus(int x,int y){return x+y;}
double plus(double x,double y){return x+y;}

int main()
{
    std::cout<<plus(10,20)<<std::endl;
    std::cout<<plus(10.5,20.4)<<std::endl;
}
```
実行結果は先ほどと同じです。なんとODRというルールがありながら、`plus`という名前の関数を二つも定義しています。これは違反ではなく正しいコードです。実は**コンパイラが関数を識別する際に使っているのは、関数名だけではなく、それに加えて関数の仮引数型らを含めて識別している**のです。(仮引数の並び、それらをシグネチャと言ったりします。)
つまり確かに、`plus`という関数名は同じです。しかし、`int`を受け取るのか、`double`を受け取るのか、その部分が双方で異なりますのでコンパイラは別の関数として捉える事ができるのです。理解を深めるため、また少し違うサンプルを見て見ましょう。
```cpp
#include<iostream>
int plus(int x){return x;}
int plus(int x,int y){return x+y;}
int plus(int x,int y,int z){return x+y+z;}

int main()
{
    std::cout<<plus(10)<<std::endl;
    std::cout<<plus(10,20)<<std::endl;
    std::cout<<plus(10,20,30)<<std::endl;
}
```
実行結果は以下となります。
```cpp
10
30
60
```
関数名は全て`plus`で、仮引数の型も全て`int`ですが、仮引数の数が違うので、これはオーバーロードする事ができます。単純ですね。その調子で、次のサンプルを見て見ます。
```cpp
#include<iostream>
int plus(int x,int y){return x+y;}
int plus(int y,int x){return y+x;}

int main()
{
    std::cout<<plus(10,20)<<std::endl;
    std::cout<<plus(10,20)<<std::endl;
}
```
これはコンパイルに成功するでしょうか。答えはNOです。何故ならば、ODRを違反しているからです。確かに、仮引数名の並びは`int x,int y`と、`int y,int x`で双方ともに異なります。しかし、コンパイラが識別に見ているのは仮引数名ではなく、仮引数の型です。そう見ると、どちらも`int`型のデータを2つ受け取る関数`plus`ですから、全く同じ定義となります。全く同じ定義はODRに違反しますので、コンパイルエラーとなるのです。
どんどん行きましょう。以下の場合はどうなるでしょうか。
```cpp
int func(int){return 42;}
double func(int){return 42.5;}
int main()
{
    func(10);
}
```
関数の戻り値型がそれぞれ違います。...が、残念ながら、戻り値型のみ違う関数もODR違反となります。別の関数として識別するのには関数名とそのシグネチャのみですから文法的に正しくないコードとなります。...しかし、実は戻り値だけが違う関数のオーバーロードをシミュレートできる機能がC++には備わっています。それについては「第11章テンプレート」にて説明しますので、楽しみにしていてください。

#### 関数とリテラル

少しここで、リテラルという概念に触れておきます。以下のような場合、コンパイラはどのように動くでしょうか。
```cpp
#include<iostream>

void func(unsigned int)
{
    std::cout<<"the argument type is unsigned int !"<<std::endl;
}
void func(int)
{
    std::cout<<"the argument type is signed int !"<<std::endl;
}
int main()
{
    func(10);
}
```
実行結果は以下となります。
```cpp
the argument type is signed int !
```
`10`という数値は、`unsigned int`にも`signed int`にも互換性のある値です。しかし、しっかりと呼び分ける事ができています。これを感覚的に捉えるには、まず`10`という値は、要するに`+10`であるのだ、と捉えると良いでしょう。`+`というsignが付いているので、`signed int`を取る関数`func`が呼ばれるのです。では、`10`を`unsigned`な`int`として表記するにはどうすれば良いのでしょうか。それは、以下のように記述します。
```cpp
10u
```
では関数`func`の呼び出しに`10u`を渡して見ましょう。
```cpp
#include<iostream>
void func(unsigned int)
{
    std::cout<<"the argument type is unsigned int !"<<std::endl;
}

void func(int)
{
    std::cout<<"the argument type is signed int !"<<std::endl;
}
int main()
{
    func(10u);
}
```
実行結果は以下となります。
```cpp
the argument type is unsigned int !
```
`unsigned int`を受け取る関数`func`が無事呼び出されました。しかしまだ`signed`と`unsigned`以外にも、例えば`double`と`float`が同じ問題を抱えています。
```cpp
#include<iostream>
void func(float)
{
    std::cout<<"the argument type is float !"<<std::endl;
}
void func(double)
{
    std::cout<<"the argument type is double !"<<std::endl;
}
int main()
{
    func(10.5);
}
```
実行結果は以下となります。
```cpp
the argument type is double !
```
`10.5`を渡しています。しかし`double`型も`float`型もどちらも小数点を扱う事のできる型です。それでいて`double`型を受け取る関数`func`が呼び出されました。`float`としての数値を表したいのに！...ご安心ください。float用にも、その機能は備えられています。
```cpp
#include<iostream>
void func(float)
{
    std::cout<<"the argument type is float !"<<std::endl;
}
void func(double)
{
    std::cout<<"the argument type is double !"<<std::endl;
}
int main()
{
    func(10.5f);
}
```
このような`u`、`f`をリテラルと言います。リテラルはまだ少し奥深いところがありますので、後ほどまた詳しく解説します。

## 6.2 グローバルスコープとローカルスコープ、static変数

この項ではスコープという概念について説明します。今まで変数を宣言/定義する時、全て関数の中に記述をしてきました。
```cpp
int main()
{
    int x;
}
```
実は、関数外にも変数を宣言する事ができるのです。
```cpp
int x;

int main(){}
```
この時、変数`x`はグローバルスコープにあると言えます。ではローカルスコープとはどのような事を言うのでしょうか。それは、以下のような時を言います。
```cpp
int main()
{
    int x;
}
```
変数`x`は`main`関数というローカルスコープにあると言えます。たったこれだけの事です。たったこれだけの事なのですが、実は両者は全くの別物なのです。

### 6.2.1 ローカルスコープ
まず、グローバルスコープの理解のためにローカルスコープを説明します。前述した通りローカルスコープとは、例えば以下のような事を言います。
```cpp
int main()
{
    int x=10;
}
```
この場合、他のスコープからは`main`関数内の変数`x`を見つける事はできません。
```cpp
int f();
int main()
{
    int x=10;
}
int f()
{
    return x+1; // エラー。関数fのスコープでxは定義されていない
}
```
通常、別のスコープへ値を渡したい場合は、関数の引数として渡す事で実現できます。
```cpp
int f(int);
int main()
{
    int x=10;
    f(x);
}
int f(int x)
{
    return x+1;
}
```
このようなスコープ内の領域を**ローカルスコープ**と言います。

### 6.2.2 グローバルスコープ
グローバルスコープに変数を宣言/定義しそれを使って見ます。
```cpp
int x=10;
void func(){x=20;}
int main()
{
    func();
    std::cout<<x<<std::endl;
}
```
実行結果は以下となります。
```cpp
20
```
このコードから分かる事は、グローバル領域に宣言/定義された変数はどのスコープからでも見えるという事です。このようなスコープ外の領域を**グローバルスコープ**と言います。ローカルスコープの変数はその内包している関数の終端で破棄されますが、グローバル変数はプログラムが完全に終了するまで破棄されないため、グローバルスコープに宣言された変数はローカル変数よりも寿命が長いと言えます。

### 6.2.3 メモリ領域
メモリ領域の観点から見ると、グローバルスコープとローカルスコープの違いは歴然です。その違いを理解するために、まずメモリ領域について説明します。以下は、C++言語で扱うメモリの論理的な模式図です。
![](/assets/memory.jpg)
各領域の役割は、以下の通りです。
* テキスト領域：機械語に翻訳されたプログラム本体が格納されます。
* 静的領域：グローバル変数、static変数などの静的変数が置かれる。
* ヒープ領域：メモリの動的管理 (malloc関数、new 演算子によってメモリを確保する事) に利用されます。
* スタック領域：CPUのレジスタの内容を一時的に退避させたり、自動変数 (多くのローカル変数) の格納、管理に用いられます。

各領域の役割の内には、まだ現時点では説明していない概念が含まれていますが、後々全て説明していきますので、今は分からなくても大丈夫です。
このようにメモリ領域の観点から考えると、グローバル変数とローカル変数は格納される領域がそれぞれ異なります。それでは、実際のC++コードからそれぞれがどの領域に格納されるのかを見て見ましょう。
```cpp
int plus(int x,int y){return x+y;}
int global_variable; // グローバル変数
int main()
{
    int x=10,y=20;
    int result=plus(x,y);
}   
```
それぞれ、以下のように各領域が格納されています。(関数アドレスについては、また後に説明します。)

| 静的領域(グローバルスコープ) | スタック領域(ローカルスコープ) |
| -- | -- | 
| plus関数アドレス | plus関数内変数x | 
| main関数アドレス | plus関数内変数y |
| 変数global_variable | main関数内変数x | 
| | main関数内変数y |
| | main関数内変数result |

### 6.2.4 領域毎のOne Definition
ところで、グローバル領域とローカル領域で同じ名前の識別子を使用する事はできるでしょうか。
```cpp
int x;
int main()
{
    int x;
}
```
これは、できます。グローバル領域の`x`とローカル領域の`x`は、領域がそれぞれ違うので別物として扱う事ができます。これは「5.1 スコープ」で説明した内容と同じです。

### 6.2.5 static変数
例えば、ある関数があったとします。その関数は呼ばれる度に、自身が何回呼ばれたのかを出力する関数だとします。
```cpp
void func()
{
    int i=1;
    std::cout<< i++ <<std::endl;
}
int main()
{
    for(unsigned int a=0; a<5; ++a)func();
}
```
実行結果は以下となります。
```cpp
1
1
1
1
1
```
これは失敗ですね。`for`文で`func`関数を5度呼び出していますが、うまくカウントできていません。理由は単純です。カウントする関数`func`内の変数`i`は、`func`内のローカル変数だからです。何か哲学的な事を言っているように聞こえるかもしれませんが、これは事実です。要するに、カウントするための変数`i`は`func`関数が実行されると`0`で初期化され、その後、後置インクリメントによって遅延的に`i`の値は`1`となりますが、そこで関数が終了してしまうため、変数`i`は破棄されてしまうのです。その後、また関数`f`が呼ばれ、同じ事を繰り返すのですから、永遠に0から変わらないのは当然です。これを解決する一つの方法として、プログラムが終了するまで、確保した領域が破棄されない変数を使うという方法がありますね。まずは、先ほどから紹介している、**グローバル変数**を用いる方法があるでしょう。
```cpp
int i=1;
void func()
{
    std::cout<< i++ <<std::endl;
}
int main()
{
    for(unsigned int a=0; a<5; ++a)func();
}
```
実行結果は以下となります。
```cpp
1
2
3
4
5
```
グローバル領域に変数を宣言したため、プログラムが終了するまでその変数は破棄されません。また、どこからでもその変数を見る事ができます。その結果、意図した通りの処理を行う事ができました。
しかし、グローバル変数とは別の手段で、プログラムが終了するまで破棄されない変数を定義する方法があるのです。それが、**static変数**です。
```cpp
void func()
{
    static int i=1;
    std::cout<< i++ <<std::endl;
}
int main()
{
    for(unsigned int a=0; a<5; ++a)func();
}
```
実行結果は以下となります。
```cpp
1
2
3
4
5
```
`static`指定子を変数宣言時の型の前に付与する事で、その変数をstatic変数とする事ができます。`static`変数は、グローバル変数と同様、プログラムが終了するまでその変数は破棄されません。しかし、グローバル変数とは違ってスコープは`func`関数内にありますので、例えば上記コードの場合、`main`関数から変数`i`を見つける事はできません。
因みに、ローカル変数は初期化も代入もせずその変数を参照しようとすると、どんな値が入っているかは分かりませんでしたが、
```cpp
#include<iostream>
int main()
{
    int x;
    std::cout<<x<<std::endl; // 何が出力されるか未定義
}
```
グローバル変数やstatic変数は初期化時に勝手に値0で初期化される事が決まっています。
```cpp
#include<iostream>
int a;
int main()
{
    static int b;
    std::cout<<a<<std::endl; // 0
    std::cout<<b<<std::endl; // 0
}
```

### 6.2.6 static指定子の別のセマンティック
セマンティックとはかなり簡潔に述べると意味論といったところです。実は、static指定子には別の意味合いもあります。それは、**そのファイル内でしかそのデータにアクセスする事はできない**という意味合いです。例えば以下のように記述されているファイルがあったとします。それは`test.hpp`という名前だとします。
```cpp
// test.hpp
static int data;
```
これをインクルードして変数`data`を使って見ましょう。
```cpp
#include"test.hpp"
int main()
{
    data=10;
}
```
...という事ができないようにする事ができるます。つまり、変数`data`にアクセスできるのは`test.hpp`というファイルの中だけで、インクルードした先でその変数に対してアクセスする事はできません。これは、ファイルごとの動作の安全性を確立するためにある機能であり、例えば変数をそのファイル内のグローバルスコープには起きたいが、他のファイルからはその変数を使えないようにしたいといった時に効力を発揮します。これは関数などでも同じです。しかしこの機能は、`static`変数とはまた異なって`static`というキーワードに異なる機能/意味合いを持たせていることからあまり分かりやすいとは言えません。staticキーワードは、本来は記憶クラスを静的にする意味の修飾子です。しかしこのように特例として、宣言した時点で最初から記憶クラスが静的なものにstaticをつけた場合、名前をファイルスコープに制限する意味となります。このように変則的に意味が変わるのはあまり分かりやすいとは言えません。

そこで、そのファイル中でしかアクセスする事ができないようにするという機能は、別の方法で実現する事ができるようになっています。それは後ほど、名前空間の項で説明します。

### 6.2.7 領域の概念から考察する設計デザイン
このようにグローバル領域に宣言されたデータと`static`指定子が付与されたデータはプログラムが終了するまで破棄されません。しかし逆を言えば、両者ともプログラムが終了するまで破棄されないで欲しいという必要性に迫られない限り、静的領域にデータを確保しても意味がなく、無駄であるとも言えるのです。更に特にグローバル領域に関して言えば、プログラムのどこからでも見えてしまうというそのあまりにも広い自由度から、バグの温床になってしまう事も考えられるため、グローバル変数自体の使用を禁止するというプロジェクトルールを掲げるチームも中には存在します。実際のところ、機能を理解している上で本当に必要であれば、使うべきです。しかし、単に単純だからといった無意味な理由でその機能を使うのは、辞めるべきです（領域の概念以外でも全てにおいて言える事ですが）。

## 6.3 Namespace
C++には名前空間(namespace)という概念があります。名前空間は、これまたスコープなどに関する概念です。まず、名前空間は以下のように使います。
```cpp
namespace Nm{
    int a;
}
int main()
{
    Nm::a=10;
}
```
`namespace 任意の名前空間名{}`とする事で名前空間を定義する事ができます。そしてその名前空間内に定義されたデータには`Nm::`と記述しなければアクセスする事はできません。関数も同様です。
```cpp
namespace Nm{
    void func(){}
}
int main()
{
    Nm::func();
}
```
たった、それだけです。これは一体何に役立つのでしょうか？

### 6.3.1 名前空間の役割
名前空間を定義する事によって、例えば以下のような定義が可能です。
```cpp
namespace Nm1{
    void func(){}
}
namespace Nm2{
    void func(){}
}
int main()
{
    Nm1::func();
    Nm2::func();
}
```
このように名前空間さえ異なれば、関数名とそのシグネチャが同じでも、定義する事ができるのです。また名前空間を名前空間で囲う事も可能です。
```cpp
namespace Nm1{
    namespace Nm2{
        void func(){}
    }
}
int main()
{
    Nm1::Nm2::func();
}
```
この場合、`func`関数を使いたければ、上記のようにそのデータまでのパスを`::`で明示的に示す事でその機能を使う事ができます。また、上記のように名前空間を何重にも内包(ネスト)している名前空間は、以下のように省略して宣言する事もできます。
```cpp
namespace Nm1::Nm2{
    void func(){}
}
int main()
{
    Nm1::Nm2::func();
}
```
この記述法は、Nested Namespace definitionと呼ばれます。
これら名前空間の機能により、例えば自分以外の誰かが作ったライブラリなどを使う際に、自分の定義した識別子がたまたまそのライブラリ内にある識別子名と重なってしまい、自分がその識別子を使う事ができない...といった事を防ぐ事ができます(たまたま同じ名前空間を定義していた場合はダメ)。実はこの機能、今まで触れてきていませんでしたが何気なく使ってきていました。
値を標準出力させるためには、以下のようなコードを書いてきましたね。
```cpp
#include<iostream>
int main()
{
    std::cout<<"hoge"<<std::endl;
}
```
これはつまり、`std`という名前空間に`cout`と`endl`が予め定義されており、それを使っているがための記述だったのです。そしてこれらは、`iostream`ヘッダに定義されています。

### 6.3.2 using宣言
以下のコードで関数`func`を使うためには
```cpp
namespace Nm{
    void func(){}
}
```
以下のように明示的に指定する必要があると述べました。
```cpp
int main()
{
    Nm::func();
}
```
しかし、初めから`Nm`という名前空間内の機能を使うつもりで、識別子の衝突も有り得ないと分かっているようであれば、`Nm::`というように一々明示的に記述するのも面倒です。
そういった場合はusing宣言をすると便利です。
```cpp
namespace Nm{
    void func(){}
}
using namespace Nm;
int main()
{
    func();
}
```
`using namespace 名前空間名`とする事でその名前空間内の全ての宣言/定義を**associated namespace**に加えます。associated namespaceは、直訳すると関連する名前空間という意味です。つまり、明示的に`::`で名前空間を示さなくてもその名前空間内を探索するという事です。名前空間全体ではなく、その名前空間の一部のデータのみを使うというようであれば、以下のように記述します。
```cpp
namespace Nm{
    void func(){}
    void func1(){}
}
using Nm::func;
int main()
{
    func();
    Nm::func1();
}
```
`using Nm::func;`とする事によって、`Nm`名前空間の`func`という関数だけを非修飾的に(名前空間を明示的に示さない事)呼べるようにしています。この時`func1`は`using`宣言されていないため、明示的に名前空間を修飾した記述が必要になります。

### 6.3.3 スコープごとのusing宣言
using宣言にも、スコープという概念はそのまま適用されます。以下のコードを見て見ましょう。
```cpp
namespace Nm{
    void f(){}
}
void func()
{
    using namespace Nm;
    f();
}
int main()
{
    func();
    f();
}   
```
`Nm`名前空間の関数`f`を使うために、`func`関数内で`using namespace`宣言をしました。そして`f()`として関数を呼んでいます。しかし、その後`main`関数内で再度名前空間の明示的な修飾なしに関数`f`を呼んでいます。このコードは正しいでしょうか？残念ながら、このコードはコンパイルエラーとなります。何故かというと、簡単です。`using namespace`宣言がされたのは、関数`func`のスコープ内だけだからです。`main`関数のスコープ内では`using namespace`が適用されませんので、非修飾的に呼び出す事はできません。この場合、グローバル空間に`using namespace`宣言をしてあげる事で動きます。
```cpp
namespace Nm{
    void f(){}
}
using namespace Nm; // グローバル空間でusing namespace宣言
void func()
{
    f();
}
int main()
{
    func();
    f();
}
```
または明示的に修飾します。
```cpp
namespace Nm{
    void f(){}
}
void func()
{
    using namespace Nm;
    f();
}
int main()
{
    Nm::func(); // 明示的に修飾
    f();
}
```
これは、`using namespace`の他に、`using`宣言でも同様です。

### 6.3.4 using宣言による衝突
このコードは文法的に正しいでしょうか。
```cpp
namespace Nm{
    void f(){}
}
using namespace Nm; // or using Nm::f;
void f(){}
int main()
{
    f();
}
```
正解は正しくない、です。何故ならば`using namespace Nm;`とした事で、名前空間`Nm`をassociated namespaceに加えました。しかし、グローバルスコープにも同名、同シグネチャの関数`f`が既に定義されているのです。この場合、同じスコープに全く同じ定義が二つある事になってしまいますのでどちらの関数`f`を呼び出すべきなのか判別する事ができません。当然ですね。
このような事から、あまり不必要に`using`宣言を多用するべきではないと考えられます。あるプロジェクトの中にも、`using`宣言を禁止とするチームも存在しました。しかし、筆者としては全ての機能において言える事ですが、その機能による作用を完全に理解しているのであれば、それを利用する事自体、特に悪い事ではないと考えます。本書では、何の機能を使っているのか視覚的に理解しやすくするため、予め名前空間が設定されている機能を用いる場合は、明示的に完全修飾をした上でその機能を利用するスタイルのサンプルコードが書かれていますが、全ての事象において、名前空間の完全修飾をしなければならないというようには思いません。

### 6.3.5 inline namespace
`inline`キーワードには、関数に`inline`をキーワードを付与する事でインライン展開してほしい旨をコンパイラに伝えられる機能がありましたが、`inline`というキーワード自体は同じであるものの、これはそれとは全く別の機能です。inline namespaceはまず、以下のように使う事ができます。
```cpp
inline namespace Nm{
    void f(){}
}
int main()
{
    f();
}
```
非修飾的に関数`f`を呼び出せています。`inline namespace`は、その名前空間をassociated namespaceに含めるという意味を持ちます。そのため、非修飾的にその内部機能を呼び出す事ができるのです。しかし、これではグローバル定義されたものとなんら変わらないのでは？と思うかもしれません。実はまさにその通りで、このように`inline namespace`をグローバル領域に宣言した場合は機能として全くの意味を持ちません。`inline namespace`の機能が発揮されるのは、名前空間が二重以上にネストされた場合です。
```cpp
namespace Awesome_Lib{
    inline namespace feautures{
        void f(){}
    }
    void g(){}
}

int main()
{
    {
        using namespace Awesome_Lib; // Awesome_Lib名前空間の全ての機能を非修飾的に呼び出す
        f();
        g();
    }
    {
        using namespace Awesome_Lib::feautures; // Awesome_Lib::feautures名前空間のみを非修飾的に呼び出す
        f();
        Awesome_Lib::g(); // 修飾が必要
    }
}
```
`Awesome_Lib`という名前空間内に、`feautures`という名前空間がinline指定されています。このように機能ごとにどこまでを非修飾的に呼び出せるようにするのかをユーザーに指定させる事ができます。またその他に、バージョンマネージメントなどに利用する事ができます。
```cpp
namespace Awesome_Lib{
    inline namespace release{
        void f(){}
    }
    namespace experimental{
        void f(){}
    }
}
int main()
{
    Awesome_Lib::f(); // releaseバージョンを使用する。
    Awesome_Lib::experimental::f(); // 実験的バージョンを使用する。
}
```
`release`名前空間を`inline namespace`にする事で、単に`Awesome_Lib`名前空間だけを修飾すると、`release`をデフォルト設定として機能を使うように出来、明示的に`experimental`名前空間を指定した場合のみ、まだ実験的なバージョンを使えるようにするというような、バージョンごとのマネージメントをする事ができます。


### 6.3.6 名付けてはならない名前空間名
名前空間にも名付けてはならない名前が存在します。基本的には識別子につけてはならない名前と同等ですが、名前空間名を名付けるにおいてはそれに一つ条件が加わります。それは、`std`名前空間を独自に定義してはならないという要件です。`std`名前空間には、規格で厳密に定められた言語機能のみが定義されていなければなりません。`std`名前空間に、独自に機能を追加した場合は規格の保証外(未定義)となりますので絶対にしてはならないのです。しかし、ある条件の場合のみ、新たに`std`名前空間に機能を追加して良い事ともなっています。それについては、「第11章テンプレート」にて説明します。


### 6.3.7 無名名前空間
無名の名前空間を定義する事もできます。
```cpp
namespace{
    void f(){}
}
int main()
{
    ::f();
    f();
}
```
無名の名前空間にアクセスするためには`::`を記述する事で無名名前空間を明記する事ができます。この機能は「6.2.6 static指定子の別のセマンティック」で紹介した機能と同じです。無名名前空間内に定義されたオブジェクトなどへはそのファイル外からアクセスする事はできなくなります。
```cpp
// test.hpp
namespace{
    void f(){}
}
```
```cpp
#include"test.hpp"
int main()
{
    f(); // 不可
    ::f(); // 不可
}
```

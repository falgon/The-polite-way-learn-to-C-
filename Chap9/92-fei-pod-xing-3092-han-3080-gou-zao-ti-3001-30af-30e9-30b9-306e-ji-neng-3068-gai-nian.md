# 9.2 非POD型を含む構造体、クラスの機能と概念

9.1では、POD型という構造体、クラスの根本的、基本的な概念を学びましたがこれらはC言語でも扱うことのできる機能です。

ここからは、POD型の制限を破り、C++言語のさらなる高性能な言語機能を扱っていきます。これらの言語機能を使いこなせるようになれば、明快で多彩なコーディングを意識づける事ができるようになります。一つずつ順にマスターしていきましょう。

以降、構造体/クラスについては一貫してクラスと呼称しています。

## 9.2.1 アクセス指定子によるアクセス領域の制御
「9.1.2独自の型」では構造体/クラスの例として以下のように示しました。
```cpp
struct Vector{
	int x,y,z;
};
```
もしくは
```cpp
class Vector{
public:
	int x,y,z;
};
```
この時、`class`キーワードを用いる場合、`public`というキーワードを用いていました。これは、アクセス領域を指定しているのです。アクセス領域には以下の種類があります。

* pubilc
* protected
* private

これらは全て**アクセス指定子**と言われます。この中で、`protected`は、さらに後に取り上げる概念である継承を理解した後に活かされるアクセス指定子のためここでは一旦取り上げずに、`private`と`public`のみを説明します。

まず**`public`指定されたアクセス領域にある全てのメンバは、クラス外からも直接アクセスできます**。逆に**`private`指定されたアクセス領域にある全てのメンバはクラス内の関数からしかアクセスする事はできませ**んそして、**`struct`キーワードで定義されたクラスのデフォルトアクセスレベルは、`public`、`class`キーワードで定義されたクラスのデフォルトアクセスレベルは`private`です**。
```cpp
struct X{
 // public ...
};
```
```cpp
class X{
 // private ...
};
```
実際にコードを書く事でより理解が深まるでしょう。
```cpp
struct X{
    int a;
};

class Y{
    int a;
};

int main()
{
    X x={10};
    Y y={10};
}
```
このコードはコンパイルが通りません。GCC 7.0.1でのエラー文は以下のように出力されます(一部を特出しています)。
```cpp
12:4: error: no matching constructor for initialization of 'Y'
        Y y={10};
          ^ ~~~~
````
特に`X`についてのエラーが出力されていない通り、`X`については正しいコードです。`X`についてはクラス内部でアクセス指定を全くしていませんが、デフォルトでアクセスレベルは`public`であるため、外部からアクセス可能です。よって正しく処理されます。
エラー文は、Yをインスタンス化する段階で発生しています。`Y`についても、内部でアクセス指定子を用いていませんが、`class`キーワードを用いてクラスを定義した場合、デフォルトのアクセスレベルは`private`となります。エラー文を見てみるとエラーの内容は、「no matching constructor」と出力されています。どうやら、constructorなるものがマッチしないようです。
constructorとは一体なんでしょうか。

## 9.2.3 コンストラクター
constructor(コンストラクター)とは、**クラスがインスタンス化される段階で一番最初に呼ばれる関数**です。コンストラクターはクラスをインスタンス化する際に初期化を行う特殊な関数なのです。

まずコンストラクターの雰囲気を掴むためにもコンストラクターの簡単な特徴を示します。

* クラス名と同じ名前の関数
* 戻り型がvoidではないが戻り値がない

これらを踏まえて実際にコンストラクタを使った最も簡単な例を以下に示します。
```cpp
struct X{
	X(){} // コンストラクター
};
```
```cpp
class X{
public:
	X(){} // コンストラクター
};
```
`struct`、`class`両キーワードを用いた場合を記載しました。上記のように、コンストラクタは`public`アクセスレベルの中で宣言/定義されていなければ外部からそのクラス自体をインスタンス化する事ができないため上記のように設定しています。
コンストラクタは、前述したようにインスタンス化される段階で必ず呼び出される関数です。実際に確認してみましょう。
```cpp
#include<iostream>
struct X{
    X(){std::cout<<"X constructor"<<std::endl;}
};

class Y{
public:
    Y(){std::cout<<"Y constructor"<<std::endl;}
};

int main()
{
    X x;
    Y y;
}
```
実行結果は以下となります。
```cpp
X constructor
Y constructor
```
このように、`X`、`Y`からオブジェクトを生成しただけでコンストラクタの内容が実行されている事が分かります。
ここで、先ほどエラーになったコードをもう一度見て見ましょう。
```cpp
struct X{
     int a;
};

class Y{
     int a;
};
int main()
{
     X x={10};
     Y y={10};
}
```
前述した通り、コンストラクタは`public`アクセスレベル中で宣言/定義されなければ外部からそのクラスをインスタンス化する事ができません。`Y`がこの時インスタンス化できないのは、`class`キーワードによって全てのアクセスレベルが`private`になっているからです。では、`Y`にコンストラクタを追記しましょう。
```cpp
class Y{
	int a; // aのアクセスレベルはprivate
public:
	Y(){} // コンストラクタのアクセスレベルはpublic
};

int main()
{
	Y y={10];
}
```
しかし、残念ながらまだこのコードはコンパイルエラーとなります。エラー文を見て見ましょう。
```cpp
11:4: error: no matching constructor for initialization of 'Y'
        Y y={10};
          ^ ~~~~
```
おっと...エラー文は全く変わりません。`Y`のinitialization、つまり`Y`の初期化においてマッチするコンストラクターがないという内容です。何故でしょうか？コンストラクターのアクセスレベルを`public`にして外部からもオブジェクトを生成できるようにしたはずです。

結論から言えば、コンストラクターは、実は引数を受け付ける事ができるのです。そして、コンストラクタの引数は、オブジェクト生成時の初期化値として与える事ができるのです。具体的には、以下のようにコンストラクタを記述します。
```cpp
#include<iostream>

class Y{
    int a;
public:
    Y(int param)
    {
        a=param;
	std::cout<<a<<std::endl;
        std::cout<<"Y constructor"<<std::endl;
    }
};

int main()
{
    Y y={10};
}
```
実行結果は以下の通りです。
```cpp
10
Y constructor
```
`Y`のコンストラクターを見て見ましょう。引数に`int`型を受け取るようになっています。つまりコンパイラの求めていたmatchingするコンストラクタとは、このようなコンストラクタであった事が分かります。
コンストラクタの内部を見て見ましょう。内部では自身のメンバ変数`a`に、引数で受け付けた`param`を代入しています。その後"Y constructor"という文字列を出力しています。
ここで一つ引っ掛かる点があります。コンストラクタは、生成されたオブジェクトに対する初期化操作のはずです。しかし、メンバ変数`a`に対する値の適用は、上記の記述だと、代入という操作が行われているのです。初期化と代入は全く異なるものであるという事を思い出してください。コンストラクタは初期化を行う機構である以上、初期化操作でなければなりません。
しかし、安心してください。コンストラクタで、メンバ変数を初期化する構文は、言語仕様によって準備されています。
```cpp
#include<iostream>

class Y{
    int a;
public:
    Y(int param):a(param)
    {
        std::cout<<a<<std::endl;
        std::cout<<"Y constructor"<<std::endl;
    }
};

int main()
{
    Y y={10};
}
```
実行結果は以下の通りです。
```cpp
10
Y constructor
```
`Y`のコンストラクタを見てください。引数の後に`:a(param)`というように続いています。このようにコンストラクタの引数の後に、`初期化したいメンバ:(初期化する値)`というように記述する事で、そのメンバを代入での値の適用ではなく、初期化として値を適用する事ができるのです。
上記の代入と初期化では、確かに結果的には全く同じです。しかし、前述した通り、初期化と代入の違いを明確化し、適切に処理する事は多くのシーンで有益な働きを齎します。初期化可能なメンバ変数は、積極的に初期化の構文で値を適用するべきなのです。

ところで、上記のように引数付きのコンストラクタを定義した場合、引数なしでインスタンス化する事はできるのでしょうか。引数なしのコンストラクタは定義されていないため、引数なしのインスタンス化はできないように思えます。
```cpp
// クラスYについての定義。
// 上記と同様

int main()
{
    Y y; // 引数なしでYをインスタンス化
}
```
予想の通り、引数なしで`Y`をインスタンス化すると、コンパイルエラーが発生します。コンパイルエラーの文面は先ほどから良く見る、「no matching constructor for initialization」のはずです。
こういった場合、引数なしのコンストラクタも用意してあげる事で、可能です。
```cpp
#include<iostream>

class Y{
    int a;
public:
    Y():a(0)
    {
        std::cout<<a<<std::endl;
        std::cout<<"Y constructor(param 0)"<<std::endl;
    }
    Y(int param):a(param)
    {
        std::cout<<a<<std::endl;
        std::cout<<"Y constructor(param 1)"<<std::endl;
    }
};

int main()
{
    Y y1;
    Y y2={10};
}
```
実行結果は以下となります。
```cpp
0
Y constructor(param 0)
10
Y constructor(param 1)
```
`y1`のインスタンス化では引数なしのコンストラクタを、`y2`のインスタンス化では`int`型を一つ受け取るコンストラクタを呼び出しています。どのようにして呼び分けているのでしょうか...ここまででこれと似たような動作をするものを、既に習得したはずです。
そうです、これは、関数のオーバーロードによって達成されているのです。コンストラクタも関数ですから、上記のようにオーバーロードすることが可能です。
もちろん、デフォルト引数を設定しておく事も可能です。
```cpp
struct Y{
	Y(int a,int b=10):a(a),b(b){}
private:
	int a,b;
};

int main()
{
	Y y={20}; // デフォルト引数が設定されているため引数が1つでも良い。この場合bは10で初期化される。
}
```
細かい点ですが、引数なしの`Y`のコンストラクタで、メンバ変数`a`を`0`で初期化しています。`0`という値でなければならないという事ではないのですが、初期化されていない、不定値として放っておく事はあまり好ましい事ではありません。しかし、引数なしのコンストラクタの場合、初期化する値も特にないので、こういった場合は`0`という値でメンバ変数を初期化しておくのが、念のためにも安全なコードと言えます。

さてさて、コンストラクタは、もう少し奥が深いのでさらに突っ込んで話していきましょう。
先ほどまでのコードでは、インスタンス化において以下のように記述してきました。
```cpp
Y y={10};
```
初期化するにはこのように記述しなければならないのかと思ってしまった方、ご安心ください。以下のように、いくつか初期化の記述の方法が用意されています。
```cpp
Y y1=10;
Y y2{10};
Y y3(10);
Y y4={10}; 
```
これらは、クラス`Y`の定義が上記である場合、全て同じように動作します。
逆に、何故こんなにも色々な記述方法が用意されているのだ?!紛らわしいと思うかもしれません。確かにその通りこれはとても紛らわしいのですが、一つ一つ意味合いが明確なのです。

初めの`=`を用いた初期化。これは、プリミティブ型の初期化と同じように記述できるために用意された記述法です。ユーザーが独自に定義した型と、プリミティブ型が同じように初期化式を書く事ができるというのは、統一性から見ると大きなメリットです。
```cpp
int i=10; // プリミティブ型intの変数iを10で初期化
Y y=10; // ユーザーが独自に定義したクラスYを10で初期化
```
次に`{}`を用いた初期化方法。これは、**Uniform initialization**と呼ばれる記述方法で、翻訳すれば統一記法といったところでしょうか。統一的な記法、何に対しての統一なのかと思われるかもしれませんが、例えばPOD型に対する初期化と`private`なメンバを持つようなここまで説明してきた非POD型に対する初期化の記述方法などが挙げられます。Uniform initializationがなかった場合、POD型に対する初期化は以下のように記述する事となります。
```cpp
struct POD{ int x; };
POD pod={10};
```
そいて非POD型に対する初期化は以下のように記述する事となります。
```cpp
// 非POD型Yの定義を省略。上記と同様
Y y1=10;
Y y2(10);
```
これらは全て統一されていません。Uniform initializationは全ての初期化文を統一的に記述する事ができる事を売りにした初期化の記述法なのです。

次に`()`を用いた初期化方法。これは、複数個の引数を受け付けるコンストラクタを設定した場合や、明確な初期化の意思表示で不可欠となる記法です。`Y`のコンストラクタを二つの引数で受け付けるようにしてみましょう。
```cpp
class Y{
	int a,b;
pubilc:
	Y(int a_,int b_):a(a_),b(b_){}
};
```
初期化は、以下のように行います。
```cpp
Y y(10,20);
```
尚、Uniform initializationもこの場合有効です。
```cpp
Y y{10,20};
```
Uniform initializationは比較的新しい記法なので、このような`()`を用いなければならない状況においても、統一的に記述する事ができるのです。

最後に、`={}`を用いた記法。これは、C言語由来からなる構造体の初期化の記法です。C++言語はC言語との互換性を可能な限り維持する傾向にあるという認識もあり、そのような意思表示がこのような部分から垣間見る事ができます。

## 9.2.4 explicit、constexpr、inline コンストラクター
前述した様々な初期化の記法の中で`=`を用いた初期化の方法について取り上げます。
まず、`=`を用いたオブジェクトの初期化は、コンストラクタの引数が必ず1つでなければなりません。よくよく考えてみれば、当然の事です。`=`に対して直接引数を二つ以上与える記法は、あまりにも直感に反します。
ところで、この`=`、前々から思っていたかもしれませんが、初期化と代入は全く違う動作であるという事をこの文書では何度も述べていますが、意味合いが事なるのに全く同じように記述しなければならない事は、場合によっては紛らわしく、また独自的に作成したクラスを用いているのか、プリミティブ型を用いているのかを明確化したい場合には、`=`の記法で初期化させたくない場合があります。
そのような要望に答えるのが`explicit`コンストラクターです。
```cpp
class Y{
	int a,b;
public:
	explicit Y(int a_):a(a_){}
};
```
このように設定した場合、`Y`のインスタンス化時、初期化構文として`=`を用いる事が許されなくなります。
```cpp
Y y1(10); // OK
Y y2{10}; // OK
Y y3=10; // NG
Y y4={10}; // NG
```
`()`を用いた初期化式が許可されると同時に、Uniform initializationは依然として許可されます。これは、前述したようにUniform initializationが統一的な記法を援助するためのものだからです。
多くの場合、プリミティブ型の初期化には`=`が使われますが、実はプリミティブ型も`()`や`{}`で初期化を行う事が可能です。
```cpp
int i(10); // 10で初期化
int j{20}; // 20で初期化
```
プリミティブ型の初期化に`()`か`{}`を用いて引数を設けなかった場合、その変数は0で初期化されます。

またコンストラクターは`constexpr`指定する事ができます。よって、コンストラクタは積極的に`constexpr`にするべきです。(本文書ではそれぞれの項目ごとに置ける重要なポイントを明確にするため、`constexpr`なコンストラクタにしていないシーンがあります。)
```cpp
struct Y{
    constexpr Y(int a):a(a){}
private:
    int a;
};

int main()
{
    Y y=10;
}
```
勿論、`explicit`との併用が可能です。
```cpp
struct Y{
    explicit constexpr Y(int a):a(a){}
private:
    int a;
};

int main()
{
    Y y(10); // =を用いた初期化は行えない。
}
```

コンストラクタは`inline`指定も可能です。
```cpp
struct Y{
	inline Y(){}
};
```
挙動は、関数のインラインかと全く変わりません。

### 9.2.5 デフォルトコンストラクター
ここまで基本的なコンストラクターの概要を見てきましたが、ところでコンストラクターを定義していないクラスは何故インスタンス化できるのだろうか？と疑問には思いませんでしょうか。
具体的に示せば以下のようなコードです。
```cpp
struct X{}; // コンストラクタ等、何も記述していない

int main()
{
	X x; // インスタンス化できる
}
```
これは何故正しくインスタンス化できるのでしょうか。
結論から言えば、これは、**コンパイラによって暗黙的にコンストラクターが定義されているから**です。
その暗黙定義されたコンストラクターを、また暗黙定義されたかに関わらず実引数を与えずに呼び出すことが可能なコンストラクタを**デフォルトコンストラクター(default constructor/default ctor)**と言います。
デフォルトコンストラクタが暗黙的に定義されるのは、**コンストラクターを一つも定義していない場合**となっています。
上記の`X`は、暗黙的にデフォルトコンストラクターが定義されたという事になります。つまり、下記
の内容と同じ動作を行うという事です。
```cpp
struct X{
	X(){}
};
```
しかし、例えば引数を受け付けるコンストラクタを用意した場合に、それとは別に引数がなければ、暗黙的に定義されるコンストラクタと同じように動くようにしたいといった場合、コンストラクタを上記のように一々記述しなければならないのは、なんとも面倒ですし、明示性に欠けるものがあります。
そのような場合には、`default`を用いる事でデフォルトコンストラクターを明示的に定義する事が可能です。
```cpp
struct X{
	X()=default; // デフォルトコンストラクタ
	X(int x):x_(x){} // 引数付きのコンストラクタ
private:
	int x_;
};
```
この`default`によるデフォルトコンストラクタの機能はとても便利で、例えばデフォルト挙動をして欲しいがそのコンストラクタは`constexpr`にしたいといった場合、以下のように記述できます。
```cpp
struct X{
	constexpr X()=default; // constexpr版デフォルトコンストラクタ
};
```
`explicit`、`inline`なども同じように指定できます。

## 9.2.6 コピーコンストラクタ


# 9.2 非POD型を含む構造体、クラスの機能と概念

9.1では、POD型という構造体、クラスの根本的、基本的な概念を学びましたがこれらはC言語でも扱うことのできる機能です。

ここからは、POD型の制限を破り、C++言語のさらなる高性能な言語機能を扱っていきます。これらの言語機能を使いこなせるようになれば、明快で多彩なコーディングを意識づける事ができるようになります。一つずつ順にマスターしていきましょう。

以降、構造体/クラスについては一貫してクラスと呼称しています。

## 9.2.1 アクセス指定子によるアクセス領域の制御
「9.1.2独自の型」では構造体/クラスの例として以下のように示しました。
```cpp
struct Vector{
	int x,y,z;
};
```
もしくは
```cpp
class Vector{
public:
	int x,y,z;
};
```
この時、`class`キーワードを用いる場合、`public`というキーワードを用いていました。これは、アクセス領域を指定しているのです。アクセス領域には以下の種類があります。

* pubilc
* protected
* private

これらは全て**アクセス指定子**と言われます。この中で、`protected`は、さらに後に取り上げる概念である継承を理解した後に活かされるアクセス指定子のためここでは一旦取り上げずに、`private`と`public`のみを説明します。

まず**`public`指定されたアクセス領域にある全てのメンバは、クラス外からも直接アクセスできます**。逆に**`private`指定されたアクセス領域にある全てのメンバはクラス内の関数からしかアクセスする事はできませ**んそして、**`struct`キーワードで定義されたクラスのデフォルトアクセスレベルは、`public`、`class`キーワードで定義されたクラスのデフォルトアクセスレベルは`private`です**。
```cpp
struct X{
 // public ...
};
```
```cpp
class X{
 // private ...
};
```
実際にコードを書く事でより理解が深まるでしょう。
```cpp
struct X{
    int a;
};

class Y{
    int a;
};

int main()
{
    X x={10};
    Y y={10};
}
```
このコードはコンパイルが通りません。GCC 7.0.1でのエラー文は以下のように出力されます(一部を特出しています)。
```cpp
12:4: error: no matching constructor for initialization of 'Y'
        Y y={10};
          ^ ~~~~
````
特に`X`についてのエラーが出力されていない通り、`X`については正しいコードです。`X`についてはクラス内部でアクセス指定を全くしていませんが、デフォルトでアクセスレベルは`public`であるため、外部からアクセス可能です。よって正しく処理されます。
エラー文は、Yをインスタンス化する段階で発生しています。`Y`についても、内部でアクセス指定子を用いていませんが、`class`キーワードを用いてクラスを定義した場合、デフォルトのアクセスレベルは`private`となります。エラー文を見てみるとエラーの内容は、「no matching constructor」と出力されています。どうやら、constructorなるものがマッチしないようです。
constructorとは一体なんでしょうか。

## 9.2.3 コンストラクター
constructor(コンストラクター)とは、**クラスがインスタンス化される段階で一番最初に呼ばれる関数**です。コンストラクターはクラスをインスタンス化する際に初期化を行う特殊な関数なのです。

まずコンストラクターの雰囲気を掴むためにもコンストラクターの簡単な特徴を示します。

* クラス名と同じ名前の関数
* 戻り型がvoidではないが戻り値がない

これらを踏まえて実際にコンストラクタを使った最も簡単な例を以下に示します。
```cpp
struct X{
	X(){} // コンストラクター
};
```
```cpp
class X{
public:
	X(){} // コンストラクター
};
```
`struct`、`class`両キーワードを用いた場合を記載しました。上記のように、コンストラクタは`public`アクセスレベルの中で宣言/定義されていなければ外部からそのクラス自体をインスタンス化する事ができないため上記のように設定しています。
コンストラクタは、前述したようにインスタンス化される段階で必ず呼び出される関数です。実際に確認してみましょう。
```cpp
#include<iostream>
struct X{
    X(){std::cout<<"X constructor"<<std::endl;}
};

class Y{
public:
    Y(){std::cout<<"Y constructor"<<std::endl;}
};

int main()
{
    X x;
    Y y;
}
```
実行結果は以下となります。
```cpp
X constructor
Y constructor
```
このように、`X`、`Y`からオブジェクトを生成しただけでコンストラクタの内容が実行されている事が分かります。
ここで、先ほどエラーになったコードをもう一度見て見ましょう。
```cpp
struct X{
     int a;
};

class Y{
     int a;
};
int main()
{
     X x={10};
     Y y={10};
}
```
前述した通り、コンストラクタは`public`アクセスレベル中で宣言/定義されなければ外部からそのクラスをインスタンス化する事ができません。`Y`がこの時インスタンス化できないのは、`class`キーワードによって全てのアクセスレベルが`private`になっているからです。では、`Y`にコンストラクタを追記しましょう。
```cpp
class Y{
	int a; // aのアクセスレベルはprivate
public:
	Y(){} // コンストラクタのアクセスレベルはpublic
};

int main()
{
	Y y={10];
}
```
しかし、残念ながらまだこのコードはコンパイルエラーとなります。エラー文を見て見ましょう。
```cpp
11:4: error: no matching constructor for initialization of 'Y'
        Y y={10};
          ^ ~~~~
```
おっと...エラー文は全く変わりません。`Y`のinitialization、つまり`Y`の初期化においてマッチするコンストラクターがないという内容です。何故でしょうか？コンストラクターのアクセスレベルを`public`にして外部からもオブジェクトを生成できるようにしたはずです。

結論から言えば、コンストラクターは、実は引数を受け付ける事ができるのです。そして、コンストラクタの引数は、オブジェクト生成時の初期化値として与える事ができるのです。具体的には、以下のようにコンストラクタを記述します。
```cpp
#include<iostream>

class Y{
    int a;
public:
    Y(int param)
    {
        a=param;
	std::cout<<a<<std::endl;
        std::cout<<"Y constructor"<<std::endl;
    }
};

int main()
{
    Y y={10};
}
```
実行結果は以下の通りです。
```cpp
10
Y constructor
```
`Y`のコンストラクターを見て見ましょう。引数に`int`型を受け取るようになっています。つまりコンパイラの求めていたmatchingするコンストラクタとは、このようなコンストラクタであった事が分かります。
コンストラクタの内部を見て見ましょう。内部では自身のメンバ変数`a`に、引数で受け付けた`param`を代入しています。その後"Y constructor"という文字列を出力しています。
ここで一つ引っ掛かる点があります。コンストラクタは、生成されたオブジェクトに対する初期化操作のはずです。しかし、メンバ変数`a`に対する値の適用は、上記の記述だと、代入という操作が行われているのです。初期化と代入は全く異なるものであるという事を思い出してください。コンストラクタは初期化を行う機構である以上、初期化操作でなければなりません。
しかし、安心してください。コンストラクタで、メンバ変数を初期化する構文は、言語仕様によって準備されています。
```cpp
#include<iostream>

class Y{
    int a;
public:
    Y(int param):a(param)
    {
        std::cout<<a<<std::endl;
        std::cout<<"Y constructor"<<std::endl;
    }
};

int main()
{
    Y y={10};
}
```
実行結果は以下の通りです。
```cpp
10
Y constructor
```
`Y`のコンストラクタを見てください。引数の後に`:a(param)`というように続いています。このようにコンストラクタの引数の後に、`初期化したいメンバ:(初期化する値)`というように記述する事で、そのメンバを代入での値の適用ではなく、初期化として値を適用する事ができるのです。
上記の代入と初期化では、確かに結果的には全く同じです。しかし、前述した通り、初期化と代入の違いを明確化し、適切に処理する事は多くのシーンで有益な働きを齎します。初期化可能なメンバ変数は、積極的に初期化の構文で値を適用するべきなのです。

ところで、上記のように引数付きのコンストラクタを定義した場合、引数なしでインスタンス化する事はできるのでしょうか。引数なしのコンストラクタは定義されていないため、引数なしのインスタンス化はできないように思えます。
```cpp
// クラスYについての定義。
// 上記と同様

int main()
{
    Y y; // 引数なしでYをインスタンス化
}
```
予想の通り、引数なしで`Y`をインスタンス化すると、コンパイルエラーが発生します。コンパイルエラーの文面は先ほどから良く見る、「no matching constructor for initialization」のはずです。
こういった場合、引数なしのコンストラクタも用意してあげる事で、可能です。
```cpp
#include<iostream>

class Y{
    int a;
public:
    Y():a(0)
    {
        std::cout<<a<<std::endl;
        std::cout<<"Y constructor(param 0)"<<std::endl;
    }
    Y(int param):a(param)
    {
        std::cout<<a<<std::endl;
        std::cout<<"Y constructor(param 1)"<<std::endl;
    }
};

int main()
{
    Y y1;
    Y y2={10};
}
```
実行結果は以下となります。
```cpp
0
Y constructor(param 0)
10
Y constructor(param 1)
```
`y1`のインスタンス化では引数なしのコンストラクタを、`y2`のインスタンス化では`int`型を一つ受け取るコンストラクタを呼び出しています。どのようにして呼び分けているのでしょうか...ここまででこれと似たような動作をするものを、既に習得したはずです。
そうです、これは、関数のオーバーロードによって達成されているのです。コンストラクタも関数ですから、上記のようにオーバーロードすることが可能です。
細かい点ですが、引数なしの`Y`のコンストラクタで、メンバ変数`a`を`0`で初期化しています。`0`という値でなければならないという事ではないのですが、初期化されていない、不定値として放っておく事はあまり好ましい事ではありません。しかし、引数なしのコンストラクタの場合、初期化する値も特にないので、こういった場合は`0`という値でメンバ変数を初期化しておくのが、念のためにも安全なコードと言えます。

さてさて、コンストラクタは、もう少し奥が深いのでさらに突っ込んで話していきましょう。
先ほどまでのコードでは、インスタンス化において以下のように記述してきました。
```cpp
Y y={10};
```
初期化するにはこのように記述しなければならないのかと思ってしまった方、ご安心ください。以下のように、いくつか初期化の記述の方法が用意されています。
```cpp
Y y1=10;
Y y2{10};
Y y3(10);
Y y4={10}; 
```
これらは、クラス`Y`の定義が上記である場合、全て同じように動作します。
逆に、何故こんなにも色々な記述方法が用意されているのだ?!紛らわしいと思うかもしれません。確かにその通りこれはとても紛らわしいのですが、一つ一つ意味合いが明確なのです。

初めの`=`を用いた初期化。これは、プリミティブ型の初期化と同じように記述できるために用意された記述法です。ユーザーが独自に定義した型と、プリミティブ型が同じように初期化式を書く事ができるというのは、統一性から見ると大きなメリットです。
```cpp
int i=10; // プリミティブ型intの変数iを10で初期化
Y y=10; // ユーザーが独自に定義したクラスYを10で初期化
```
次に`{}`を用いた初期化方法。これは、**Uniform initialization**と呼ばれる記述方法で、翻訳すれば統一記法といったところでしょうか。統一的な記法、何に対しての統一なのかと思われるかもしれませんが、例えばPOD型に対する初期化と`private`なメンバを持つようなここまで説明してきた非POD型に対する初期化の記述方法などが挙げられます。**Uniform initialization**がなかった場合、POD型に対する初期化は以下のように記述する事となります。
```cpp
struct POD{ int x; };
POD pod={10};
```
そいて非POD型に対する初期化は以下のように記述する事となります。
```cpp
// 非POD型Yの定義を省略。上記と同様
Y y1=10;
Y y2(10);
```
これらは全て統一されていません。**Uniform initialization**は全ての初期化文を統一的に記述する事ができる事を売りにした初期化の記述法なのです。

次に`()`を用いた初期化方法。

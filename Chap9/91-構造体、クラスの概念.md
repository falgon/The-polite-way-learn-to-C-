# 9.1 構造体、クラスの概念

さて、今までは「2.1 変数とデータ型」で説明したような”型”を使ってデータの操作をしてきました。構造体やクラスは、誤解を恐れずに述べると、その”型”を作る事ができる機能と言えます。まず第一に、その基本的な概念となるPOD型から触れていきます。

## 9.1.1 POD型

PODとは、Plain Old Dataの略で一種の型の分類を言います。例えば、「2.1.6型 データ型の一覧」で述べたプリミティブ型は、全てPOD型です。

これらは大まかに言えば、C言語でも扱う事のできる型です。C++はC言語から拡張された言語であるため、このようにC言語との互換性のある型をPOD型と分類することで、様々な環境に応じた拡張や分類を成す事ができるのです。

さて、C言語でも扱うことのできる型とは、具体的にはどのような型を言うのでしょうか。それは大きく分けて以下の二点が満たされている型や構造体、クラスのことを言います。

* **standart layout type**\(標準標準レイアウト型\)である
* **trivial type**\(トリビアル型\)である

それぞれがどのような意味なのか、順に示しますが、現段階では理解する必要はありません。

### standart layout type

standart layout typeは、以下の条件が満たされた型、構造体、クラスを示します。

* virtual関数を持たない
* virtual関数を持った型の継承をしていない
* 参照メンバを持たない
* 非staticメンバに対して複数のアクセス指定子を持たない
* standart layout typeでない型を継承していない
* standart layoutでない非staticメンバを持たない
* 継承しても良いが非staticメンバを持つクラスは継承構造の中で1つに限られている

### trivial type

trivial typeは、以下の要件が満たされた型、構造体、クラスを示します。

* コンパイラが暗黙に定義するコンストラクタ、コピーコンストラクタ、ムーブコンストラクタと同等の動作をするそれらを持つ

なにやらよく分からない内容が大量にでてきましたが、これらは全て意図的に記述しない限り発生しない内容で、自分で新たに型を定義する時に自ら意図して記述しなければ、殆どがPOD型となるでしょう。

上記に挙げられた内容は、全てこれから順を追って説明するため分からなくても気にする必要は全くありませんが、後に振り返ることとなりますので頭の隅に置いておくと良いかもしれません。

## 9.1.2 独自の型

さて、ではさっそく、独自の型を作って見ましょうか。POD型は一番基本的な型となりますので、まずそのような型を作ります。

といっても、とても簡単です。例えば、`int`型を3つもった型、`Vector`型を作成してみましょう。

```cpp
struct Vector{
    int x,y,z;
};
```

もしくは

```cpp
class Vector{
public:
    int x,y,z;
}
```

両者は全く同じ動作となりますが、`class`の方では`public:`というようなキーワードが付与されていますね。これは、アクセス指定子と言われるもので、本項の後に取り上げる内容ですから、今は気にしなくて大丈夫です。しかし、`class`キーワードを使って上記の`struct`キーワードを使った構造体と同じ動作を期待したい場合、必ず`public:`という記述が必要になります。

また、上記のコードのような`x`、`y`、`z`を**メンバ変数**と言います。

さて、これで取り敢えず`Vector`という型が定義できました。型ができたのですから、今までのように、この型から成る変数を定義することができます。

```cpp
Vector v;
```

これで、Vector型の`v`という**オブジェクト**を**インスタンス化**できました。

### オブジェクト

何度かこれまで**オブジェクト**という用語を用いていましたが、まだ明確に述べていませんでした。**オブジェクト**とは、直訳すると「物」といったところですが、意味合いとしてはある型から生成されたデータの事を基本的に示します。変数も、オブジェクトの一つです。変数でない、無名の、見えないオブジェクトもあります。「7.7 ムーブセマンティックス」で述べた、**rvalue**などがそうです。

### インスタンス化

**インスタンス化**とは、ある型を実際のデータとして構築する事を主に言います。ある型を**インスタンス化**した時、その型の**オブジェクト**がデータとして存在します。

### 独自に定義した型への操作

というわけで`Vector`型をインスタンス化して、`v`というオブジェクトを生成しました。しかし、これだけでは何も嬉しくはありません。実際にインスタンス化した`v`というオブジェクト内部のデータを扱えなければなんの意味もありません。

ではまず、`Vector`型を任意の値で初期化してみましょう。初期化は、以下のように行います。

```cpp
#include<iostream>

struct Vector{
    int x,y,z;
};

int main()
{
    // どちらでも良い。
    Vector v1={1,2,3};
    Vector v2{1,2,3};
}
```

こうする事で、`Vector`型の持つデータ、`x`、`y`、`z`が、順に1、2、3で初期化されます。コード中のコメントにあるように、この場合は、`={}`としても、`{}`としても動作は変わりません。

動作自体は変わりませんので、今の所特に気にする必要はありませんが、厳密に言えば内部的な解釈は異なります。`std::initializer_list`を用いていない構造体/クラスの初期化における`={}`という記法は、C言語から受け継いだ記法で、構造体の一般的な初期化法となります。`std::initializer_list`については、本項の後に取り上げています。  
次に`{}`という記法は**uniform initialization\(universel initialization\)**と呼ばれる初期化の方法です。これについての厳密な動作や概念も、後に取り上げる内容となりますので今の所知っている必要はありませんが、少し紹介すると、全ての初期化を統一的な記述方法で記述できるようにした記法です。つまり、コンパイラの処理としてはuniform initializationを用いた場合、「uniform initializationを認識 -&gt; 初期化内容の推論 -&gt; 推論した結果C言語由来の初期化方法で初期化」といったような流れで処理されることになります\(厳密な処理はコンパイラによって異なる\)。取り敢えず現段階では、動作自体は変わらないものなのだな、と頭の片隅に置いておきましょう。

...さて、初期化できたところで、初期化されたデータにアクセスできなければ、なんの意味もありません。`x`、`y`、`z`に対して何かアクションを起こしたいものです。そのためには、以下のように記述します。

```cpp
#include<iostream>

struct Vector{
    int x,y,z;
};

int main()
{
    Vector v{1,2,3};

    std::cout<< v.x << " " << v.y << " " << v.z << std::endl; // アクセス
}
```

実行結果は以下となります。

```cpp
1 2 3
```

インスタンス化されたオブジェクトに対して`.`演算子を使い、その内部の変数を指定する事で、そのデータにアクセスする事ができます。`v.x`、`v.y`、`v.z`は、それぞれ`Vector`型の`x`、`y`、`z`にアクセスしています。

独自に定義した`Vector`\(POD\)型は、コピーや代入も今までのプリミティブ型のように行うことができます。

```cpp
struct Vector{
    int x,y,z;
};

int main()
{
    Vector v1{1,2,3};
    Vector v2=v1; // コピーして初期化
    v2=v1; // 代入
}
```

また「8.1 enum」で述べた`enum`と同じように、構造体/クラスの定義と同時にそのオブジェクトを定義することも可能です。

```cpp
struct Vector{
    int x,y,z;
}v1,v2{1,2,3},v3={1,2,3}; // v1は未初期化、v2はuniform initializationによって初期化、v3は従来の方法で初期化
```

そして、これまた「8.1 enum」で述べた`enum`と同じように、構造体/クラスを関数スコープ内で定義することもできます。

```cpp
void f()
{
    struct X{};
}
```

構造体/クラスも同様、スコープの概念を持ちます。

また、`enum`と同じように、構造体/クラスのオブジェクトを定義する際、`struct`/`class`キーワードを用いることが可能です。

```cpp
struct X{};

int main()
{
    struct X x;
    class X y; 
}
```

両者は全く同じ意味を持ちます。しかし、C++ではわざわざキーワードを付与する事はあまりありません。

...とここまでが、構造体、クラスの基本的な部分となりますが、そもそも型を作れて一体何が嬉しいのかと思うかもしれません。後に説明する機能を理解できれば、独自の型を定義できる事がどれだけ有意義な事かの理解がさらに容易くなりますが、ここまでだけでも十分実用性や意義を見出す事ができます。例えば、関数から値を返却する際、返せる値は1つのみでした。

```cpp
int f()
{
    return 42;
}

int main()
{
    std::cout << f() << std::endl; // 42
}
```

独自定義した型`Vector`を使えば、三つの`int`型のデータを返す事が可能となりますね。

```cpp
class Vector{
public:
    int x,y,z;
};

Vector f()
{
    return Vector{10,20,30};
}

int main()
{
    Vector vec = f();
    std::cout << vec.x << " " << vec.y << " " << vec.z << std::endl; // 10 20 30
}
```

`return Vector{10,20,30};`としているところは、以下のようにしても同じように動きます。

```cpp
Vector f()
{
    return {10,20,30};
}
```

関数`f`の戻り型に`Vector`を指定しているため、`{}`という記述だけでも型を推論することができます。この仕組みは、前述したuniform initializationに関係しているため、厳密な仕組みを現段階で気にする必要はありません。

### 独自に定義した型のポインターと参照

ポインターと参照も、プリミティブ型と同じく今まで通り使う事ができます。まずは、`Vector`型のポインターを操作して見ましょう。

```cpp
struct Vector{
    int x,y,z;
};

int main()
{
    Vector v{10,20,30};
    Vector* vecptr=&v;
    std::cout<< vecptr->x << " " << vecptr->y << " " << vecptr->z << std::endl;
}
```

実行結果は以下となります。

```cpp
10 20 30
```

`->`という見たことのない演算子が現れました。これは、**関節メンバ参照演算子/アロー演算子**といい、ポインターからポインターの型が持つメンバへアクセスする際に、上記のように使います。この演算子以外は、特に目新しい部分はありませんね。`Vector`型のポインターは`Vector*`のように宣言しますしオブジェクトのアドレスも、単に`&`演算子を用いるだけです。そのほかは全て通常のプリミティブ型のポインターと同じように扱うことができます。

また、上記のコードは、実は`->`演算子を用いなくともメンバ変数にアクセスすることができます。

```cpp
#include<iostream>

struct Vector{
    int x,y,z;
};

int main()
{
    Vector a{1,2,3};
    Vector* vecptr=&a;
    std::cout << (*vecptr).x << " " << (*vecptr).y << " " << (*vecptr).z << std::endl;
}
```

実行結果は先ほどと同じです。

オブジェクトを示すポインターに対して`*`演算子を使って関節参照した後、`.`演算子によってメンバ変数へアクセスします。やっている事は`->`演算子と変わりませんから、どのように記述しても構いません。

さて、ポインターを普通に操作できるという事は、動的にオブジェクトを生成して、それを指し示す事もできます。

```cpp
#include<iostream>

struct Vector{
    int x,y,z;
};

int main()
{
    Vector* vecptr=new Vector{1,2,3};
    std::cout << vecptr->x << " " << vecptr->y << " " << vecptr->z << std::endl;
    delete vecptr;
}
```

実行結果は先ほどと同じです。

また、動的なオブジェクトを指し示せるのですから、動的配列にもできます。

```cpp
#include<iostream>

struct Vector{
    int x,y,z;
};

int main()
{
    Vector* vecptr=new Vector[3]{{1,2,3},{4,5,6},{7,8,9}};
    for(unsigned int i=0; i<3; ++i)
        std::cout<< vecptr[i].x << " " << vecptr[i].y << " " << vecptr[i].z << std::endl;
    delete[] vecptr;
}
```

実行結果は以下となります。

```cpp
1 2 3
4 5 6
7 8 9
```

プリミティブ型へのポインターと、特別差異はありません。落ち着いて考えれば、難しい事はありません。



さて、次は参照です。参照も、プリミティブ型と特に変わりはありません。

```cpp
#include<iostream>

struct Vector{
    int x,y,z;
};

int main()
{
    Vector v{10,20,30};
    
    
    Vector& vref1=v; 
    // 変更操作ができる。non-const lvalue reference。
    // vref1.x=42;などと操作した場合、v.xは42となる。rvalueを参照する事はできない。
    
    const Vector& vref2=v;
    // 変更操作ができない。const lvalue reference。
    // vref2.x=42;といったような変更操作は受け付けない。rvalueを参照することもできる。
    
    Vector&& vref4=Vector();
    // 変更操作ができる。non-const rvalue reference。
    // lvalueを参照する事はできない。
    
    const Vector&& vref5=Vector();
    // 変更操作ができない。const rvalue reference。
    // lvalueを参照する事はできない。
}
```

## 9.1.2 POD型の外へ

ここまでは、POD型と言われる型を作ってきました。しかし、これだけではC++言語の強力な言語機能を全く使えていません。C++の構造体/クラスの強力な機能は、POD型の殻を破ったその先にあるのです。

ここまでで定義した独自のPOD型`Vector`ですが、例えば`Vector`のオブジェクト同士で加算がしたいとは思いませんか？やってみましょう。

```cpp
struct Vector{
    int x,y,z;
};

int main()
{
    Vector a{1,2,3},b{4,5,6};
    Vector result = a + b;
}
```

残念ながら、このコードはコンパイルエラーとなります。なぜでしょうか？実際にコンパイルしてエラー文を見てみてください。GCC 7.0.1では、以下のようなコンパイルエラー文が出力されました。

```
error: no match for 'operator+' (operand types are 'Vector' and 'Vector')
     Vector result = a + b;
                     ~~^~~
```

つまり、型`Vector`と型`Vector`が加算される方法、そして`+`という演算子をどのように使うかの定義がされていないため、「no match」となってしまうのです。`x + y`の部分を見て、何となく無意識のうちに両者の`x`、`y`、`z`同士が加算されるかのように想像したかもしれませんが、そのように融通を効かせてはくれません。

実は、今まで学んできたことだけだと、このようなコードで`Vector`型のオブジェクト、`x`と`y`に対して`+`を使う事はできませんが、`X`型の参照を受け付けて両者の`x`、`y`、`z`を加算した結果を持つ`X`型のオブジェクトを返す関数を定義すれば、`X`型の加算を表す事はできます。具体的には、以下のようなコードです。

```cpp
#include<iostream>

struct X{
    int x,y,z;
};

X plus(const X& lhs,const X& rhs)
{
    return {lhs.x+rhs.x,lhs.y+rhs.y,lhs.z+rhs.z};
}

int main()
{
    X a{1,2,3},b{4,5,6};
    X result = plus(a,b);
    std::cout << result.x << " " << result.y << " " << result.z << std::endl; // 5 7 9
}
```

しかし、一々加算をするのに、`plus`と書き続けるのは冗長です。例えば、加算の引数がもし増えたら、以下のように記述しなければなりません。

```cpp
X a{1,2,3},b{4,5,6},c{7,8,9},d{10,11,12},e{13,14,15};
X result = plus(plus(plus(plus(a,b),c),d),e); // やりたい事は a + b + c + d + e
std::cout << result.x << " " << result.y << " " << result.z << std::endl; // 35 40 45
```

これは、あまりにも非人道的です。単純に`+`と記述しただけで上記のような動作が行われて欲しいと思いませんか？

安心してください。C++には、これを自分で定義する方法が備わっています。そしてもちろん、そのような機能の他にも様々な強力で実用的な機能が備わっています。このような、独自的な定義を次々と行えるのが、C++のパワフルな機能の一つでもあります。次項からは、そのパワフルな機能らを順に説明していきます。


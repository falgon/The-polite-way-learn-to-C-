# 9.1 構造体、クラスの概念

さて、今までは「2.1 変数とデータ型」で説明したような”型”を使ってデータの操作をしてきました。構造体やクラスは、誤解を恐れずに述べると、その”型”を作る事ができる機能と言えます。まず第一に、その基本的な概念となるPOD型から触れていきます。

## 9.1.1 POD型

PODとは、Plain Old Dataの略で一種の型の分類を言います。例えば、「2.1.6型 データ型の一覧」で述べたプリミティブ型は、全てPOD型です。

これらは大まかに言えば、C言語でも扱う事のできる型です。C++はC言語から拡張された言語であるため、このようにC言語との互換性のある型をPOD型と分類することで、様々な環境に応じた拡張や分類を成す事ができるのです。

さて、C言語でも扱うことのできる型とは、具体的にはどのような型を言うのでしょうか。それは大きく分けて以下の二点が満たされている型や構造体、クラスのことを言います。

* **standart layout type**\(標準標準レイアウト型\)である
* **trivial type**\(トリビアル型\)である

それぞれがどのような意味なのか、順に示しますが、現段階では理解する必要はありません。

### standart layout type

standart layout typeは、以下の条件が満たされた型、構造体、クラスを示します。

* virtual関数を持たない
* virtual関数を持った型の継承をしていない
* 参照メンバを持たない
* 非staticメンバに対して複数のアクセス指定子を持たない
* standart layout typeでない型を継承していない
* standart layoutでない非staticメンバを持たない
* 継承しても良いが非staticメンバを持つクラスは継承構造の中で1つに限られている

### trivial type

trivial typeは、以下の要件が満たされた型、構造体、クラスを示します。

* コンパイラが暗黙に定義するコンストラクタ、コピーコンストラクタ、ムーブコンストラクタと同等の動作をするそれらを持つ

なにやらよく分からない内容が大量にでてきましたが、これらは全て意図的に記述しない限り発生しない内容で、自分で新たに型を定義する時に自ら意図して記述しなければ、殆どがPOD型となるでしょう。

上記に挙げられた内容は、全てこれから順を追って説明するため分からなくても気にする必要は全くありませんが、後に振り返ることとなりますので頭の隅に置いておくと良いかもしれません。

## 9.1.2 独自の型 - POD型

さて、ではさっそく、独自の型を作って見ましょうか。POD型は一番基本的な型となりますので、まずそのような型を作ります。

といっても、とても簡単です。例えば、`int`型を3つもった型、`Vector`型を作成してみましょう。

```cpp
struct Vector{
    int x,y,z;
};
```
もしくは
```cpp
class Vector{
public:
    int x,y,z;
}
```
両者は全く同じ動作となりますが、`class`の方では`public:`というようなキーワードが付与されていますね。これは、アクセス指定子と言われるもので、本項の後に取り上げる内容ですから、今は気にしなくて大丈夫です。しかし、`class`キーワードを使って上記の`struct`キーワードを使った構造体と同じ動作を期待したい場合、必ず`public:`という記述が必要になります。

さて、これで取り敢えず`Vector`という型が定義できました。型ができたのですから、今までのように、この型から成る変数を定義することができます。

```cpp
Vector v;
```

これで、Vector型の`v`という**オブジェクト**を**インスタンス化**できました。

### オブジェクト

なんどかこれまで**オブジェクト**という用語を用いていましたが、まだ明確に述べていませんでした。**オブジェクト**とは、直訳すると「物」といったところですが、意味合いとしてはある型から生成されたデータの事を基本的に示します。変数も、オブジェクトの一つです。変数でない、無名の見えないオブジェクトもあります。それは、「7.7 ムーブセマンティックス」で述べた、**rvalue**などがそうです。

### インスタンス化

次に**インスタンス化**とは、ある型を実際のデータとして構築する事を主に言います。ある型を**インスタンス化**した時、その型の**オブジェクト**がデータとして存在します。

### 独自に定義した型への操作

さて、少し話がそれてしまいましたが、`Vector`型をインスタンス化して、`v`というオブジェクトを生成しました。しかし、これだけでは何も嬉しくはありません。実際にインスタンス化した`v`というオブジェクト内部のデータを扱えなければなんの意味もありません。

ではまず、`Vector`型を任意の値で初期化してみましょう。初期化は、以下のように行います。

```cpp
#include<iostream>

struct Vector{
    int x,y,z;
};

int main()
{
    // どちらでも良い。
    Vector v1={1,2,3};
    Vector v2{1,2,3};
}
```

こうする事で、`Vector`型の持つデータ、`x`、`y`、`z`が、順に1、2、3で初期化されます。コード中のコメントにあるように、この場合は、`={}`としても、`{}`としても動作は変わりません。

動作自体は変わりませんので、今の所特に気にする必要はありませんが、厳密に言えば内部的な解釈は異なります。`std::initializer_list`を用いていない構造体/クラスの初期化における`={}`という記法は、C言語から受け継いだ記法で、構造体の一般的な初期化法となります。`std::initializer_list`については、本項の後に取り上げています。
次に`{}`という記法は**uniform initialization(universel initialization)**と呼ばれる初期化の方法です。これについての厳密な動作や概念も、後に取り上げる内容となりますので今の所知っている必要はありませんが、少し紹介すると、全ての初期化を統一的な記述方法で記述できるようにした記法です。つまり、コンパイラの処理としてはuniform initializationを用いた場合、「uniform initializationを認識 -> 初期化内容の推論 -> 推論した結果C言語由来の初期化方法で初期化」といったような流れで処理されることになります(厳密な処理はコンパイラによって異なる)。取り敢えず現段階では、動作自体は変わらないものなのだな、と頭の片隅に置いておきましょう。

...さて、初期化できたところで、初期化されたデータにアクセスできなければ、なんの意味もありません。`x`、`y`、`z`に対して何かアクションを起こしたいものです。そのためには、以下のように記述します。

```cpp
#include<iostream>

struct Vector{
    int x,y,z;
};

int main()
{
    Vector v{1,2,3};

    std::cout<< v.x << " " << v.y << " " << v.z << std::endl; // アクセス
}
```

実行結果は以下となります。

```cpp
1 2 3
```

インスタンス化されたオブジェクトに対して`.`演算子を使い、その内部の変数を指定する事で、そのデータにアクセスする事ができます。`v.x`、`v.y`、`v.z`は、それぞれ`Vector`型の`x`、`y`、`z`にアクセスしています。

独自に定義した`Vector`(POD)型は、コピーや代入も今までのプリミティブ型のように行うことができます。
```cpp
struct Vector{
    int x,y,z;
};

int main()
{
    Vector v1{1,2,3};
    Vector v2=v1; // コピーして初期化
    v2=v1; // 代入
}
```
また「8.1 enum」で述べた`enum`と同じように、構造体/クラスの定義と同時にそのオブジェクトを定義することも可能です。
```cpp
struct Vector{
    int x,y,z;
}v1,v2{1,2,3},v3={1,2,3}; // v1は未初期化、v2はuniform initializationによって初期化、v3は従来の方法で初期化
```
そして、これまた「8.1 enum」で述べた`enum`と同じように、構造体/クラスを関数スコープ内で定義することもできます。
```cpp
void f()
{
    struct X{};
}
```
構造体/クラスも同様、スコープの概念を持ちます。

また、`enum`と同じように、構造体/クラスのオブジェクトを定義する際、`struct`/`class`キーワードを用いることが可能です。
```cpp
struct X{};

int main()
{
    struct X x;
    class X y; 
}
```
両者は全く同じ意味を持ちます。しかし、C++ではわざわざキーワードを付与する事はあまりありません。


...とここまでが、構造体、クラスの基本的な部分となりますが、そもそも型を作れて一体何が嬉しいのかと思うかもしれません。後に説明する機能を理解できれば、独自の型を定義できる事がどれだけ有意義な事かの理解がさらに容易くなりますが、ここまでだけでも十分実用性や意義を見出す事ができます。例えば、関数から値を返却する際、返せる値は1つのみでした。

```cpp
int f()
{
    return 42;
}

int main()
{
    std::cout << f() << std::endl; // 42
}
```
独自定義した型`Vector`を使えば、三つの`int`型のデータを返す事が可能となりますね。
```cpp
class Vector{
public:
    int x,y,z;
};

Vector f()
{
    return Vector{10,20,30};
}

int main()
{
    Vector vec = f();
    std::cout << vec.x << " " << vec.y << " " << vec.z << std::endl; // 10 20 30
}
```
`return Vector{10,20,30};`としているところは、以下のようにしても同じように動きます。
```cpp
Vector f()
{
    return {10,20,30};
}
```
関数`f`の戻り型に`Vector`を指定しているため、`{}`という記述だけでも型を推論することができます。この仕組みは、前述したuniform initializationに関係しているため、厳密な仕組みを現段階で気にする必要はありません。
# 9.6 継承/派生

この項では、今まで学習してきたクラスの概念に加えて継承という新しい概念を取り入れていきます。継承という概念によって既存のクラスの再利用性を高めたり、継承させたクラスに対して一定の強制力を持たせる事ができます。しかしむやみやたらに継承すれば、ただ複雑になるだけで利点を活かす事ができません。効果的に継承を使えるように、しっかりと本項目で学んでいきましょう。

## 9.6.1 継承の基本構文とアクセスレベル
まずは継承をどのように記述するのか見てしまいましょう。以下のコードを見てください。
```cpp
struct X{
    void f(){std::cout<<__func__<<std::endl;}
};

struct Y:public X{}; // クラスXを継承したクラスYを定義
```
継承を行うには、上記の通り、`struct`もしくは`class`でクラス名を宣言した後に`:`を記述し、その後アクセスレベルを付与し、継承するクラス名を付与します。継承を行ったクラスをインスタンス化して使って見ましょう。
```cpp
#include<iostream>

struct X{
    void f(){std::cout<<__func__<<std::endl;}
};

struct Y:public X{};

int main()
{
    Y y;
    y.f();
}
```
クラス`Y`には`f`という関数を定義していませんが、呼び出せています。継承によって、`X`から`f`を引き継いでいるので、`f`を利用する事ができるのです。以下、用語の紹介まで上記の場合のクラス`X`を派生元クラス、クラス`Y`を派生先クラスと呼称します。尚、派生先クラスの定義を記述する場合、その記述する位置から派生元クラスの定義が見えていなければなりません。つまり、派生先クラスの定義において、派生元クラスの前方宣言だけではプログラムとしては不適合となります。
```cpp
struct X; // クラスの前方宣言

struct Y:public X{ // NG
	// ...
};
```
ところで、継承した際に指定したアクセスレベルは、一体どのような効果を発揮するのでしょうか。
```cpp
struct X{
    int x=10;
};

struct Y:private X{}; // 継承時のアクセスレベルをprivateにしてみる

int main()
{
    Y y;
    y.x=20;
}
````
このコードはコンパイルに失敗します。エラー文では内容として派生元のクラスに対して`private`である事が示されています。つまり、**継承時のアクセスレベルの設定は、継承先から継承元を見た時に、どのようなアクセスレベルとして捉えるかを設定するものである**かという事です。この場合、`private`に設定しているため、継承先のクラス`Y`からは`X`のメンバーが全て`private`アクセスレベルであると認識するのです。よってクラス`Y`のインスタンスからは、`X`の内部メンバにアクセスする事ができないのです。しかし、`private`継承を行なっても、以下のように、継承先の内部で、継承元のメンバにアクセスする事は可能です。
```cpp
struct X{
    int x=10;
};

struct Y:private X{
    constexpr int get()const noexcept{return x;} // 継承先のメンバからはアクセス可
};

int main()
{
    Y y;
    y.get();
}
```
ところでアクセスレベルは、`public`、`private`の他に、`protected`というものがあります。`protected`は、自身と、継承先にのみメンバを公開する事を意味するアクセスレベルです。
```cpp
struct X{
    int a; // 全てに公開
protected:
    int b; // 自身と継承先に公開
private:
    int c; // 自身にのみ公開

    // X::a,X::b,X::cの全てにアクセスできる
};

struct Y:public X{
    // X::a、X::bにアクセスできる
};

int main()
{
    // X::aを操作できる    
}
```
継承先に対するアクセスレベルにも`protected`を指定する事ができます。`protected`を指定した場合、派生先からは派生元の`public`、`protected`は`protected`に、`private`は`private`アクセスレベルとして捉えます。
```cpp
struct X{
    int a;
protected:
    int b;
private:
    int c;
};

struct Y:protected X{
    // X::a,X::bにアクセスできる
};

int main()
{
    X x;
    x.a;  // Xのインスタンスからはaにアクセスできる

    Y y;
    y.a: // エラー！Yのインスタンスからはaはprotectedとして捉えられるためアクセスできない
}
```
尚、継承時にアクセスレベルを指定しない事もできます。
```cpp
struct W{};
struct X:W{}; // public継承

class Y{};
struct Z:Y{}; // private継承
```
その場合、派生元が`struct`キーワードを用いてクラスを定義しているか`class`キーワードを用いてクラスを定義しているかでその意味は異なります。**派生元クラスが`struct`キーワードで宣言されたクラスであり、そのクラスに対してアクセスレベルを指定せずに継承した場合、`public`継承となり**、**派生元クラスが`class`キーワードで宣言されたクラスであり、そのクラスに対してアクセスレベルを指定せずに継承した場合`private`継承となります**。


ところで、継承したクラスのコンストラクタ、デストラクタはどのように動作するのでしょうか。継承元にデータメンバを保持していた場合、継承元のデータメンバも正しく生成、破棄される必要がありますから継承元のクラスのコンストラクタやデストラクタも動作しそうです。実際に確認してみましょう。
```cpp
#include<iostream>

struct X{
    explicit X(){std::cout<<__func__<<std::endl;}
    ~X(){std::cout<<__func__<<std::endl;}
};

struct Y:X{
    explicit Y(){std::cout<<__func__<<std::endl;}
    ~Y(){std::cout<<__func__<<std::endl;}
};

int main()
{
    Y();
}
```
実行結果は以下の通りです。
```cpp
X
Y
~Y
~X
```
まず派生元のクラスのコンストラクタ、次に派生先のクラスのコンストラクタ、破棄時にはまず派生先のクラスのコンストラクタ、次に派生元のクラスのデストラクタが呼ばれます。このように、**コンストラクタとデストラクタの呼び出し順序は生成と破棄で逆順になります**。

最後に用語をまとめておきましょう。継承元となるクラスのことを**スーパークラス（親クラス、基本クラスなど）**と言い、継承を行うクラスを**サブクラス（子クラス、派生クラスなど） **といいます。


## 9.6.2 is-a関係

## 9.6.3 継承コンストラクタ

## 9.6.4 隠滅

## 9.6.5 継承を禁止する

## 9.6.6 スライシング
まず定義として、派生クラスは、基底クラスよりサイズが大きくなります。これは、派生クラスは、基底クラスのサイズに追加のメンバ変数うを持っている可能性があるため、断定できる条件なのです。つまりクラス`Base`という基底クラスからクラス`Derived`が派生クラスとして定義されていた場合、両者の関係は必ず`sizeof(Base) <= sizeof(Derived)`が`true`となります。

継承関係にあるクラス同士は、型変換が効くので以下のようなコードを記述する事もできます。
```cpp
struct Base{};

struct Derived:Base{};

int main()
{
    Base base=Derived(); // スライシング。派生クラスのインスタンスで基底クラスを初期化
}
```
しかし、このように基底クラス型のオブジェクトを派生クラスのオブジェクトで初期化すると、基底クラスは派生クラスの全ての情報を扱う事ができないため(派生クラスは基底クラスよりもサイズが大きい)、派生クラスに固有な情報が失われてしまいます。これを、**スライシング**と言います。

スライシングは、意図せず記述した場合明らかにバグとなりますので防止する必要がありますが、ここでの問題は実態として派生クラスのオブジェクトで初期化するために起きていますから、この場合基底クラスのオブジェクトではなく派生クラスのオブジェクトで派生クラスのオブジェクトを初期化する必要があります。

尚、ポインターや参照の場合は問題ありません。単に指し示すだけなので、データそのものが失われる事はないのです。
```cpp
struct Base{};

struct Derived:Base{};

int main()
{
    Base* ptr=new Derived();
    delete ptr;

    const Base& ref=Derived();
}
```
なぜわざわざ基底クラス型のポインターや参照で派生クラスのオブジェクトをポイントしておくのか、その利点については「9.6.7 仮想関数とオーバーライド」で明らかとなりますのでそれは一旦置いておくとして、実はこのように基底クラス型のポインターや参照として派生クラスをポイントしている場合でも、スライシングとはまた別の問題が発生してしまっているのです。何が起きてしまっているのかは、デストラクタの挙動を追いかける事で判明します。
```cpp
#include<iostream>

struct Base{
    ~Base(){std::cout<<__func__<<std::endl;}
};

struct Derived:Base{
    ~Derived(){std::cout<<__func__<<std::endl;}
};

int main()
{
    Base* ptr=new Derived();
    delete ptr;
}
```
実行結果は以下の通りです。
```cpp
~Base
```
なんと、派生クラスのデストラクタが呼び出されないのです。指し示している実態は`Derive`のインスタンスですが、delete の対象はポインターの型`Base`を元に動作するため、基底クラス側のデストラクタだけが呼び出される動作となってしまうのです。このような問題が起きないためには、基底クラスのポインター型でヒープ上に生成された派生クラスのオブジェクトをそもそも指し示さなければ良いのですが、これから解説する基底クラスのポインターで派生クラスのインスタンスを管理する事の利点を踏まえると、どうも捨てがたい機能ではあるのです。
この問題は、**仮想関数**という機能を用いる事で回避する事が可能です。

## 9.6.7 仮想関数とオーバーライド

vtable

## 9.6.8 多重継承、継承パターン、合成

## 9.6.9 EBO最適化

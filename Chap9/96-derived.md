# 9.6 継承/派生

この項では、今まで学習してきたクラスの概念に加えて継承という新しい概念を取り入れていきます。継承という概念によって既存のクラスの再利用性を高めたり、継承させたクラスに対して一定の強制力を持たせる事ができます。しかしむやみやたらに継承すれば、ただ複雑になるだけで利点を活かす事ができません。効果的に継承を使えるように、しっかりと本項目で学んでいきましょう。

## 9.6.1 継承の基本構文とアクセスレベル
まずは継承をどのように記述するのか見てしまいましょう。以下のコードを見てください。
```cpp
struct X{
    void f(){std::cout<<__func__<<std::endl;}
};

struct Y:public X{}; // クラスXを継承したクラスYを定義
```
継承を行うには、上記の通り、`struct`もしくは`class`でクラス名を宣言した後に`:`を記述し、その後アクセスレベルを付与し、継承するクラス名を付与します。継承を行ったクラスをインスタンス化して使って見ましょう。
```cpp
#include<iostream>

struct X{
    void f(){std::cout<<__func__<<std::endl;}
};

struct Y:public X{};

int main()
{
    Y y;
    y.f();
}
```
クラス`Y`には`f`という関数を定義していませんが、呼び出せています。継承によって、`X`から`f`を引き継いでいるので、`f`を利用する事ができるのです。ところで、継承した際に指定したアクセスレベルは、一体どのような効果を発揮するのでしょうか。
```cpp
struct X{
    int x=10;
};

struct Y:private X{}; // 継承時のアクセスレベルをprivateにしてみる

int main()
{
    Y y;
    y.x=20;
}
````
このコードはコンパイルに失敗します。エラー文では内容として派生元のクラスに対して`private`である事が示されています。つまり、**継承時のアクセスレベルの設定は、継承先から継承元を見た時に、どのようなアクセスレベルとして捉えるかを設定するものである**かという事です。この場合、`private`に設定しているため、継承先のクラス`Y`からは`X`のメンバーが全て`private`アクセスレベルであると認識するのです。よってクラス`Y`のインスタンスからは、`X`の内部メンバにアクセスする事ができないのです。しかし、`private`継承を行なっても、以下のように、継承先の内部で、継承元のメンバにアクセスする事は可能です。
```cpp
struct X{
    int x=10;
};

struct Y:private X{
    constexpr int get()const noexcept{return x;} // 継承先のメンバからはアクセス可
};

int main()
{
    Y y;
    y.get();
}
```
ところでアクセスレベルは、`public`、`private`の他に、`protected`というものがあります。`protected`は、自身と、継承先にのみメンバを公開する事を意味するアクセスレベルです。
```cpp
struct X{
    int a; // 全てに公開
protected:
    int b; // 自身と継承先に公開
private:
    int c; // 自身にのみ公開

    // X::a,X::b,X::cの全てにアクセスできる
};

struct Y:public X{
    // X::a、X::bにアクセスできる
};

int main()
{
    // X::aを操作できる    
}
```
継承先に対するアクセスレベルにも`protected`を指定する事ができます。`protected`を指定した場合、派生先からは派生元の`public`、`protected`は`protected`に、`private`は`private`アクセスレベルとして捉えます。
```cpp
struct X{
    int a;
protected:
    int b;
private:
    int c;
};

struct Y:protected X{
    // X::a,X::bにアクセスできる
};

int main()
{
    X x;
    x.a;  // Xのインスタンスからはaにアクセスできる

    Y y;
    y.a: // エラー！Yのインスタンスからはaはprotectedとして捉えられるためアクセスできない
}
```
尚、継承時にアクセスレベルを指定しない事もできます。
```cpp
struct W{};
struct X:W{}; // public継承

class Y{};
struct Z:Y{}; // private継承
```
その場合、派生元が`struct`キーワードを用いてクラスを定義しているか`class`キーワードを用いてクラスを定義しているかでその意味は異なります。**派生元クラスが`struct`キーワードで宣言されたクラスであり、そのクラスに対してアクセスレベルを指定せずに継承した場合、`public`継承となり**、**派生元クラスが`class`キーワードで宣言されたクラスであり、そのクラスに対してアクセスレベルを指定せずに継承した場合`private`継承となります**。


ところで、継承したクラスのコンストラクタ、デストラクタはどのように動作するのでしょうか。継承元にデータメンバを保持していた場合、継承元のデータメンバも正しく生成、破棄される必要がありますから継承元のクラスのコンストラクタやデストラクタも動作しそうです。実際に確認してみましょう。
```cpp
#include<iostream>

struct X{
    explicit X(){std::cout<<__func__<<std::endl;}
    ~X(){std::cout<<__func__<<std::endl;}
};

struct Y:X{
    explicit Y(){std::cout<<__func__<<std::endl;}
    ~Y(){std::cout<<__func__<<std::endl;}
};

int main()
{
    Y();
}
```
実行結果は以下の通りです。
```cpp
X
Y
~Y
~X
```
まず派生元のクラスのコンストラクタ、次に派生先のクラスのコンストラクタ、破棄時にはまず派生先のクラスのコンストラクタ、次に派生元のクラスのデストラクタが呼ばれます。このように、**コンストラクタとデストラクタの呼び出し順序は生成と破棄で逆順になります**。

最後に用語をまとめておきましょう。継承元となるクラスのことを**スーパークラス（親クラス、基本クラスなど）**と言い、継承を行うクラスを**サブクラス（子クラス、派生クラスなど） **といいます。

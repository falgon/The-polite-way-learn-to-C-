# 9.x 演算子のオーバーロード

第6章で、関数をオーバーロードできる事を学びましたが、なんと演算子すらもオーバーロードを行う事ができるのです。演算子のオーバーロードを適切に活用する事で、ソースコードに高いセマンティック性を与える事ができます。順に学んでいきましょう。

## 9.x.x new/delete\(overloading usual new/delete\)

new/delete演算子すらも、なんとオーバーロードすることができるのです。まず本稿では、より一般的なnew/deleteのオーバーロードについて説明します。

さて、まずはじめに、ここで種明かしのようになりますが、「第7章動的な領域確保」で行ったnew/delete演算子の操作は、**そもそも標準で用意されている、グローバル領域に定義されたoperator new、operator deleteを呼び出していた**のです。



## 9.x.x Placement new / delete\(overloading placement new/delete \)

本項ではこれまでで説明してきたnew/deleteとは少し異なる領域の確保/活用方法を説明します。

まず、`new`演算子には、「7.6 動的な領域確保」で述べたような使い方に加えて、情報を付加するような構文が二種類あります。これらは**placement new\(しばしば配置new\)**と呼ばれます。

まず一つ目ですが、`new`演算子は、領域の確保に失敗すると`std::bad_alloc`例外を送出しますが、従来の古いしきたりのように、例外ではなく`nullptr`を返すように設定することができます\(しかし、これは現代のC++ではdeprecatedとされているため、使うべきではありません\)。

```cpp
#include<new>

struct X{};

int main()
{
    X* ptr=new(std::nothrow) X();
    if(p)delete ptr;
}
```

`new()`と記述して、そこに`std::nothrow`を設定することで`nullptr`を返すようになります\(メモリ領域の確保中に起きる例外に限ります。オブジェクト生成中の例外、つまりコンストラクタ実行中の例外が発生した場合はそのまま例外を投げることになります\)。`std::nothrow`は`<new>`ヘッダに定義されている`std::nothrow_t`型の定数です。またこの構文は`new`演算子をオーバーロードすることで使うことができる構文です。上記の場合では、これまた`<new>`ヘッダの中で既にplacement newがオーバーロードされているため、使うことができています。

これらは、`<new>`ヘッダ内で以下のように宣言されています。

```cpp
void* operator new(std::size_t, const std::nothrow_t&)noexcept;
void* operator new[](std::size_t, const std::nothrow_t&)noexcept;
void operator delete(void*, const std::nothrow_t&)noexcept;
void operator delete[](void*, const std::nothrow_t&)noexcept;
```

全てが`noexcept`修飾されていることに注目してください。`std::nothrow`によって例外は投げないと指定していることからその明示性が伺えます。

因みにこれらは、



さて、ここまでで説明してきた動的な領域確保は、主に**ヒープ領域から**使うぶんの領域を確保していました。ここで、ヒープ領域から単純に領域を確保する際の短所を考察してみます。

* ヒープ領域から領域を確保するのは一般的にスタック領域から確保するよりも低速です。
* new演算子、malloc系関数を用いたヒープ領域からのリソース確保の方法は処理系のメモリ管理アルゴリズムに依存するため、ユーザー定義な独自の管理を行う事ができない

これらを解消するためには、ヒープ領域でない部分から領域を取ってくると良いかもしれません。

placement new構文は、それを可能にします。まずは領域をスタック領域から確保して、それを使うという事をしてみましょう。それをするためには、new/deleteをplacement newの形でオーバーロードしなければなりません。やっていることは、確保済みの領域から領域を取って来るといったところでしょうか。コードを見てしまった方が理解に容易いでしょう。以下に、方法を示します。

```cpp
#include<iostream>

struct X{
    X(){std::cout<<"ctor"<<std::endl;}
    ~X(){std::cout<<"dtor"<<std::endl;}

    void* operator new(std::size_t,void* ptr){return ptr;}
    void operator delete(void*,void*)noexcept{}
};

int main()
{
    char resource[sizeof(X)];
    X* ptr=new(resource) X;
    ptr->~X();
}
```

実行結果は以下の通りです。

まず`main`内では、char型の配列を用意しています。そのサイズは、`X`型と同じバイト長です。char型は必ず1 byteであることが定められていますから、その領域ぶんのサイズを確保できれば、当然ながら互換性がある事になります。今回は、あらかじめ用意した領域は`X`型1つ分ということになります。

次に`X`型内部を見て見ましょう。new/delete演算子をオーバーロードしていることが伺えます。先ほどのusual new/deleteとは異なり、引数の数が多いですね。

```cpp
#include<iostream>
#include<new>

struct X{
    X(){std::cout<<"ctor"<<std::endl;}
    ~X(){std::cout<<"dtor"<<std::endl;}
};

int main()
{
    char resource[sizeof(X)];

    X* ptr=new (resource) X();
    ptr->~X();
}
```

実行結果は以下の通りです。

```cpp
ctor
dtor
```

まずは、`<new>`というヘッダで既にplacement newを用いたオーバーロードが行われているため、今回はそれを使っていますが、挙動としては、端的にコードで言えば`resource`から希望したサイズぶんの領域をとってくるだけといった挙動をします。

このようにplacement newを使ってメモリ割当てを行うシステムを、**アロケータ**と言い、アロケータによる管理の基使われる予定である予め確保された領域を**メモリプール**と言います。標準で用意されたライブラリの中でも、独自のアロケータでメモリ管理ができるように、設定の引数が設けられていたりするのですが、詳細は第12章のSTLと標準ライブラリで取り上げることとします。

さて、ここまでスタック領域からリソースを取れるということを売りにしてきたplacement newですが、ヒープ領域からも領域を取得することは可能です。

スタック領域の確保は、どうしても固定長\(コンパイル時に定まった値\)でなければならないため、メモリプールの領域も可変にしたい、しかし連続的に領域の確保/破棄がしたいためにメモリプールは欲しいといった場合では対応できません。そう行った場合は、以下のようにヒープ領域からメモリプールを確保してそこをplacement newするという手段も考えられます。

### メモリリソースの断片化

ここで一度、メモリリソースの断片化について取り上げます。

**リソース領域から、多くの回数領域の確保、解放の操作を繰り返すと、断片化が発生してしまい**、希望する領域サイズ分が、リソース中の空き領域の合計サイズと同等以上あったとしても、連続した領域で確保する事ができないため\(ある程度のサイズのデータ領域を確保しようとした時、私たちに与えられている領域確保の方法は配列であり、配列は連続した領域に確保されるという事を思い出してください。\)、領域の確保に失敗すると行った事が起こり得るようになります。

断片化していくメモリの様子を図に示しました。この領域確保の手法は、**ファーストフィット**と呼ばれるもので、主に一番最初に見つかった確保可能な領域を使用するアルゴリズムです。

**ファーストフィット**の次に一般的な領域確保の手法として**ベストフィット**という手法も紹介します。これは、空き容量の中で欲しいサイズ以上の最も近いサイズの領域を使うと行った考え方で、ファーストフィットのように最初に見つかった領域を単に使うだけなのと比較して、一般的に断片化が起きにくいと考えられるものの、空き容量のリストを全探索しなければならないため、処理時間がかかってしまう傾向にあります。両者の相違点は過程6,7,8部分にあります。

実際に断片化しやすいコードを書いてみました。

このような事を防ぐためには、二つの方法が考えられますね。

* 断片化を防止する
* 断片化したリソースを整理し再利用可能にする

まず断片化がおきないように領域確保を行うこと、これは可能であれば最も好ましい解決方法でしょう。後術する断片化したリソースの再整理は、再整理するだけの処理能力をやはり覆わなくてはなりません。それをなしに、初めから効率の良いリソース確保ができるのであれば、それが最も良いパフォーマンスの出し方であることは想像に容易いでしょう。しかし、断片化が起きないようにするリソース確保の手法は一概にこれであるとすることはできません。何故ならば、最適な確保の仕方も、要求される条件や処理系に依存するからです。前述したファーストフィット、ベストフィットといった単純な手法の他にも様々な活用方法が考案されています。よって、ここでは深く触れませんが、その概要がわかりやすく[こちらのスライド](https://www.slideshare.net/alwei/ss-11521742)で紹介されていますので、興味のある方は調べてみるのも良いでしょう。

次に、断片化を整理する、**デフラグ**という操作を行う事で再利用可能にする方法です。デフラグの手法は様々ですが、内容としては断片化したリソース領域を一方方向に全てずらして詰めてあげる\(メモリコンパクション\)といった具合に行います。デフラグの方法については、まだ説明していませんが、主に演算子オーバーロードなどを用いて領域確保の手法や管理方法を各個人が再定義する事で可能となりますが、これについての詳細はまた一つ大きな分野であるため、本章では取り扱いません。


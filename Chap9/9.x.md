# 9.x 演算子のオーバーロード

第6章で、関数をオーバーロードできる事を学びましたが、なんと演算子すらもオーバーロードを行う事ができるのです。演算子のオーバーロードを適切に活用する事で、ソースコードに高いセマンティック性を与える事ができます。順に学んでいきましょう。

## 9.x.x new/delete\(usual new/delete\)

new/delete演算子すらも、なんとオーバーロードすることができるのです。まず本稿では、より一般的なnew/deleteのオーバーロードについて説明します。

さて、まずはじめに、ここで種明かしのようになりますが、「第7章動的な領域確保」で行ったnew/delete演算子の操作は、**そもそも標準で用意されている、グローバル領域に暗黙的に定義されたoperator new、operator deleteを呼び出していた**のです。

以下らがプログラムの翻訳単位で暗黙的に定義されます。

```cpp
void* operator new(std::size_t);
void* operator new(std::size_t, std::align_val_t);
void operator delete(void*) noexcept;
void operator delete(void*, std::size_t) noexcept;
void operator delete(void*, std::align_val_t) noexcept;
void operator delete(void*, std::size_t, std::align_val_t) noexcept;
void* operator new[](std::size_t);
void* operator new[](std::size_t, std::align_val_t);
void operator delete[](void*) noexcept;
void operator delete[](void*, std::size_t) noexcept;
void operator delete[](void*, std::align_val_t) noexcept;
void operator delete[](void*, std::size_t, std::align_val_t) noexcept;
```

通常のnew/delete演算子を実行すると、これらの暗黙定義された関数が実行されることになっています。

operator new/deleteの第二引数、`std::size_t`にはそのオブジェクトのバイト数が渡されます。

`std::alignval_t`は、アライメントが、標準で定義されている`__STDCPP_DEFAULT_NEW_ALIGNMENT__`というマクロ定数よりも大きいオブジェクトと使われた場合にそのアライメントを送信するために使われます\(アライメントについてはコラムを参照\)。これらと同じシグネチャでユーザーがグローバル領域にnew/deleteを定義した場合、**翻訳段階でその定義によって完全に上書きされます。**

ではこれらを全て独自に定義して、これまで説明してきたものを確認してみましょう。

```cpp
#include<cstdio>
#include<cstdlib>

struct liner{
    static void line()
    {
        for(std::size_t i=0; i<50; ++i)printf("-");
        puts("");
    }

    liner(){line();}
    ~liner(){line();}
};

// Single object operator new
void* operator new(std::size_t x) // (1)
{
    liner _;

    std::printf("1 param op %s std::size_t is %ld\n",__func__,x);
    return std::malloc(x);
}

void* operator new(std::size_t x,std::align_val_t align) // (2)
{
    liner _;

    std::printf("2 param op %s std::size_t is %ld\n",__func__,x); 
    std::printf("align is %ld\n",static_cast<std::size_t>(align));

    return aligned_alloc(static_cast<std::size_t>(align),x);
}

// Array object operator new
void* operator new[](std::size_t x) // (3)
{
    liner _;

    std::printf("1 param op %s std::size_t is %ld\n",__func__,x);
    return std::malloc(x);
}

void* operator new[](std::size_t x,std::align_val_t align) // (4)
{
    liner _;

    std::printf("2 params op %s std::size_t is %ld\n",__func__,x);
    std::printf("align is %ld\n",static_cast<std::size_t>(align));

    return aligned_alloc(static_cast<std::size_t>(align),x);
}

// Single object operator delete
void operator delete(void* ptr)noexcept // (5)
{
    liner _;

    std::printf("1 param op %s\n",__func__);
    std::free(ptr);
}

void operator delete(void* ptr,std::size_t x)noexcept // (6)
{
    liner _;

    std::printf("2 params op %s std::size_t is %ld\n",__func__,x);
    std::free(ptr);
}

void operator delete(void* ptr,std::align_val_t align)noexcept // (7)
{
    liner _;

    std::printf("2 param op %s\n",__func__);
    std::printf("align is %ld\n",static_cast<std::size_t>(align));
    std::free(ptr);
}

void operator delete(void* ptr,std::size_t x,std::align_val_t align)noexcept // (8)
{
    liner _;

    std::printf("3 param op %s std::size_t is %ld\n",__func__,x);
    std::printf("align is %ld\n",static_cast<std::size_t>(align));
    std::free(ptr);
}

// Array object operator delete
void operator delete[](void* ptr)noexcept // (9)
{
    liner _;

    std::printf("1 param op %s\n",__func__);
    std::free(ptr);
}

void operator delete[](void* ptr,std::size_t x)noexcept // (10)
{
    liner _;

    std::printf("2 params op %s std::size_t is %ld\n",__func__,x);
    std::free(ptr);
}


void operator delete[](void* ptr,std::align_val_t align)noexcept // (11)
{
    liner _;

    std::printf("2 params op %s\n",__func__);
    std::printf("align is %ld\n",static_cast<std::size_t>(align));
    std::free(ptr);
}


void operator delete[](void* ptr,std::size_t x,std::align_val_t align)noexcept // (12)
{
    liner _;

    std::printf("3 params op %s std::size_t is %ld\n",__func__,x);
    std::printf("align is %ld\n",static_cast<std::size_t>(align));
    std::free(ptr);
}

struct X{
    X(){std::puts(__func__);}
    ~X(){std::puts(__func__);}    

    char a[200];
};

struct alignas((__STDCPP_DEFAULT_NEW_ALIGNMENT__*2)) Y{
    Y(){std::puts(__func__);}
    ~Y(){std::puts(__func__);}
};


int main()
{
    delete new X();
    delete new Y();

        delete[] new X[3];
        delete[] new Y[3];
}
```

実行結果は以下の通りです。

```cpp
--------------------------------------------------
1 param op operator new std::size_t is 200
--------------------------------------------------
X
~X
--------------------------------------------------
2 params op operator delete std::size_t is 200
--------------------------------------------------
--------------------------------------------------
2 param op operator new std::size_t is 32
align is 32
--------------------------------------------------
Y
~Y
--------------------------------------------------
3 param op operator delete std::size_t is 32
align is 32
--------------------------------------------------
--------------------------------------------------
1 param op operator new [] std::size_t is 608
--------------------------------------------------
X
X
X
~X
~X
~X
--------------------------------------------------
2 params op operator delete [] std::size_t is 608
--------------------------------------------------
--------------------------------------------------
2 params op operator new [] std::size_t is 96
align is 32
--------------------------------------------------
Y
Y
Y
~Y
~Y
~Y
--------------------------------------------------
3 params op operator delete [] std::size_t is 128
align is 32
--------------------------------------------------
```

この実行結果から、様々なものが表されていますね。

オーバーロードは上から単一のオブジェクト用のoperator new、複数のオブジェクト用のoperator new\[\]、単一のオブジェクトのoperator delete、複数のオブジェクト用のoperator delete\[\]と記述されています（`liner`という型を作っていますが、その名の通り単に罫線を引くためだけのものなので、本項の内容とは特別関係ありません。\)。

`main`関数内の実行過程をここで順に見ていきましょう。

`main`関数では、まず一番初めに単一の`X`型をnewしています。この時呼び出されるのは`(1)`のoperator newです。その後、出力からわかるように`X`のコンストラクタが呼ばれています。`main`関数ですぐさまそれをdeleteしていますので、その後の即座に`X`のデストラクタが呼ばれていることがわかります。その後、operator deleteが呼び出されます。この時呼び出されるのは`(6)`のoperator deleteです。

次に、単一の`Y`型をnewしています。`Y`型の定義部分に注目してください。`struct alignas((__STDCPP_DEFAULT_NEW_ALIGNMENT__*2)) Y`となっています。これは、`Y`型のインスタンスを特定のバイト境界でメモリにおけ

グローバルに定義したものは、引数の多いoperator deleteが優先的に呼び出されます。しかし、クラスメンバはとして定義した場合は若干異なり、引数の少ないoperator deleteが呼び出される事となります。これは厳密にいうと優先度の変化というわけではなく、**operator deleteをクラススコープでオーバーロードした場合、**`void*`**一つを受け付けるoperator delete、**`void*`**に加えて**`std::alignval_t`**を受け付けるoperator deleteはusual delete\(通常のdelete\)として、**`void*`**に加えて**`std::size_t`**を受け付けるoperator deleteはplacement deleteとして捉えられるため**です。

```cpp
/*                             */
/* []といった配列版を省略...     */
/*                             */

// グローバルスコープ ...
void operator new(std::size_t); // usual new
void operator delete(void*)noexcept; // usual delete
void operator delete(void*,std::align_val_t)noexcept; // usual delete
void operator delete(void*,std::size_t)noexcept; // usual delete

// クラススコープ...
struct X{
    void operator new(std::size_t); // usual new
    void operator delete(void*)noexcept; // usual delete
    void operator delete(void*,std::align_val_t)noexcept; // usual delete
    void operator delete(void*,std::size_t)noexcept; // placement delete
};
```

operator new/deleteは、usualなnewであればusualなdeleteを、placementなnewであればplacementなdeleteを呼ぶため、捉えられ方によって挙動が少し変わる結果となっています。

## 9.x.x Placement new / delete\(placement/Non-allocating forms new/delete \)

本項ではこれまでで説明してきたnew/deleteとは少し異なる領域の確保/活用方法を説明します。

まず、`new`演算子には、「7.6 動的な領域確保」で述べたような使い方に加えて、情報を付加するような構文があり、標準で定義されたものは二種類に分類することができます。これらは**placement new\(しばしば配置new\)**と呼ばれます。

### newヘッダーに定義されるplacement-new

まず一つ目ですが、`new`演算子は、領域の確保に失敗すると`std::bad_alloc`例外を送出しますが、従来の古いしきたりのように、例外ではなく`nullptr`を返すように設定することができます\(しかし、これは現代のC++ではdeprecatedとされているため、`nullptr`を返すようにするべきではありません\)。

```cpp
#include<new>

struct X{};

int main()
{
    X* ptr=new(std::nothrow) X();
    if(p)delete ptr;
}
```

`new()`と記述して、そこに`std::nothrow`を設定することで`nullptr`を返すようになります\(メモリ領域の確保中に起きる例外に限ります。オブジェクト生成中の例外、つまりコンストラクタ実行中の例外が発生した場合はそのまま例外を投げることになります\)。`std::nothrow`は`<new>`ヘッダに定義されている`std::nothrow_t`型の定数です。またこの構文は`new`演算子をオーバーロードすることで使うことができる構文です。上記の場合では、これまた`<new>`ヘッダの中で既にplacement newがオーバーロードされているため、使うことができています。

これらは、`<new>`ヘッダ内で以下のように宣言されています。

```cpp
void* operator new(std::size_t, const std::nothrow_t&)noexcept;
void* operator new[](std::size_t, const std::nothrow_t&)noexcept;
void operator delete(void*, const std::nothrow_t&)noexcept;
void operator delete[](void*, const std::nothrow_t&)noexcept;
```

全てが`noexcept`修飾されていることに注目してください。`std::nothrow`によって例外は投げないと指定していることからその明示性が伺えます。

### Non-allocating forms

次に二つ目です。

さて、ここまでで説明してきた動的な領域確保は、主に**ヒープ領域から**使うぶんの領域を確保していました。ここで、ヒープ領域から単純に領域を確保する際の短所を考察してみます。

* ヒープ領域から領域を確保するのは一般的にスタック領域から確保するよりも低速です。
* new演算子、malloc系関数を用いたヒープ領域からのリソース確保の方法は処理系のメモリ管理アルゴリズムに依存するため、ユーザー定義な独自の管理を行う事ができない

これらを解消するためには、ヒープ領域でない部分から領域を取ってくると良いかもしれません。

placement new構文は、それを可能にします。まずは領域をスタック領域から確保して、それを使うという事をしてみましょう。それをするためには、new/deleteをplacement newの形でオーバーロードしなければなりません。やっていることは、確保済みの領域から領域を取って来るといったところでしょうか。コードを見てしまった方が理解に容易いでしょう。以下に、方法を示します。

```cpp
#include<iostream>

struct X{
    X(){std::cout<<"ctor"<<std::endl;}
    ~X(){std::cout<<"dtor"<<std::endl;}

    void* operator new(std::size_t,void* ptr){return ptr;}
    void operator delete(void*,void*)noexcept{}
};

int main()
{
    char resource[sizeof(X)];
    X* ptr=new(resource) X;
    ptr->~X();
}
```

実行結果は以下の通りです。

まず`main`内では、char型の配列を用意しています。そのサイズは、`X`型と同じバイト長です。char型は必ず1 byteであることが定められていますから、その領域ぶんのサイズを確保できれば、当然ながら互換性がある事になります。今回は、あらかじめ用意した領域は`X`型1つ分ということになります。

次に`X`型内部を見て見ましょう。new/delete演算子をオーバーロードしていることが伺えます。先ほどのusual new/deleteとは異なり、引数の数が多いですね。

```cpp
#include<iostream>
#include<new>

struct X{
    X(){std::cout<<"ctor"<<std::endl;}
    ~X(){std::cout<<"dtor"<<std::endl;}
};

int main()
{
    char resource[sizeof(X)];

    X* ptr=new (resource) X();
    ptr->~X();
}
```

実行結果は以下の通りです。

```cpp
ctor
dtor
```

まずは、`<new>`というヘッダで既にplacement newを用いたオーバーロードが行われているため、今回はそれを使っていますが、挙動としては、端的にコードで言えば`resource`から希望したサイズぶんの領域をとってくるだけといった挙動をします。

このようにplacement newを使ってメモリ割当てを行うシステムを、**アロケータ**と言い、アロケータによる管理の基使われる予定である予め確保された領域を**メモリプール**と言います。標準で用意されたライブラリの中でも、独自のアロケータでメモリ管理ができるように、設定の引数が設けられていたりするのですが、詳細は第12章のSTLと標準ライブラリで取り上げることとします。

さて、ここまでスタック領域からリソースを取れるということを売りにしてきたplacement newですが、ヒープ領域からも領域を取得することは可能です。

スタック領域の確保は、どうしても固定長\(コンパイル時に定まった値\)でなければならないため、メモリプールの領域も可変にしたい、しかし連続的に領域の確保/破棄がしたいためにメモリプールは欲しいといった場合では対応できません。そう行った場合は、以下のようにヒープ領域からメモリプールを確保してそこをplacement newするという手段も考えられます。

### メモリリソースの断片化

ここで一度、メモリリソースの断片化について取り上げます。

**リソース領域から、多くの回数領域の確保、解放の操作を繰り返すと、断片化が発生してしまい**、希望する領域サイズ分が、リソース中の空き領域の合計サイズと同等以上あったとしても、連続した領域で確保する事ができないため\(ある程度のサイズのデータ領域を確保しようとした時、私たちに与えられている領域確保の方法は配列であり、配列は連続した領域に確保されるという事を思い出してください。\)、領域の確保に失敗すると行った事が起こり得るようになります。

断片化していくメモリの様子を図に示しました。この領域確保の手法は、**ファーストフィット**と呼ばれるもので、主に一番最初に見つかった確保可能な領域を使用するアルゴリズムです。

**ファーストフィット**の次に一般的な領域確保の手法として**ベストフィット**という手法も紹介します。これは、空き容量の中で欲しいサイズ以上の最も近いサイズの領域を使うと行った考え方で、ファーストフィットのように最初に見つかった領域を単に使うだけなのと比較して、一般的に断片化が起きにくいと考えられるものの、空き容量のリストを全探索しなければならないため、処理時間がかかってしまう傾向にあります。両者の相違点は過程6,7,8部分にあります。

実際に断片化しやすいコードを書いてみました。

このような事を防ぐためには、二つの方法が考えられますね。

* 断片化を防止する
* 断片化したリソースを整理し再利用可能にする

まず断片化がおきないように領域確保を行うこと、これは可能であれば最も好ましい解決方法でしょう。後術する断片化したリソースの再整理は、再整理するだけの処理能力をやはり覆わなくてはなりません。それをなしに、初めから効率の良いリソース確保ができるのであれば、それが最も良いパフォーマンスの出し方であることは想像に容易いでしょう。しかし、断片化が起きないようにするリソース確保の手法は一概にこれであるとすることはできません。何故ならば、最適な確保の仕方も、要求される条件や処理系に依存するからです。前述したファーストフィット、ベストフィットといった単純な手法の他にも様々な活用方法が考案されています。よって、ここでは深く触れませんが、その概要がわかりやすく[こちらのスライド](https://www.slideshare.net/alwei/ss-11521742)で紹介されていますので、興味のある方は調べてみるのも良いでしょう。

次に、断片化を整理する、**デフラグ**という操作を行う事で再利用可能にする方法です。デフラグの手法は様々ですが、内容としては断片化したリソース領域を一方方向に全てずらして詰めてあげる\(メモリコンパクション\)といった具合に行います。デフラグの方法については、まだ説明していませんが、主に演算子オーバーロードなどを用いて領域確保の手法や管理方法を各個人が再定義する事で可能となりますが、これについての詳細はまた一つ大きな分野であるため、本章では取り扱いません。


# 9.x 演算子のオーバーロード

第6章で、関数をオーバーロードできる事を学びましたが、なんと演算子すらもオーバーロードを行う事ができるのです。演算子のオーバーロードを適切に活用する事で、ソースコードに高いセマンティック性を与える事ができます。順に学んでいきましょう。

## 9.x.x new/delete\(overloading usual new/delete\)

## 9.x.x Placement new / delete\(overloading placement new/delete \)

これまでで説明してきたnew/deleteとは少し異なる領域の確保/活用方法を、本項目では説明します。

ここまでで説明してきた動的な領域確保は、主に**ヒープ領域から**使うぶんの領域を確保していました。ここで、ヒープ領域から単純に領域を確保する際の短所を考察してみます。

* ヒープ領域から領域を確保するのは一般的にスタック領域から確保するよりも低速です。
* new演算子、malloc系関数を用いたヒープ領域からのリソース確保の方法は処理系のメモリ管理アルゴリズムに依存するため、ユーザー定義な独自の管理を行う事ができない

これらを解消するためには、**placement new**という手法を用いるのが良いでしょう\(しばしば配置newとも呼ばれる\)。placement newは、まず領域を**スタック領域**から確保して、それを使うという手法です。謂わば、確保済みの領域から領域を取って来るといったところでしょうか。コードを見てしまった方が理解に容易いでしょう。以下に、方法を示します。



```cpp
#include<iostream>
#include<new>

struct X{
	X(){std::cout<<"ctor"<<std::endl;}
	~X(){std::cout<<"dtor"<<std::endl;}
};

int main()
{
	char resource[sizeof(X)];

	X* ptr=new (resource) X();
	ptr->~X();
}
```

実行結果は以下の通りです。

```cpp
ctor
dtor
```

まずは、`<new>`というヘッダで既にplacement newを用いたオーバーロードが行われているため、今回はそれを使っていますが、挙動としては、端的にコードで言えば`resource`から希望したサイズぶんの領域をとってくるだけといった挙動をします。

このようにplacement newを使ってメモリ割当てを行うシステムを、**アロケータ**と言い、アロケータによる管理の基使われる予定である予め確保された領域を**メモリプール**と言います。標準で用意されたライブラリの中でも、独自のアロケータでメモリ管理ができるように、設定の引数が設けられていたりするのですが、詳細は第12章のSTLと標準ライブラリで取り上げることとします。

さて、ここまでスタック領域からリソースを取れるということを売りにしてきたplacement newですが、ヒープ領域からも領域を取得することは可能です。



スタック領域の確保は、どうしても固定長\(コンパイル時に定まった値\)でなければならないため、メモリプールの領域も可変にしたい、しかし連続的に領域の確保/破棄がしたいためにメモリプールは欲しいといった場合では対応できません。そう行った場合は、以下のようにヒープ領域からメモリプールを確保してそこをplacement newするという手段も考えられます。


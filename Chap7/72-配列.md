# 7.2 配列

「2.4 配列を触ってみる」にて配列には少し触れましたね。ここでは、更に深く配列について触れていきます。まずは配列の特徴を捉えるために、配列を定義してその各要素のアドレスを見てましょう。

```cpp
#include<iostream>
int main()
{
    int array[5];
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
        std::cout<< &array[i] <<std::endl;
}
```
実行結果は例のごとく実行時/実行環境によって左右しますが、ある特徴があるのです。筆者の環境では以下のように出力されました。

```cpp
0x7fff503b8590
0x7fff503b8594
0x7fff503b8598
0x7fff503b859c
0x7fff503b85a0
```
配列`array`のそれぞれの要素のアドレス値が出力されています。この時、アドレスのそれぞれの末尾を見比べて見てください。

```
0x...8590
0x...8594
0x...8598
0x...859c
0x...85a0
```
`90`、`94`、`98`...というように`4`バイトずつそれぞれが領域を使っていてかつ順序良く並んでいる事に気付きましたでしょうか。何故`4`バイトずつなのでしょうか。それは、`int`型だからです。配列の型を、例えば`char`型にしてもう一度見て見ましょう。
```cpp
#include<iostream>
int main()
{
    char array[5];
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
        std::cout<< static_cast<void*>(&array[i]) <<std::endl;
}

```
筆者の環境では以下のように出力されました。

```cpp
0x7fff5cfbb597
0x7fff5cfbb598
0x7fff5cfbb599
0x7fff5cfbb59a
0x7fff5cfbb59b
```
末尾の数値を見てください。`char`型は1バイトの領域を使うためそれぞれの要素が1バイトずつ綺麗に並んでいる事が分かります。このように配列を宣言すると、論理的には、**その要素は必ず順序良く並んでメモリ上に置かれます**。では次に、以下のコードを見て見ましょう。

```cpp
#include<iostream>
int main()
{
    int array[5];
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
        std::cout<< &array[i] <<std::endl;
    std::cout<<"----------------"<<std::endl;
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
        std::cout<< &array[0]+i << std::endl;
}
```
筆者の環境では以下のように出力されました。

```cpp
0x7fff56311590
0x7fff56311594
0x7fff56311598
0x7fff5631159c
0x7fff563115a0
----------------
0x7fff56311590
0x7fff56311594
0x7fff56311598
0x7fff5631159c
0x7fff563115a0
```
上の結果がそれぞれの要素のアドレスです。下は、なんとアドレスに対して変数`i`を加算しています。アドレスに数値を足すと一体どういったことが起きるのでしょうか。

```cpp
int main()
{
    int array[5]={};
    &array[0]+1;
}
```
これは、**`array[0]`のアドレスから`4`バイト分先のアドレスへアクセスする**という意味になるのです。先ほど、配列を宣言すると順序良くそのデータ型サイズ分をあけて並べられると述べました。よって`array[0]`のアドレスに対して`1`を加算することで実際には`array[1]`のデータへアクセスする事ができるのです。つまり`array[数値]`は、`&array[0]+数値`と同じ場所を示しているという事になります。今回は、配列`array`が`int`型の配列であると宣言されているため、`1`を加算すると`array[0]`のアドレスから4バイト分先のアドレスへ進みますが、配列の型が例えば`char`型だった場合、`1`を加算した時に進むバイト数は`1`バイトです。このように、型によって適切に次の要素へ進めるようになっているのです。

```cpp
#include<iostream>
int main()
{
    int array[]={1,2,3,4,5};
    int* ptr = &array[0]+1;
    std::cout<< *ptr <<std::endl;
}
```
実行結果は以下となります。
```cpp
2
```
`array[0]`のアドレスから1要素分(4バイト)進んだ先、つまり`array[1]`のアドレスを`ptr`というポインタに代入しています。それを出力しているのですから、`2`が出力されますね。

### 7.2.1 配列の概念から考えるポインタ型の必要性

そもそも、ここまででポインターの変数型は全て32ビットであれば4バイト、64ビットであれば8バイトであると述べました。「サイズが全て同じであるならポインタの型は何でも良いじゃないか！」と思うかもしれません。しかしそれにはここまでに述べてきた通り、**何型のポインタなのか**を適切に指定しなければ、そのデータの実体の1単位の区切りを適切にコンピュータは知り得る事ができません。またそのような理由から、アドレスに対して`1`を加算した時、その型のバイト数分を進む事ができないのです。(reinterpret_castについては気にしなくても大丈夫です)

```cpp
#include<climits>
#include<iostream>
int main()
{
    int array[]={INT_MAX,42};
    char* ptr=reinterpret_cast<char*>(&array[0]); // int型のデータがある領域のアドレスを強引にchar型のポインターへ代入
    std::cout<< *(ptr+1) << std::endl; // うまく動かない
}
```

このプログラムは、明確な言語規格違反なコードであり、正しく動作しません。`int`型は一つにつき`4`バイトのサイズを使います。よってそのアドレスに+1された場合、`4`バイト分進まなければ次の要素にアクセスする事はできません。しかし、`char`型のポインタ型に強引に代入してアクセスした事で、`1`バイト分のデータを読み取ろうとしてしまいます。また、+1しても進むのは`4`バイト分ではなく、`1`バイトのため、正しくアクセスする事はできないのです。このために、各型に対するポインタ型というものが必要となるのです。

```cpp
#include<iostream>
int main()
{
    int array[]={1,2};
    int* ptr=&array[0]; // int型へのポインターとして宣言、array[0]のアドレスで初期化
    std::cout<< *(ptr+1) << std::endl; // 2が出力される。
}
```
`ptr`の宣言において`int`型のポインターである旨を明示していますから、`ptr+1`では正しく`int`型のデータ量である4バイト分メモリアドレスを進めるため`array[1]`の値`2`が出力されるのです。

この時、実はポインターが指し示す実際のデータの型が何の型であるか明示しないが、とりあえずポインターであるという事だけ宣言するといった方法もあ実は存在します。それは、以下のように、`void*`とする事によって表します。
```cpp
void* ptr;
```
しかし、ここまで話してきた通り、何の型のポインターであるのか分からないので、以下のように実際にポイントするアドレスを指定して、そのポインターから値を読み取ろうとしても、上手く動きません。
```cpp
int main()
{
    int a=10;
    void* ptr=&a;
    *ptr; // 意図した通りには動かない
}
```
では、`void*`として何型の値をもつデータを指すのか指定していないポインターでは、実際の値を読み取る事はできないのでしょうか。いいえ、**キャスト**をする事で実際の値を読み取る事が可能です。
```cpp
int main()
{
    int a=10;
    void* ptr=&a;
    *static_cast<int*>(ptr); // キャスト
}
```
キャストには上記の`static_cast`以外にも様々な種類がありますが、話が脱線してしまいますのでここではまだ解説しません。「第9章 構造体とクラス」で一気に全てのキャストについて説明します。

### 7.2.2 配列とポインタの関係性

以下のように記述すると何が出力されるでしょうか。

```cpp
#include<iostream>
int main()
{
    int array[2];
    std::cout << &array[0] << std::endl;
    std::cout << array << std::endl;
}
```
筆者の環境では以下のように出力されました。

```cpp
0x7fff5daba5a0
0x7fff5daba5a0
```
同じアドレス値が出力されています。何故なら、**`array`は配列の先頭アドレスを指すポインター**だからです。実は、今まで使ってきた`[]`演算子は、`array[添え字]`とあった場合、**`array`ポインターが指すアドレスからどれだけの要素分離れているかを表していた**のです。つまり、`*(array+添え字)`の代替手段のようなものだったとも捉える事ができます。(このようなものをシンタックスシュガーと言ったりします)

よく分からないかもしれませんが、以下のコードをじっくり見て見ると分かりやすいでしょう。
```cpp
#include<iostream>
int main()
{
    int array[]={10,20};
    std::cout << array[1] << std::endl;
    std::cout << *(&array[0]+1) << std::endl;
    std::cout << *(array+1) << std::endl;
}
```
実行結果は以下となります。

```cpp
20
20
20
```
関係性が見えてきましたでしょうか。`array[1]`と`*(array+1)`は全く同じ意味なのです。そして、`*(&array[0]+1)`は、`array[0]`のアドレス、つまり`array`の先頭アドレスから`+1`したアドレスの`*`としていますからその部分の値、つまり`20`が取得できますね。よって意味合いとしては全て同じ事となるのです。

ところで、`*(配列+添え字)`は`*(添え字+配列)`と同じになるでしょうか。当然ながら、同じです。加算の場合、数値を入れ替えてもその演算結果は変わりませんね。では、`配列名[添え字]`は`添え字[配列名]`と同じになるでしょうか。実はこれも、同じになるのです。

```cpp
#include<iostream>
int main()
{
    int array[]={10,20};
    std::cout << 1[array] << std::endl;
    std::cout << *(1+&array[0]) << std::endl;
    std::cout << *(1+array) << std::endl;
}
```
実行結果は以下となります。

```cpp
20
20
20
```
`1[array]`は、感覚的にはとても不思議な記述に思えますが先程も述べた通り、これは文法的には全く問題のない記述なのです。ただ、単純にそういった感覚的な意味で分かりにくいので、あまりこのような記述をわざわざする機会はありません。

ところで先ほど、以下のように配列が定義された場合、
```cpp
int main()
{
    int array[10];
}
```
**`array`はその配列の先頭アドレスを指すポインターである**と述べました。ポインターであるのならば、今まで通り、異なるデータのアドレスをポインターに代入する事ができるのでは？と思うかもしれません。
```cpp
int main()
{
    int array[10];
    int a;
    array = &a; // 異なるデータのアドレスを代入
}
```
残念ながら、上記のような事は許されていないのです。単一の変数/オブジェクトに対するポインターの指し示す先を変更する事は一般的に許容されていますが、**配列の先頭アドレスを指し示すポインターに対する変更操作は許容されていません**。

### 7.2.3 配列型とポインター型は異なる
まず、以下のコードを見てください。
```cpp
#include<iostream>
void func(int* ptr)
{
    std::cout<< *(ptr+1) <<std::endl;
}
int main()
{
    int array[]={1,2};
    func(array);
}
```
実行結果は以下となります。
```cpp
2
```
配列の先頭アドレスを関数に渡しています。`int`型の値が確保されるアドレスが渡されますので、関数`f`では`int`型のポインター`ptr`としてそのアドレス値を受け取っています。それに対して+1をする事で、実質的に`array[1]`の値を読み取る事で、`2`と出力されました。では次に以下のコードを見てください。
```cpp
#include<iostream>
void func(int ptr[])
{
    std::cout<< *(ptr+1) <<std::endl;
}
int main()
{
    int array[]={1,2};
    func(array);
}
```
実行結果は以下となります。
```cpp
2
```
これを見て、配列型とポインター型は同じである！というのは、間違いなのです。その訳をサンプルコードと共に見ていきます。

#### externキーワード
以下のコードを見て見ましょう。
```cpp
// a.cpp
int i;
void f(){}
```
```cpp
// b.cpp
int main()
{
	i=10;
	f();
}
```
これをコンパイルしてみましょう。
```cpp
$ g++ a.cpp b.cpp
```
...しかし、コンパイルエラーとなります。何故ならば`b.cpp`内では変数`i`、関数`f`が宣言されていないからです。当然ですね。では、宣言をする事としましょう。
```cpp
// b.cpp
void f();
int i;
int main()
{
	i=10;
	f();
}
```
しかし、これでもコンパイルエラーとなってしまいます。関数`f`はブロックスコープの有無で宣言か定義か明白ですから、これで良さそうです。しかし、変数は宣言が二度された時点で、ODL違反となってしまいます。そう言った時に外部に実態がある事を宣言することのできる、`extern`キーワードを使います。
```cpp
// b.cpp
void f();
extern int i;
int main()
{
	i=10;
	f();
}
```
これで正しくコンパイルされます。さて、ではこれを配列でやってみましょう。尚、配列はポインターで持つ事ができますから以下のようにできるはずです。
```cpp
// a.cpp
#include<iostream>
int array[2];
void access_array();
int main()
{
	array[0]=42;
	array[1]=84;
	access_array();
}
```
```cpp
// b.cpp
#include<iostream>
extern int* array;
void access_array()
{
	std::cout<<array[0]<<" "<<array[1]<<std::endl;
}
```
...残念ながらこれは意図した通りに動きません。しかし、コンパイル、リンクには成功してしまいます。そしてこのコードを実行した場合、不正な処理を行ってしまいます。何故でしょうか？

問題点は明白です。配列で定義したのにも関わらず、ポインタで宣言してしまったからです。コンパイル時には、各ファイルが個別にコンパイル(文法チェック)がされます。文法として、ポインタを配列のように添え字(`[]`)で扱う事が許されているので、どちらのファイルもコンパイルエラーとはなりません。しかし、b.cppでは`array`はポインタ型であると宣言してしまっているがために、`access_array`でアクセスしているように、`array[0]`とすると`42`という**アドレス値**として、`array[1]`とすると`84`という**アドレス値**として認識してしまうのです。よってアドレス`42`、`84`へアクセスしてしまい、不正なアクセスとなるのです。

これは、どのようにすれば解決するのでしょうか？それは簡単です、コンパイラーに配列型であるという事を分からせれば良いのです。つまり、以下のように記述します。
```cpp
// b.cpp
#include<iostream>
extern int array[]; // arrayは配列である
void access_array()
{
	std::cout<<array[0]<<" "<<array[1]<<std::endl;
}
```
ポインターで添え字(`[]`)を使えるので配列とポインターは混同されがちですが、それは単に同じ書き方ができるようになっているだけで、両者は全く別の概念です。

### 7.2.4 多次元配列
配列の配列といったような、多次元配列を使う事もできます。
```cpp
int main()
{
    int array[10][10];
}
```
意味合いとしては、`int`型の要素が10個ある配列が10個ある、といったところでしょうか。それぞれの要素にアクセスするには以下のようにします。
```cpp
int main()
{
    int array[10][10];
    array[5][9]=42;
}
```
5つめの配列の9の要素に対して42という値を代入しています。ポインターを使って多次元配列にアクセスする事も勿論可能です。
```cpp
int main()
{
    int array[10][10]={};
    int** ptr=&array;
}
```

### 7.2.4 文字と文字列、文字配列
# 7.2 配列

「2.4 配列を触ってみる」にて配列には少し触れましたね。ここでは、更に深く配列について触れていきます。まずは配列の特徴を捉えるために、配列を定義してその各要素のアドレスを見てましょう。

```cpp
#include<iostream>
int main()
{
    int array[5];
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
        std::cout<< &array[i] <<std::endl;
}
```
実行結果は例のごとく実行時/実行環境によって左右しますが、ある特徴があるのです。筆者の環境では以下のように出力されました。

```cpp
0x7fff503b8590
0x7fff503b8594
0x7fff503b8598
0x7fff503b859c
0x7fff503b85a0
```
配列`array`のそれぞれの要素のアドレス値が出力されています。この時、アドレスのそれぞれの末尾を見比べて見てください。

```
0x...8590
0x...8594
0x...8598
0x...859c
0x...85a0
```
`90`、`94`、`98`...というように`4`バイトずつそれぞれが領域を使っていてかつ順序良く並んでいる事に気付きましたでしょうか。何故`4`バイトずつなのでしょうか。それは、`int`型だからです。配列の型を、例えば`char`型にしてもう一度見て見ましょう。
```cpp
#include<iostream>
int main()
{
    char array[5];
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
        std::cout<< static_cast<void*>(&array[i]) <<std::endl;
}

```
筆者の環境では以下のように出力されました。

```cpp
0x7fff5cfbb597
0x7fff5cfbb598
0x7fff5cfbb599
0x7fff5cfbb59a
0x7fff5cfbb59b
```
末尾の数値を見てください。`char`型は1バイトの領域を使うためそれぞれの要素が1バイトずつ綺麗に並んでいる事が分かります。このように配列を宣言すると、論理的には、**その要素は必ず順序良く並んでメモリ上に置かれます**。では次に、以下のコードを見て見ましょう。

```cpp
#include<iostream>
int main()
{
    int array[5];
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
        std::cout<< &array[i] <<std::endl;
    std::cout<<"----------------"<<std::endl;
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
        std::cout<< &array[0]+i << std::endl;
}
```
筆者の環境では以下のように出力されました。

```cpp
0x7fff56311590
0x7fff56311594
0x7fff56311598
0x7fff5631159c
0x7fff563115a0
----------------
0x7fff56311590
0x7fff56311594
0x7fff56311598
0x7fff5631159c
0x7fff563115a0
```
上の結果がそれぞれの要素のアドレスです。下は、なんとアドレスに対して変数`i`を加算しています。アドレスに数値を足すと一体どういったことが起きるのでしょうか。

```cpp
int main()
{
    int array[5]={};
    &array[0]+1;
}
```
これは、**`array[0]`のアドレスから`4`バイト分先のアドレスへアクセスする**という意味になるのです。先ほど、配列を宣言すると順序良くそのデータ型サイズ分をあけて並べられると述べました。よって`array[0]`のアドレスに対して`1`を加算することで実際には`array[1]`のデータへアクセスする事ができるのです。つまり`array[数値]`は、`&array[0]+数値`と同じ場所を示しているという事になります。今回は、配列`array`が`int`型の配列であると宣言されているため、`1`を加算すると`array[0]`のアドレスから4バイト分先のアドレスへ進みますが、配列の型が例えば`char`型だった場合、`1`を加算した時に進むバイト数は`1`バイトです。このように、型によって適切に次の要素へ進めるようになっているのです。

```cpp
#include<iostream>
int main()
{
    int array[]={1,2,3,4,5};
    int* ptr = &array[0]+1;
    std::cout<< *ptr <<std::endl;
}
```
実行結果は以下となります。
```cpp
2
```
`array[0]`のアドレスから1要素分(4バイト)進んだ先、つまり`array[1]`のアドレスを`ptr`というポインタに代入しています。それを出力しているのですから、`2`が出力されますね。

### 7.2.1 配列の概念から考えるポインタ型の必要性

そもそも、ここまででポインターの変数型は全て32ビットであれば4バイト、64ビットであれば8バイトであると述べました。「サイズが全て同じであるならポインタの型は何でも良いじゃないか！」と思うかもしれません。しかしそれにはここまでに述べてきた通り、**何型のポインタなのか**を適切に指定しなければ、そのデータの実体の1単位の区切りを適切にコンピュータは知り得る事ができません。またそのような理由から、アドレスに対して`1`を加算した時、その型のバイト数分を進む事ができないのです。(reinterpret_castについては気にしなくても大丈夫です)

```cpp
#include<climits>
#include<iostream>
int main()
{
    int array[]={INT_MAX,42};
    char* ptr=reinterpret_cast<char*>(&array[0]); // int型のデータがある領域のアドレスを強引にchar型のポインターへ代入
    std::cout<< *(ptr+1) << std::endl; // うまく動かない
}
```

このプログラムは、明確な言語規格違反なコードであり、正しく動作しません。`int`型は一つにつき`4`バイトのサイズを使います。よってそのアドレスに+1された場合、`4`バイト分進まなければ次の要素にアクセスする事はできません。しかし、`char`型のポインタ型に強引に代入してアクセスした事で、`1`バイト分のデータを読み取ろうとしてしまいます。また、+1しても進むのは`4`バイト分ではなく、`1`バイトのため、正しくアクセスする事はできないのです。このために、各型に対するポインタ型というものが必要となるのです。

```cpp
#include<iostream>
int main()
{
    int array[]={1,2};
    int* ptr=&array[0]; // int型へのポインターとして宣言、array[0]のアドレスで初期化
    std::cout<< *(ptr+1) << std::endl; // 2が出力される。
}
```
`ptr`の宣言において`int`型のポインターである旨を明示していますから、`ptr+1`では正しく`int`型のデータ量である4バイト分メモリアドレスを進めるため`array[1]`の値`2`が出力されるのです。

この時、実はポインターが指し示す実際のデータの型が何の型であるか明示しないが、とりあえずポインターであるという事だけ宣言するといった方法もあ実は存在します。それは、以下のように、`void*`とする事によって表します。
```cpp
void* ptr;
```
しかし、ここまで話してきた通り、何の型のポインターであるのか分からないので、以下のように実際にポイントするアドレスを指定して、そのポインターから値を読み取ろうとしても、上手く動きません。
```cpp
int main()
{
    int a=10;
    void* ptr=&a;
    *ptr; // 意図した通りには動かない
}
```
では、`void*`として何型の値をもつデータを指すのか指定していないポインターでは、実際の値を読み取る事はできないのでしょうか。いいえ、**キャスト**をする事で実際の値を読み取る事が可能です。
```cpp
int main()
{
    int a=10;
    void* ptr=&a;
    *static_cast<int*>(ptr); // キャスト
}
```
キャストには上記の`static_cast`以外にも様々な種類がありますが、話が脱線してしまいますのでここではまだ解説しません。「第9章 構造体とクラス」で一気に全てのキャストについて説明します。

### 7.2.2 配列とポインタの関係性

以下のように記述すると何が出力されるでしょうか。

```cpp
#include<iostream>
int main()
{
    int array[2];
    std::cout << &array[0] << std::endl;
    std::cout << array << std::endl;
}
```
筆者の環境では以下のように出力されました。

```cpp
0x7fff5daba5a0
0x7fff5daba5a0
```
同じアドレス値が出力されています。何故なら、**`array`は配列の先頭アドレスを指すポインター**だからです。実は、今まで使ってきた`[]`演算子は、`array[添え字]`とあった場合、**`array`ポインターが指すアドレスからどれだけの要素分離れているかを表していた**のです。つまり、`*(array+添え字)`の代替手段のようなものだったとも捉える事ができます。(このようなものをシンタックスシュガーと言ったりします)

よく分からないかもしれませんが、以下のコードをじっくり見て見ると分かりやすいでしょう。
```cpp
#include<iostream>
int main()
{
    int array[]={10,20};
    std::cout << array[1] << std::endl;
    std::cout << *(&array[0]+1) << std::endl;
    std::cout << *(array+1) << std::endl;
}
```
実行結果は以下となります。

```cpp
20
20
20
```
関係性が見えてきましたでしょうか。`array[1]`と`*(array+1)`は全く同じ意味なのです。そして、`*(&array[0]+1)`は、`array[0]`のアドレス、つまり`array`の先頭アドレスから`+1`したアドレスの`*`としていますからその部分の値、つまり`20`が取得できますね。よって意味合いとしては全て同じ事となるのです。

ところで、`*(配列+添え字)`は`*(添え字+配列)`と同じになるでしょうか。当然ながら、同じです。加算の場合、数値を入れ替えてもその演算結果は変わりませんね。では、`配列名[添え字]`は`添え字[配列名]`と同じになるでしょうか。実はこれも、同じになるのです。

```cpp
#include<iostream>
int main()
{
    int array[]={10,20};
    std::cout << 1[array] << std::endl;
    std::cout << *(1+&array[0]) << std::endl;
    std::cout << *(1+array) << std::endl;
}
```
実行結果は以下となります。

```cpp
20
20
20
```
`1[array]`は、感覚的にはとても不思議な記述に思えますが先程も述べた通り、これは文法的には全く問題のない記述なのです。ただ、単純にそういった感覚的な意味で分かりにくいので、あまりこのような記述をわざわざする機会はありません。

ところで先ほど、以下のように配列が定義された場合、
```cpp
int main()
{
    int array[10];
}
```
**`array`はその配列の先頭アドレスを指すポインターである**と述べました。ポインターであるのならば、今まで通り、異なるデータのアドレスをポインターに代入する事ができるのでは？と思うかもしれません。
```cpp
int main()
{
    int array[10];
    int a;
    array = &a; // 異なるデータのアドレスを代入
}
```
残念ながら、上記のような事は許されていないのです。単一の変数/オブジェクトに対するポインターの指し示す先を変更する事は一般的に許容されていますが、**配列の先頭アドレスを指し示すポインターに対する変更操作は許容されていません**。

### 7.2.3 配列型とポインター型は異なる
まず、以下のコードを見てください。
```cpp
#include<iostream>
void func(int* ptr)
{
    std::cout<< *(ptr+1) <<std::endl;
}
int main()
{
    int array[]={1,2};
    func(array);
}
```
実行結果は以下となります。
```cpp
2
```
配列の先頭アドレスを関数に渡しています。`int`型の値が確保されるアドレスが渡されますので、関数`f`では`int`型のポインター`ptr`としてそのアドレス値を受け取っています。それに対して+1をする事で、実質的に`array[1]`の値を読み取る事で、`2`と出力されました。では次に以下のコードを見てください。
```cpp
#include<iostream>
void func(int ptr[])
{
    std::cout<< *(ptr+1) <<std::endl;
}
int main()
{
    int array[]={1,2};
    func(array);
}
```
実行結果は以下となります。
```cpp
2
```
これを見て、配列型とポインター型は同じである！というのは、間違いなのです。その訳をサンプルコードと共に見ていきます。

#### externキーワード
以下のコードを見て見ましょう。
```cpp
// a.cpp
int i;
void f(){}
```
```cpp
// b.cpp
int main()
{
	i=10;
	f();
}
```
これをコンパイルしてみましょう。
```cpp
$ g++ a.cpp b.cpp
```
...しかし、コンパイルエラーとなります。何故ならば`b.cpp`内では変数`i`、関数`f`が宣言されていないからです。当然ですね。では、宣言をする事としましょう。
```cpp
// b.cpp
void f();
int i;
int main()
{
	i=10;
	f();
}
```
しかし、これでもコンパイルエラーとなってしまいます。関数`f`はブロックスコープの有無で宣言か定義か明白ですから、これで良さそうです。しかし、変数は宣言が二度された時点で、ODR違反となってしまいます。そう言った時に単一のオブジェクトとして外部に実態がある事を宣言することのできる、`extern`キーワードを使います。
```cpp
// b.cpp
void f();
extern int i;
int main()
{
	i=10;
	f();
}
```
これで正しくコンパイルされます。さて、ではこれを配列でやってみましょう。尚、配列はポインターで持つ事ができますから以下のようにできるはずです。
```cpp
// a.cpp
#include<iostream>
int array[2];
void access_array();
int main()
{
	array[0]=42;
	array[1]=84;
	access_array();
}
```
```cpp
// b.cpp
#include<iostream>
extern int* array;
void access_array()
{
	std::cout<<array[0]<<" "<<array[1]<<std::endl;
}
```
...残念ながらこれは意図した通りに動きません。しかし、コンパイル、リンクには成功してしまいます。そしてこのコードを実行した場合、不正な処理を行ってしまいます。何故でしょうか？

問題点は明白です。**配列で定義したのにも関わらず、ポインタで宣言してしまったから**です。コンパイル時には、各ファイルが個別にコンパイル(文法チェック)されます。文法として、ポインタを配列のように添え字(`[]`)で扱う事ができますので、どちらのファイルもコンパイルエラーとはなりません。しかし、b.cppでは`array`はポインタ型であると宣言してしまっているがために、`access_array`でアクセスしているように、`array[0]`とすると`42`という**アドレス値**として、`array[1]`とすると`84`という**アドレス値**として認識してしまうのです。よってアドレス`42`、`84`へアクセスしてしまい、不正なアクセスとなるのです。

この問題の解決法は簡単です、コンパイラーに実態が配列であるという事を分からせれば良いのです。つまり、以下のように記述します。
```cpp
// b.cpp
#include<iostream>
extern int array[]; // arrayは配列である
void access_array()
{
	std::cout<<array[0]<<" "<<array[1]<<std::endl;
}
```
ポインターで添え字(`[]`)を使えるので配列とポインターは混同されがちですが、それは単に同じ書き方ができるようになっているだけで、両者は全く別の概念です。

### 7.2.4 多次元配列
配列の配列といったような、多次元配列を使う事もできます。
```cpp
int main()
{
    int array[10][10];
}
```
意味合いとしては、`int`型の要素が10個ある配列が10個ある、といったところでしょうか。それぞれの要素にアクセスするには以下のようにします。
```cpp
int main()
{
    int array[10][10];
    array[5][9]=42;
}
```
5つめの配列の9の要素に対して42という値を代入しています。ポインターを使って多次元配列にアクセスする事も勿論可能です。
```cpp
int main()
{
    int array[10][10]={};
    int** ptr=&array;
}
```


### 7.2.5 文字配列と文字列定数


####文字配列
「2.1 変数とデータ型」で述べたように`char`型は文字を扱う事ができます。
```cpp
char a='a';
```
`char`型は1文字のみ格納する事ができます。では`char`を配列にした場合、どうでしょう。
```cpp
char str[]={'a','b','c','d'};
```
なんと、配列によって`abcd`という**文字列**が再現できてしまいました。しかし、これは文字列としては若干惜しいです。文字列の最後には`¥0`というものが入る事が決まっており文字列の終端を表します。何故文字列の終端を表す必要があるのかは、以下に述べています。よって文字列としての正しい配列定義は
```cpp
char str[]={'a','b','c','d','¥0'};
```
となります。これにより、`abcd`という文字列を扱う事ができます。しかし、実際問題、一々文字ごとに`'`をつけるのはとても楽なものではありません。そこで上の記述は以下のように記述する事ができるようになっています。
```cpp
char str[]="abcd";
```
このようにした場合、`¥0`が見受けられないように見えますが配列`str`の最後の要素には`¥0`が自動的に入る事となります。つまり、指定した文字列の文字数+1の要素が実際には確保される事となります。実際にコードを書いて様子を見て見ましょう。
```cpp
#include<iostream>
int main()
{
	char str[]="hoge";
	std::cout<<str[0]<<" "<<str[1]<<" "<<str[2]<<" "<<str[3]<<" "<<static_cast<int>(str[4])<<std::endl;
	std::cout<<str<<std::endl;

	str[0]='f';
	str[1]='o';
	str[2]='o';
	str[3]='\0';
	std::cout<<str<<std::endl;
}
```
実行結果は以下となります。
```cpp
h o g e 0
hoge
foo
```
"hoge"という文字列を配列の要素にセットしています。それにより配列の要素一つ一つがそれぞれの文字を持っている事が確認できます。そして最後には'¥0'が入っていますね。
その後に標準出力オブジェクト、`std::cout`に対して直接`char`型の配列を指定していますが、正しく文字列が出力されています。これは、`char`型の配列が指定された場合'¥0'までの要素を出力させるような仕組みになっているためです。(これについては、演算子オーバーロードという概念が入ってくるため現時点では詳しくは述べません。)

その仕組みに従うため、その後に配列の一つ一つの要素に対して文字を格納していますが、それらの終端を表すために最後の要素に'¥0'をセットしています。仮に、文字配列の終端に'¥0'をセットしなかった場合どのような動作となるのでしょうか。
```cpp
#include<iostream>
int main()
{
	char str[]="hoge";
	str[4]='a';
	std::cout<<str<<std::endl;
}
```
文字配列の終端に値`'a'`を代入してみる事で'¥0'を上書きしています。筆者の環境では以下のようになってしまいました。
```cpp
hogea??jY?
```
これは、実際のところ未定義動作であり何が起こるか保証されていません。よって基本的には特別な理由もなく必要の無い限り、文字列の最後には'¥0'が必ずあるべきです。

#### 文字配列のコピー、比較、文字数カウント、連結操作
文字配列を**コピー**してみましょう。
```cpp
char str[]="hoge";
char str1[]=str;
```
...というのは、残念ながらうまくいきません。文字配列は単なる`char`型の配列ですから、要素ごとにコピーをしなければならないのです。
```cpp
#include<iostream>
int main()
{
	char str[]="hoge";
	char str1[sizeof(str)/sizeof(str[0])]; // strと同じ分の領域を使う
	for(unsigned int i=0; i<sizeof(str)/sizeof(str[0]); ++i)str1[i]=str[i]; // 一文字ずつコピーする
	std::cout<<str1<<std::endl;
}
```
実行結果は以下となります。
```cpp
hoge
```
折角ですから、文字列のコピー操作を関数化して、操作を明確にしましょう。
```cpp
#include<iostream>
char* strcpy(char* lhs,char* rhs) // 文字列コピーを関数としてまとめる
{
	for(; *rhs!='\0'; ++lhs,++rhs)*lhs=*rhs;
	*lhs='\0';
	return lhs;
}

int main()
{
	char str[]="hoge";
	char str1[sizeof(str)/sizeof(str[0])];
	strcpy(str1,str); // strからstr1へコピーする
	
	char str2[]="This is a array of character";
	char str3[sizeof(str2)/sizeof(str2[0])];
	strcpy(str3,str2); // str2からstr3へコピーする

	std::cout<<str1<<std::endl;
	std::cout<<str3<<std::endl;
}
```
実行結果は以下となります。
```cpp
hoge
This is a array of character
```
`strcpy`関数の仕組みを説明します。まずコピー元とコピー先の二つの`char`型の配列の先頭アドレスを渡します。ループに入り、コピー元の文字列の終端文字(`¥0`)が見つかるまでループをするとしています。そして、ループの度に、コピー元とコピー先のそれぞれの配列の要素を一つずつ進めていきます。そして進める度に文字一つ一つを代入していきます。やがてループを抜けたらコピー先の終端要素に`¥0`を入れておきます。以上で文字列のコピーは完了です。この関数は、実装として**コピー先の配列はコピー元以上の要素数を持つ配列である事を前提としています**。つまり、以下のようにコピー先の要素がコピー元の要素数よりも少なかった場合、確保していない領域までアクセスが進行するためプログラムは不正なものとなりますからそれに関してはしっかりと留意しなければなりません。
```cpp
char str[]="hoge"; // 要素数は5
char str1[1]; // 要素数は1
strcpy(str1,str); // str1の要素数-2分ループが進むため、str1[3]までアクセスしてしまう。不正。
```
また、二つの引数に同じ文字配列を指定した場合、不正なアクセスとなります。
```cpp
char str[]="hoge";
strcpy(str,str); // strcpy内で1回のループで二度インクリメントする事となるため不正。
```
さて、strcpyという文字列をコピーする関数を実装しましたが、この関数は私たちが書く必要はないのです。**標準ライブラリに、予め実装されています**。
```cpp
#include<iostream>
#include<cstring> // std::strcpy
int main()
{
	char str[]="hoge";
	char str1[sizeof(str)/sizeof(str[0])];
	std::strcpy(str1,str); // strからstr1へコピーする
	
	char str2[]="This is a array of character";
	char str3[sizeof(str2)/sizeof(str2[0])];
	std::strcpy(str3,str2); // str2からstr3へコピーする

	std::cout<<str1<<std::endl;
	std::cout<<str3<<std::endl;
}
```
`cstring`ヘッダーをインクルードする事で予め定義された`std`名前空間に属する`strcpy`関数を用いる事ができます。`std::strcpy`関数も先ほど述べたのと同じく、コピー先の配列はコピー元の配列以上の要素数を持っていなければなりません。

次に、コピーの次は文字配列を**比較**してみましょう。
```cpp
char str[]="hoge";
char str1[]="foo";
bool result = (str == str1);
```
...という事も残念ながら期待した通りには動作しません。どちらもただの配列であり、配列名だけの場合は、その配列の先頭アドレスを示すのでしたよね。つまり上記の記述では`str`と`str1`のアドレス値を比較する事となります。実際にしたい事は、文字配列`str`と文字配列`str1`のそれぞれのデータが等しいかを照合したいのです。これも、実はループさせて一つ一つの要素を比較する事で実現します。
```cpp
#include<iostream>

int strcmp(char* lhs,char* rhs)
{
	for(; *lhs==*rhs; ++lhs,++rhs)
		if(*lhs=='\0')return 0;
	return *lhs-*rhs;
}

void output_result(int result)
{
	std::cout<< (result ? (result > 0 ? "Left" : "Right") :"Same") <<std::endl;
}

int main()
{
	char str[]="hoge";
	char str1[]="foo";

	output_result(strcmp(str,str)); // strとstrを比較。以下同じく続く。
	output_result(strcmp(str,str1));
	output_result(strcmp(str1,str));
}
```
実行結果は以下となります。
```cpp
Same
Left
Right
```
まず、`strcmp`の仕様は以下のようになっています。
* 同じ文字列だった場合、値`0`を返す
* 文字列L > 文字列Rだった場合、正数(1以上の正数であれば良い)を返す
* 文字列L < 文字列Rだった場合、負数(-1以下の負数であれば良い)を返す

では`strcmp`の仕組みを解説します。ここでも、比較したい二つの
文字配列を受け取ります。そしてループに入ります。ループの継続条件は互いのそれぞれの要素が等しい場合です。つまり、文字列中に等しく無い文字が現れた瞬間にループから脱出します。もしループ中の要素で終端文字'¥0'が現れた時、それは最後まで文字列と文字列が等しかった事を示しますから、値0を返します。そうでなかった場合、ループを即抜けますので抜けた要素部分で減算を行いその値を返します。ここでの文字列同士の大小関係とは、単に`char`型の文字における整数値の比較と同義です。因みに`output_result`関数は、`strcmp`関数の実行結果をそのまま渡す事で`0`であれば"Same"、正数であれば"Left"、負数であれば"Right"と出力させています。

案の定、`strcmp`関数も標準で用意されています。
```cpp
#include<iostream>
#include<cstring> // std::strcmp

void output_result(int result)
{
	std::cout<< (result ? (result > 0 ? "Left" : "Right") :"Same") <<std::endl;
}

int main()
{
	char str[]="hoge";
	char str1[]="foo";

	output_result(std::strcmp(str,str));
	output_result(std::strcmp(str,str1));
	output_result(std::strcmp(str1,str));
}
```

どんどんいきましょう。次は、**文字列の文字数カウント**をします。
```cpp
#include<iostream>
unsigned int strlen(char* str)
{
	unsigned int counter=0;
	for(; *str++ != '\0'; ++counter);
	return counter;
}

int main()
{
	char str[]="hogefoo";
	std::cout<< strlen(str) <<std::endl; // strの文字数を取得
}
```
実行結果は以下となります。
```cpp
7
```
ごく単純ですね。文字数を取得したい文字配列を指定し、終端文字`¥0`が出現するまで`counter`をインクリメントしそれを返します。

こちらも標準で準備されています。
```cpp
#include<iostream>
#include<cstring>
int main()
{
	char str[]="hogefoo";
	std::cout<< std::strlen(str) <<std::endl;
}
```

最後に、文字列を**連結**しましょう。
```cpp
char str[]="hoge";
char str1[]="foo";
char str2[]=str+str1;
```
...としたいところですが、残念ながらできません。またもや、ループで回して連結する事となります。
```cpp
#include<iostream>
#include<cstring>

char* strcat(char* lhs,char* rhs)
{
	lhs+=std::strlen(lhs);
	for(; *rhs!='\0'; ++rhs,++lhs)*lhs=*rhs;
	*lhs='\0';
	return lhs-std::strlen(lhs);
}

int main()
{
	char str[]="hoge";
	char str1[sizeof(str)/sizeof(str[0])+3]="foo";
	strcat(str1,str); // str1にstrを連結
	std::cout<< str1 <<std::endl;
}
```
実行結果は以下となります。
```cpp
hogefoo
```
まず、連結を適用する文字配列と連結させる文字配列を受け取ります。次に、適用する文字配列の終端文字`¥0`の手前までポインタを進めます。その後、連結させる文字配列の終端文字`¥0`まで適用する文字配列を代入し終端に`¥0`を入れます。`strcat`では連結される文字配列は、自身のサイズ+連結する文字列のサイズ以上のサイズが必要となります。

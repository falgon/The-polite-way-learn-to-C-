## 7.2 配列

「2.4 配列を触ってみる」にて配列には少し触れましたね。ここでは、更に深く配列について触れていきます。まずは配列の特徴を捉えるために、配列を定位してその各要素のアドレスを見てましょう。

```cpp
#include<iostream>
int main()
{
    int array[5];
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
        std::cout<< &array[i] <<std::endl;
}
```
実行結果は例のごとく実行時/実行環境によって左右しますが、ある特徴があるのです。筆者の環境では以下のように出力されました。

```cpp
0x7fff503b8590
0x7fff503b8594
0x7fff503b8598
0x7fff503b859c
0x7fff503b85a0
```
配列`array`のそれぞれの要素のアドレス値が出力されています。この時、アドレスのそれぞれの末尾を見比べて見てください。

```
0x...8590
0x...8594
0x...8598
0x...859c
0x...85a0
```
`90`、`94`、`98`...というように`4`バイトずつそれぞれが領域を使っていてかつ順序良く並んでいる事に気付きましたでしょうか。何故`4`バイトずつなのでしょうか。それは、`int`型だからです。配列の型を、例えば`char`型にしてもう一度見て見ましょう。(`static_cast`については今は気にしなくても大丈夫です)

```cpp
#include<iostream>
int main()
{
    char array[5];
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
        std::cout<< static_cast<void*>(&array[i]) <<std::endl;
}

```
筆者の環境では以下のように出力されました。

```cpp
0x7fff5cfbb597
0x7fff5cfbb598
0x7fff5cfbb599
0x7fff5cfbb59a
0x7fff5cfbb59b
```
末尾の数値を見てください。`char`型は1バイトの領域を使うためそれぞれの要素が1バイトずつ綺麗に並んでいる事が分かります。このように配列を宣言すると、論理的には、**その要素は必ず順序良く並んでメモリ上に置かれます**。では次に、以下のコードを見て見ましょう。

```cpp
#include<iostream>
int main()
{
    int array[5];
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
        std::cout<< &array[i] <<std::endl;
    std::cout<<"----------------"<<std::endl;
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
        std::cout<< &array[0]+i << std::endl;
}
```
筆者の環境では以下のように出力されました。

```cpp
0x7fff56311590
0x7fff56311594
0x7fff56311598
0x7fff5631159c
0x7fff563115a0
----------------
0x7fff56311590
0x7fff56311594
0x7fff56311598
0x7fff5631159c
0x7fff563115a0
```
上の結果がそれぞれの要素のアドレスです。下は、なんとアドレスに対して変数`i`を加算しています。アドレスに数値を足すと一体どういったことが起きるのでしょうか。

```cpp
int main()
{
    int array[5]={};
    &array[0]+1;
}
```
これは、**`array[0]`のアドレスから`4`バイト分先のアドレスへアクセスする**という意味になるのです。先ほど、配列を宣言すると順序良くそのデータ型サイズ分をあけて並べられると述べました。よって`array[0]`のアドレスに対して`1`を加算することで実際には`array[1]`のデータへアクセスする事ができるのです。つまり`array[数値]`は、`&array[0]+数値`と同じ場所を示しているという事になります。今回は、配列`array`が`int`型の配列であると宣言されているため、`1`を加算すると`array[0]`のアドレスから4バイト分先のアドレスへ進みますが、配列の型が例えば`char`型だった場合、`1`を加算した時に進むバイト数は`1`バイトです。このように、型によって適切に次の要素へ進めるようになっているのです。

```cpp
#include<iostream>
int main()
{
    int array[]={1,2,3,4,5};
    int* ptr = &array[0]+1;
    std::cout<< *ptr <<std::endl;
}
```
実行結果は以下となります。
```cpp
2
```
`array[0]`のアドレスから1要素分(4バイト)進んだ先、つまり`array[1]`のアドレスを`ptr`というポインタに代入しています。それを出力しているのですから、`2`が出力されますね。

### 7.2.1 配列の概念から考えるポインタ型の必要性

そもそも、ここまででポインターの変数型は全て32ビットであれば4バイト、64ビットであれば8バイトであると述べました。「サイズが全て同じであるならポインタの型は何でも良いじゃないか！」と思うかもしれません。しかしそれにはここまでに述べてきた通り、**何型のポインタなのか**を適切に指定しなければ、そのデータの実体の1単位の区切りを適切にコンピュータは知り得る事ができません。またそのような理由から、アドレスに対して`1`を加算した時、その型のバイト数分を進む事ができないのです。(reinterpret_castについては気にしなくても大丈夫です)

```cpp
#include<climits>
#include<iostream>
int main()
{
    int array[]={INT_MAX,42};
    char* ptr=reinterpret_cast<char*>(&array[0]); // int型のデータがある領域のアドレスを強引にchar型のポインターへ代入
    std::cout<< *(ptr+1) << std::endl; // うまく動かない
}
```

このプログラムは、正しく動作しません。`int`型は一つにつき`4`バイトのサイズを使います。よってそのアドレスに+1された場合、`4`バイト分進まなければ次の要素にアクセスする事はできません。しかし、`char`型のポインタ型に強引に代入してアクセスした事で、`1`バイト分のデータを読み取ろうとしてしまいます。また、+1しても進むのは`4`バイト分ではなく、`1`バイトのため、正しくアクセスする事はできないのです。このために、各型に対するポインタ型というものが必要となるのです。

```cpp
#include<iostream>
int main()
{
    int array[]={1,2};
    int* ptr=&array[0]; // int型へのポインターとして宣言、array[0]のアドレスで初期化
    std::cout<< *(ptr+1) << std::endl; // 2が出力される。
}
```
`ptr`の宣言において`int`型のポインターである旨を明示していますから、`ptr+1`では正しく`int`型のデータ量である4バイト分メモリアドレスを進めるため`array[1]`の値`2`が出力されるのです。

この時、実はポインターが指し示す実際のデータの型が何の型であるか明示しないが、とりあえずポインターであるという事だけ宣言するといった方法もあ実は存在します。それは、以下のように、`void*`とする事によって表します。
```cpp
*void ptr;
```
しかし、ここまで話してきた通り、何の型のポインターであるのか分からないので、以下のように実際にポイントするアドレスを指定して、そのポインターから値を読み取ろうとしても、上手く動きません。
```cpp
int main()
{
    int a=10;
    void* ptr=&a;
    *ptr; // 意図した通りには動かない
}
```
では、`void*`として何型の値をもつデータを指すのか指定していないポインターでは、実際の値を読み取る事はできないのでしょうか。いいえ、**キャスト**をする事で実際の値を読み取る事が可能です。
```cpp
int main()
{
    int a=10;
    void* ptr=&a;
    *static_cast<int*>(ptr); // キャスト
}
```
キャストは簡単に言えば、型を変換する機能を持ちます。この時、`void*`型で宣言された変数`ptr`を`int*`型に変換しています。指し示している値の型は`int`ですから正しく読み取る事ができるのです。キャストには上記の`static_cast`以外にも様々な種類がありますが、話が脱線してしまいますのでここではまだ解説しません。「第9章 構造体とクラス」で一気に全てのキャストについて説明します。

### 7.2.2 配列とポインタの関係性

以下のように記述すると何が出力されるでしょうか。

```cpp
#include<iostream>
int main()
{
    int array[2];
    std::cout << &array[0] << std::endl;
    std::cout << array << std::endl;
}
```
筆者の環境では以下のように出力されました。

```cpp
0x7fff5daba5a0
0x7fff5daba5a0
```
同じアドレス値が出力されています。何故なら、**`array`は配列の先頭アドレスを指すポインター**だからです。実は、今まで使ってきた`[]`演算子は、`array[添え字]`とあった場合、**`array`ポインターが指すアドレスからどれだけの要素分離れているかを表していた**のです。つまり、`*(array+添え字)`の代替手段のようなものだったとも捉える事ができます。(このようなものをシンタックスシュガーと言ったりします)

よく分からないかもしれませんが、以下のコードをじっくり見て見ると分かりやすいでしょう。
```cpp
#include<iostream>
int main()
{
    int array[]={10,20};
    std::cout << array[1] << std::endl;
    std::cout << *(&array[0]+1) << std::endl;
    std::cout << *(array+1) << std::endl;
}
```
実行結果は以下となります。

```cpp
20
20
20
```
関係性が見えてきましたでしょうか。`array[1]`と`*(array+1)`は全く同じ意味なのです。そして、`*(&array[0]+1)`は、`array[0]`のアドレス、つまり`array`の先頭アドレスから`+1`したアドレスの`*`としていますからその部分の値、つまり`20`が取得できますね。よって意味合いとしては全て同じ事となるのです。

ところで、`*(配列+添え字)`は`*(添え字+配列)`と同じになるでしょうか。当然ながら、同じです。加算の場合、数値を入れ替えてもその演算結果は変わりませんね。では、`配列名[添え字]`は`添え字[配列名]`と同じになるでしょうか。実はこれも、同じになるのです。

```cpp
#include<iostream>
int main()
{
    int array[]={10,20};
    std::cout << 1[array] << std::endl;
    std::cout << *(1+&array[0]) << std::endl;
    std::cout << *(1+array) << std::endl;
}
```
実行結果は以下となります。

```cpp
20
20
20
```
`1[array]`は、感覚的にはとても不思議な記述に思えますが先程も述べた通り、これは文法的には全く問題のない記述なのです。ただ、単純にそういった感覚的な意味で分かりにくいので、あまりこのような記述をわざわざする機会はありません。

ところで先ほど、以下のように配列が定義された場合、
```cpp
int main()
{
    int array[10];
}
```
**`array`はその配列の先頭アドレスを指すポインターである**と述べました。ポインターであるのならば、今まで通り、異なるデータのアドレスをポインターに代入する事ができるのでは？と思うかもしれません。
```cpp
int main()
{
    int array[10];
    int a;
    array = &a; // 異なるデータのアドレスを代入
}
```
残念ながら、上記のような事は許されていないのです。何故ならば、**配列の先頭アドレスを示すポインターと、配列を指し示していないポインターは異なる型**だからです。


### 7.2.4 多次元配列
配列の配列といったような、多次元配列を使う事もできます。
```cpp
int main()
{
    int array[10][10];
}
```
意味合いとしては、`int`型の要素が10個ある配列が10個ある、といったところでしょうか。それぞれの要素にアクセスするには以下のようにします。
```cpp
int main()
{
    int array[10][10];
    array[5][9]=42;
}
```
5つめの配列の9の要素に対して42という値を代入しています。ポインターを使って多次元配列にアクセスする事も勿論可能です。
```cpp
int main()
{
    int array[10][10]={};
    int** ptr=&array;
}
```

### 7.2.4 文字と文字列、文字配列
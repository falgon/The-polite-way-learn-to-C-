# 7.1 ポインター

まず、ポインターとは、単純に英語単語から考えて、どういう意味でしょうか。ポインターはポイント(point)をする者ですね。つまり、ポインター(pointer)とは何かを指し示すものなのです。誰もが使う身近なものから例えると、デスクトップなどにあるショートカットアイコンが良い例です。例えば何かブラウザのショートカットアイコンをダブルクリックすると、そのブラウザが起動しますね。しかしショートカット自体は、アプリケーションの実体ではありません。実体のアプリケーションの居場所を指し示しているのです。当然の事を、何を言っているのだと思うかもしれません。しかし、分からなくなってしまったら、この事を思い出して見てください。少し頭の中で整理できるかもしれませんから。

### 7.1.1 メモリアドレス

「第1章 基礎知識」で触れたように、コンピューターにはメモリーと言われる装置があります。メモリーは1バイト単位で区分けされていて、そのそれぞれに**アドレス**が割り当てられています。**アドレス**は実際には数値です。この章までのサンプルコードで何度も様々な変数や関数などの宣言/定義などを行ってきましたが、それらは全てメモリ上のどこかのアドレスに格納されているのです。これは、「6.2.3 メモリ領域」でも少し触れました。実は、このアドレスを実際に見る事ができるのです。コードは以下となります。

```cpp
#include<iostream>
int main()
{
    int a;
    std::cout<<&a<<std::endl;
}
```
`&`演算子によってアドレスを取得する事ができます。尚、実行結果は実行時/実行環境によって変動します。何故かというと、どこのアドレスへ領域を確保するかはその時々によってCPUが勝手に判断するためです。しかし何やら、よく分からない数値が出力されたと思います。それが、変数`a`が領域確保されたメモリ上のアドレスなのです。ここで、変数`a`がどれぐらいの領域を`&a`で出力されたメモリから使っているのか少し調べて見ましょう。まず、`sizeof`で`int`型のサイズを見て見ます。(int型のサイズは規格によって定められておらず、環境によって変動します。)

```cpp
#include<iostream>
int main()
{
    int a;
    std::cout<<sizeof(a)<<std::endl;
}
```

筆者の環境では以下のように出力されました。

```cpp
4
```
便宜上、ここでは`int`型を4バイトとして話を進めます。先ほどメモリーは1バイト単位で区切られていると述べました。という事はつまり、変数`a`は**論理的には**`&a`で出力された値から4バイト分を使っているという事になりますね。...さて、理解を深めるためにさらに以下のコードを見て見ましょう。`static_cast`については今は気にしなくても大丈夫です。

```cpp
#include<iostream>
int main()
{
    char a;
    double b;
    std::cout<< sizeof(a) <<std::endl;
    std::cout<< sizeof(b) <<std::endl;
    std::cout<< static_cast<void*>(&a) <<std::endl;
    std::cout<< &b <<std::endl;
}
```
筆者の環境では以下のように出力されました。(`char`型は必ず1バイトです。)

```cpp
1
8
0x7fff53a1558f
0x7fff53a15580
```
`char`型は1バイトです。なので、この時変数`a`はアドレス、`0x7fff53a1558f`を使います。`double`型は8バイトと出力されました。なのでこの時、変数`b`は`0x7fff53a15580`から`0x7fff53a15588`までを使うという事になります。今の所はなんとなくメモリをどのように占有するのか、イメージが出来れば大丈夫です。

### 7.1.2 ポインターの基本

変数のアドレスを`&`演算子によって得る事ができました。

```cpp
int main()
{
    int a=42;
    &a; // アドレス取得
}
```
アドレスはつまりその変数の居場所を示しています。という事は、そのアドレスの居場所を目当てに何か操作すれば変数`a`を使わなくても変数`a`の中身を操作できるという事になりますね。やってみましょう。それには、まず変数`a`のアドレスをメモって置いて、そのアドレスに対して操作をすると良いかもしれません。メモるために、アドレスを格納する用の変数があったら便利ですね。それが、C++にはあります。そして、それをポインターを言うのです。

```cpp
int main()
{
    int a=42;
    int* a_ptr=&a; // アドレスをa_ptrに格納。
}
```
`型* 識別子`とする事で、その型のアドレスを格納するポインターと宣言する事ができます。そして、ポインター(この場合、`a_ptr`)が指している(この場合、変数`a`)値を取得するには以下の様に書きます。

```cpp
#include<iostream>
int main()
{
    int a=42;
    int* a_ptr=&a;
    std::cout<< *a_ptr <<std::endl; // *によって値を取得。
}
```
実行結果は以下となります。

```cpp
42
```
`*`演算子をポインターに付与する事で、そのポインター(この場合`a_ptr`)が指している(この場合、変数`a`)値を取得する事ができます。という事は、`a_ptr`は変数`a`のアドレスを挿しているのですから、変数`a`の値を変えた場合、`a_ptr`から取得できる値も変わるという事です。**メモリの同じ場所にあるデータを別のモノから見ようとしているだけ**なのですから、当然ですね。

```cpp
#include<iostream>
int main()
{
    int a=42; // aを42で初期化
    int* a_ptr=&a; // aのアドレスを格納
    std::cout<< *a_ptr <<std::endl; // aのアドレスにある値を見る
    a=50; // aに50を代入
    std::cout<< *a_ptr <<std::endl; // するとaと同じアドレスを見ているのだから50が得られる
}
```
実行結果は以下となります。

```cpp
42
50
```
逆に、ポインターを使って、そのポイントしている場所へ値を代入する事もできます。

```cpp
#include<iostream>
int main()
{
    int a;
    int* a_ptr=&a;
    
    *a_ptr=42; // ポインタを使ってaと同じところに値42を代入
    std::cout<< a <<std::endl;
    *a_ptr=50; // 同じ
    std::cout<< a <<std::endl;
}
```

実行結果は以下となります。

```cpp
42
50
```
実際の値の代入にも`*`演算子を使います。この関係性が分かれば、とても良い調子で理解できていると言えます。ちなみに、以下の様にすると何が出力されるでしょうか。

```cpp
#include<iostream>
int main()
{
    int a=42;
    int* a_ptr=&a;
    std::cout<< a_ptr <<std::endl; // * 演算子がない
}
```
これははたまた実行時/実行環境によって変動します。何故ならばその出力された値というのは、単にそのポインターが指しているアドレスだからです。以下の様にして見て見ましょう。

```cpp
#include<iostream>
int main()
{
    int a=42;
    int* a_ptr=&a;
    std::cout<< &a <<std::endl;
    std::cout<< a_ptr <<std::endl;
}
```
出力される値は実行時/実行環境によって変動します。しかし、全く同じ数値が出力されます。この結果から、変数`a`と変数`a_ptr`が全く同じメモリアドレス領域を使っている事が分かるでしょう。また、以下の様な事もできます。

```cpp
#include<iostream>
int main()
{
    int a=10,b=20,c=30;
    int *ptr=&a; // 変数aと同じ場所を指す。
    
    *ptr=100; // aと同じ場所に対して値100を代入
    std::cout<<a<<std::endl; // 100
    
    ptr=&b; // 指す先を変数aからbへ変更。変数bと同じ場所を指す。
    *ptr=200; // bと同じ場所に対して値200を代入
    
    std::cout<<b<<std::endl; // 200

    ptr=&c; // 指す先を変数bからcへ変更。変数cと同じ場所を指す。
    *ptr=300; // cと同じ場所に対して値300を代入
    std::cout<<c<<std::endl;
}
```

実行結果は以下となります。

```cpp
100
200
300
```

なんと、変数`a`、`b`、`c`を初めにそれぞれ`10`、`20`、`30`として初期化したのに、それぞれの変数に一切直接手をつけずにそれぞれの値を変えてしまいました。ポインターとして宣言されたポインタ変数は、`*`無しで代入する事で指す先のアドレスを変更する事ができます。よって初めに変数`a`のアドレスを持っていたとしてもその後に変数`b`のアドレスを同じポインターにまた代入する事ができるのです。それにより、`ptr`という同じポインタ変数名でありながら、指し示しているアドレスが変わっているのです。そして、`*`演算子を使って実際の値を代入していますから、それぞれの変数の値が変わるのというのはよくよく考えれば当然の事ですね。

### 7.1.3 nullptr

突然ですが、以下に壊滅的なコードを示します。

```cpp
#include<iostream>
int main()
{
    int* ptr;
    std::cout<< *ptr <<std::endl;;
}
```

これをコンパイル、実行してはいけません。ポインタは、何かを指すものです。しかし、このコードでは`ptr`というポインタが何を指すのか示されていません。「4.1.2 不定値」で説明したのと同じ様に、ポインタ変数であっても初期化、代入を行わなかった場合、どんな値が入っているかは規定されていません。つまり、プログラムが使って良いと許可されていない領域のアドレスを示すような値が入っていても、全くおかしくはないのです。C++言語は元々C言語の拡張言語として開発された言語ですが、許可されていないアドレスへのアクセスを行ってしまうというのはC言語時代からあるとても典型的で最も致命的なバグの1つです。これは、絶対的に未然に防がなければなりません。未然に防ぐ手段を考えて見ましょう。問題は、そのポインターが不正なアドレスを持った状態でそのアドレスへ操作を行う事です。では、そのポインターが不正なアドレスを持っているかどうかを確かめ、不正なアドレスでない場合のみ操作を行うとすれば良いのではないでしょうか？実際にやってみましょう。

```cpp
#include<iostream>
int main()
{
    int* ptr=nullptr; // nullptrを入れておく
    if(ptr!=nullptr)std::cout<< *ptr <<std::endl; // ptrはnullptrのままなのでこの一文は実行されない
}
```

`nullptr`は標準規格で予め定められているキーワードです。

一般的に、`null`というワード自体は「空」だとか、「何も初期化されていない」といったニュアンスで使われます。`nullptr`はつまり、「何も初期化されていないポインタ」という意味と捉える事ができます。コードでは、`nullptr`を`int`型のポインター型へ予め代入しています。つまり、`nullptr`は`int`型の数値なのだろうかと考えられるかもしれません。それは実は考え方によっては合っています。ここまでの知識のみだと、`nullptr`自体の仕組みを理解することはできません。ですので今はとにかく、まずは`nullptr`を代入しておく事で、そのポインターが不正なアドレス値を持っていないかどうかを確認する事ができる、と認識してください。`nullptr`の詳細については、「第12章 STLと標準ライブラリ」にて再度取り上げます。
<br>尚、`nullptr`に値`0`を足すと`nullptr`に、`nullptr`から値`0`を引いた場合は`std::ptrdiff_t`型ん値`0`になります。


### 7.1.4 ポインターの利用

ここまでで、ポインターの基本を知ったところで一体この機能は何に使えるんだ？と思ったかもしれません。しかも、不正なアドレスを持ったポインタを誤って使ってしまう可能性もありますからただただリスクがあるだけで何も良いところは無いじゃないかと思うかもしれません。しかし、ポインタの概念を使わなければ出来ない事もあるのです。例題として以下のコードを見て見ましょう。

```cpp
#include<iostream>
void swap(int a,int b)
{
    int tmp=b;
    b=a;
    a=tmp;
}
int main()
{
    int a=10,b=20;
    swap(a,b);
    std::cout<<a<<std::endl<<b<<std::endl;
}
```

変数`a`と変数`b`の値を入れ替える`swap`という関数を定義しました。`a`は`10`、`b`は`20`で初期化しています。実行結果は以下となります。

```cpp
10
20
```
残念ながら意図通りに動いていませんね。しかし、何故でしょうか。コードを見る限りやろうとしている事は正しい様に思えます。これを理解するにはコピーという概念を知らなくてはなりません。



#### コピー

コピーとはどのような意味でしょうか。翻訳するならば「複製」ですね。プログラムの世界では、新しい変数に対して元の変数の**値**を適用した状態を複製と言うのです。まずは以下のコードを見てください。

```cpp
int main()
{
    int x=10;
    int y=x;
}
```
この時、yの値は何でしょうか。`10`です。当然ですね。しかしこの時、xの値は何でしょうか。それは、`10`です。...何を言っているのか分からないかもしれませんが、「コピー」とはこの事を言います。変数`y`に対して変数`x`を代入しています。しかしその後変数`x`が使えなくなるわけではないですよね。何故ならば、複製しているからです。**同じ値を持つ変数を別の領域に確保させているからです。**



#### コピーと仮引数

先ほど、コピーとは同じ値を持つ変数を別の領域に確保していると述べました。関数で以下の様に書いた場合、**関数に渡された変数はコピーされます**。

```cpp
void f(int x) // xはコピーされた変数。main関数の変数aではない。
{
    x;
}
int main()
{
    int a=10;
    f(a);
}
```
ここで冒頭に述べた`swap`関数がうまく動かない理由が理解できたかもしれません。要するに、冒頭で述べた`swap`関数が意図した通りに動かなかった理由は、**コピーされた別の変数同士の値を入れ替えているだけで、渡された変数の値を入れ替えていたわけではなかったから**なのです。

```cpp
#include<iostream>
void swap(int a,int b) // a、bはswap関数内で新たに複製されたコピーであって、決してmain関数内で定義されたaとbではない。
{
    int tmp=b;
    b=a;
    a=tmp;
}
int main()
{
    int a=10,b=20;
    swap(a,b);
    std::cout<<a<<std::endl<<b<<std::endl;
}
```

コピーされた変数の値を変更しても、コピー元は変わりません。当然です。データXがあったとします。Xのバックアップを取っておいて(コピー/複製)、それをYとします。Yに対して何か破壊的な事をしてしまい、Yは壊れてしまいました。その時、Xは壊れているでしょうか。当然ながら、壊れていませんよね。といった単純な事です。それではコピーではなく、変数そのものを渡したい場合はどのようにすれば良いのでしょうか。解決方法の1つとして先ほどから学んできたポインターが使えるのです。

```cpp
#include<iostrem>
void swap(int* a,int* b)
{
    int tmp = *b;
    *b = *a;
    *a = tmp;
}
int main()
{
    int a=10,b=20;
    swap(&a,&b);
    std::cout<<a<<std::endl<<b<<std::endl;
}

```
実行結果は以下となります。
```cpp
20
10
```
このように`swap`関数の仮引数を、アドレスを受け取るように定義しました。変数のアドレスをポインターで受け取って、そのポインタからアドレスへアクセスすれば、変数自体を弄るのと同等になりましたね(「7.1.2 ポインターの基本」)。それを利用して変数をコピーするのではなく、アドレスを渡してそれに対して操作を行う事で、その変数自身の値を操作するのと同等の機能を実現しています。

### 7.1.5 ポインターのポインター

ポインターは、変数に`&`演算子を用いた値を代入する事でその変数と同じ領域を指す事ができました。

```cpp
int main()
{
    int a;
    int* a_ptr = &a;
}
```
ところでポインタとは変数ですね。当たり前の事を言っているように思えるかもしれませんが、もう一度言います、ポインタ自体も任意のアドレスを格納しておける変数です。そして、変数には`&`演算子を使う事でその変数が使う領域のアドレスを取得する事が出来ました。という事はつまり、ポインターに`&`演算子を使った場合はポインターのアドレスを取得できるのでしょうか。やってみましょう。
```cpp
int main()
{
    int a;
    int* ptr = &a;
    int** pptr = &ptr;
}
```

`int**`とする事で`int`型のデータを指すポインターを指すポインターを定義しています。何度も言っていますが、ポインタ自体も変数です。という事はつまりポインタ自体もメモリのどこかに領域を使って格納されているのです。メモリ領域を使っているのであれば、そのアドレスを取得する事は当然ながら可能です。では、ポインタ自体はどれだけの領域を使っているのでしょうか。実際に`sizeof`で見てみましょう。

```cpp
#include<iostream>
int main()
{
    std::cout<<sizeof(int*)<<std::endl<<
    sizeof(char*)<<std::endl<<
    sizeof(double*)<<std::endl<<
    sizeof(float*)<<std::endl<<
    sizeof(bool*)<<std::endl;
}
```
実行結果は、32ビットOSか、64ビットOSかで変動します。筆者の環境(64ビット)では実行結果は以下となりました。

```cpp
8
8
8
8
8
```
32ビットOSであれば全て`4`が出力されるでしょう。このように、ポインターの型によってそのポインターが使うサイズはそれぞれ全く変わりません。どんな型のポインターであっても、32ビットOSであれば`4`バイトであり、64ビットOSであれば`8`バイトの領域を使います。何故でしょうか。よくコンピューターを購入しようと検討している時などに、**32ビットOSではメモリー容量を4GBまでしか読み込めない**と聞いた事はないでしょうか。これはメモリのアドレス1バイトずつ全てに数値を割り当てようとした時、32ビットの容量の数値では4GB領域までしかアドレスを割り当てる/表現する事ができないからです。分かりやすくするため少し例え話を交えて解説します。

#### 環境によって何故ポインター変数の使う領域が変動するのか

「7.1.1 アドレス」でも述べたように、メモリーには全てアドレスという数値が割り当てられています。前提として、**もし割り当てなければ、つまり認識不可能という事になりますので、コンピューターはその領域を作業領域として使う事はできません**。例えば現実的には有りえない話ですが、1ビットOSがあったとします。1ビットで表せるのは、`0`か`1`のみです。(二進数で考える事を想定としています。二進数表記で使える数字は`0`と`1`のみでしたね。何故二進数で考える必要があるのかは、コンピューターの記憶の最小単位に起因しています。「2.2.5 バイト、ビット」などを参照して下さい。)

`0`か`1`の2種類しか使えないので、メモリーには2バイト分(2つ分)のアドレスを割り振る事ができます。よって、このOSが認識できるメモリー容量は2バイトという事になります。この話でメモリを図式化すると、以下のようになります。

| 0 | 1 |
| -- | -- |

次に、2ビットOSがあったとします。2ビットで表せる数値を列挙してみましょう。`00`と`01`と`10`と`11`ですね。つまり、2ビットOSでは4種類のパターンが存在するので4バイト分(4つ分)にアドレスを割り振る事ができます。

| 00 | 01 | 10 | 11 |
| -- | -- | -- | -- |

このように、**1ビットずつ増えるたびに扱える数値は2倍になりますから、その分割り当てられるアドレスの数も2倍になります。**
念のため3ビットOSの場合も考えてみましょうか。ここまで読んできていれば簡単ですね。単に列挙すれば良いだけです。

| 000 | 001 | 010 | 011 | 100 | 101 | 110 | 111 |
| -- | -- | -- | -- | -- | -- | -- | -- |

つまり、8バイト分(8つ分)にアドレスを割り振る事ができますね。これらの事象の法則性を考えましょう。

* 1ビットOS: 2 &#8727; 1

* 2ビットOS: 2 &#8727; 2

* 3ビットOS: 2 &#8727; 2 &#8727; 2 ...

となっていますから、要するにこれは**2の乗数で表す事ができる**と考えられますね。

* $$2^1$$

* $$2^2$$

* $$2^3$$ ...

では、32ビットの場合どうなるでしょうか。数式は以下となりますね。

$$2^{32}$$

これを計算すると、`4294967296`となります。この数値の単位は**バイト**です。順番にギガバイトへ単位を変換していきます。バイトをキロバイトに変換するためには、`1024`で除算すれば良いのです。(これについては慣習的な単語の使われ方と単位に関する正確な規格の狭間を行くかのような事を言っています。つまり、厳密に言うとこの言われ方は正しくないのです。これについては、後述しています。）

$$4294967296/1024$$

この数式では、`4194304`という数値が得られます。これは、単位としてはキロバイトです。それでは次にメガバイトへ変換しましょう。メガバイトへ変換するには更に`1024`で除算します。

$$4194304/1024$$

この数式では`4096`という数値が得られます。単位としてはメガバイトです。それでは最後にギガバイトへ変換しましょう。ギガバイトへ変換するには更に`1024`で除算します。

$$4096/1024$$

この数式では`4`という数値が得られます。単位はギガバイトです。ここで、やっと謎か解けたでしょうか。つまり、冒頭で述べた「**32ビットOSではメモリー容量を4GBまでしか読み込めない**」というのはこういった事情から起因しているのです。よって、ポインターが環境によって変動する理由の結論は、**ポインターの中に入る数値が32ビットで表せるアドレス範囲の数値なのか、64ビットで表せるアドレス範囲の数値なのかに起因している**からなのです。

この結論から、要するにポインター自体がどれだけの領域を有するのかさえ調べてしまえば、(実際のコードではsizeofで調べたように)そのコンピューターに搭載されたOSが何ビットなのか知る事ができるという事ですね。



#### 厳密な単位定義

バイトをキロバイトに変換し、その後メガバイト、ギガバイトへと変換しました。バイト、キロバイト、メガバイト、ギガバイトというのは単位の単語ですね。しかし、この場合、厳密に言うと実は使われ方としては正しくないのです。(国際標準規格 JIS Z8203「国際単位系 (SI) 及びその使い方」より。)

正確には、キロバイトとは**キビバイト**、メガバイトとは**メビバイト**、ギガバイトとは**ギビバイト**の事を示して今までこの単語を用いてきました。それぞれの単位/単語は、`1024`を単位として使う時の、バイト単位に対する上位単位です。

元々、**キロ**という単語は、`1000`を単位として使う単語です。これは、確かに10進数表記が普遍的に使われる社会ではとても使いやすい区切りと言えます。しかし、コンピューターは主に2進数を基準として処理をしますから10進数で言うところの`1000`では、単位としての区切りが悪いのです。そこでコンピューター寄りの単位で考える時、慣習的に$$2^{10}$$(つまり1024)を1単位としてみなして、`1024`バイトを`1`**キロ**バイトとみなすのです。しかしそれだと**キロ**という単位は`1000`と`1024`の異なる数字を表す事になり、10進数と2進数の**キロ**という単位には24の誤差が出てしまう事になるのです。考え方によって異なる意味合いを持つ同じ単語を、厳密な単位の単語として用いるべきではありませんね。そこで標準規格では、既存の各単位に2進数を表わす「バイナリー(binary)」を付けて表す事としました。例えば、$$2^{10}$$(つまり1,024)は、キロバイナリー(Kilobinary、別名：キビ(Kibi))です。

この決まりによって、1000バイトは1キロバイト(1KB)、1024バイトは1キビバイト(1KiB)と区別できるようになりました。

...が、これらの単位は一般には普及しておらず、1000の乗数と1,024の乗数の区別なしに、キロバイト、メガバイト…という単位が用いられているのです。





### 7.1.6 ポインターへのポインターの利用

ここまででポインター自体について詳しく見てきましたが、まだ実際にはそのポインターを使ってはいませんでしたね。使ってみましょう。

```cpp
#include<iostream>
int main()
{
    int a = 42;
    int* a_ptr = &a;
    int** a_pptr = &a_ptr;

    **a_pptr = 100;
    std::cout<< a << std::endl <<
    *a_ptr << std::endl <<
    **a_pptr << std::endl;
}
```
実行結果は以下となります。

```cpp
100
100
100
```

`a`は`42`で初期化されています。そのアドレスを`a_ptr`が指しています。そして`a_ptr`のアドレスを`a_pptr`が指しています。そして、`a_pptr`に対して`*`演算子を2つ使っています。すると、まず、`a_pptr`は`a_ptr`を指していますからそれにアクセスします。そして、`a_ptr`は`a`を指していますのでそこに`100`を代入する事で全ての出力が`100`となります。全て同じメモリーの場所をアクセスしているのですから、当然ですね。それでは、以下のように記述した場合、どのような実行結果が得られでうでしょうか。

```cpp
#include<iostream>
int main()
{
    int a=42;
    int* a_ptr=&a;
    int** a_pptr=&a_ptr;
    
    int b=50;
    *a_pptr=&b;
    std::cout<< a << std::endl <<
    *a_ptr << std::endl <<
    **a_pptr << std::endl;
}
```
実行結果は以下となります。
```cpp
42
50
50
```
`*a_pptr=&b;`の部分で訳がわからなくなるかもしれませんが、順番に考えていけば理解できるはずです。元々、`a_pptr`はポインターへのポインターなのです。ですから、`*`を1つ使った場合に入れる値もアドレスのはずです。そしてそのアドレスは元々、変数`a`を指している`a_ptr`でした。しかし、`*a_pptr`(つまり`a_ptr`)、に変数`b`のアドレスを代入していますので、`*a_ptr`と`**a_pptr`は最終的に変数`b`を辿る事となり、`50`が二度出力されるのです。

### 7.1.7 関数ポインター
なんと、関数のポインターを作る事もできます。関数も、実態としてメモリのどこかに存在しているわけですから、それを示す事ができてもおかしくはないですよね。例えば、以下のように記述します。
```cpp
#include<iostream>
void f()
{
    static int i=1;
    std::cout<<i++<<std::endl;
}
int main()
{
    void (*func_ptr)()=f; // 関数fのアドレスをfunc_ptrポインターに格納
    void (*func_ptr1)()=&f; // 関数fのアドレスをfunc_ptr1ポインターに格納
    func_ptr(); // func_ptrポインターから関数fを呼び出す
    func_ptr1(); // func_ptr1ポインターから関数fを呼び出す
}
```
実行結果は以下となります。
```cpp
1
2
```
アンパサンド(`&`)はつけても付けなくても同じ関数のアドレスを取得する事ができます。しかし、関数ポインタの型宣言部分が少し複雑に見えますね。構文としては、以下のようになっています。
```cpp
関数の戻り型 (*ポインター名)(引数型)
```
例えば、引数のある関数の関数ポインターであれば以下のように記述します。
```cpp
#include<iostream>
int plus(int l,int r)
{
    return l+r;
}
int main()
{
    int (*plus_ptr)(int,int)=plus;
    std::cout<< plus_ptr(10,20) << std::endl;
}
```
実行結果は以下となります。
```cpp
30
```
関係性が見えてきましたでしょうか。因みに、関数ポインターも言ってみればただのポインターですので、関数ポインターのポインターを作る事もできます。
```cpp
#include<iostream>
void f()
{
    static int i=1;
    std::cout<<i++<<std::endl;
}
int main()
{
    void (*f_ptr)()=f; // fのアドレスを格納
    void (**f_pptr)()=&f_ptr; // f_ptrのアドレスを格納
    f_ptr();
    (*f_pptr)();
}
```
実行結果は以下となります。
```cpp
1
2
```
宣言部分を見ると、`*`が増えただけですね。引数付きでも、同様です。
```cpp
#include<iostream>
int plus(int l,int r)
{
    return l+r;
}
int main()
{
    int (*f_ptr)(int,int)=plus;
    int (**f_pptr)(int,int)=&f_ptr;
    int result=f_ptr(10,20),result1=(*f_pptr)(10,20);
    std::cout<<result<<std::endl;
    std::cout<<result1<<std::endl;
}
```
実行結果は以下となります。
```cpp
30
30
```

### 7.1.8 関数ポインターの使い所

ところで関数ポインタは、どのような場面で使えるのでしょうか。関数を単に呼び出すために、関数ポインタへ一々格納する必要もなく直接呼べば良いじゃないかと思うかもしれません。確かに、決まった関数を呼び出すのであれば直接関数を呼ぶべきです。ポインターによる間接的な呼び出しは通常の関数呼び出しよりもさらに遅くなります。しかし、決まった関数呼び出しではないという場合、関数ポインターはとても役立ちます。例えば、以下のように。
```cpp
#include<iostream>
int plus(int l,int r){return l+r;}
int minus(int l,int r){return l-r;}
int multiply(int l,int r){return l*r;}
int division(int l,int r){return r?l/r:r;}

int apply(int l,int r,int (*func_ptr)(int,int))
{
    return func_ptr(l,r);
}

int main()
{
    std::cout<< apply(20,10,plus) <<std::endl;
    std::cout<< apply(20,10,minus) <<std::endl;
    std::cout<< apply(20,10,multiply) <<std::endl;
    std::cout<< apply(20,10,division) <<std::endl;
}
```
実行結果は以下となります。
```cpp
30
10
200
2
```
関数`apply`は、`int`型の値二つと、`int`型を返しかつ`int`型の値二つを引数にとる関数のアドレスを受け取ります。上から順に`plus`、`minus`、`multiply`、`division`を渡し、全てに`20`と`10`を渡していますね。つまりこの呼び出しにより関数`apply`内で渡された関数ポインタを元にそれぞれの関数を呼び出しているのです。そして、それぞれの関数に対して渡された値、`l`、`r`を渡しその結果をそのまま返す事で渡した関数によって処理を変動させる事が可能となります。(関数`division`での条件演算子についての詳細は後述しています)

また関数ポインターを配列に格納する使い方も有用的です。
```cpp
#include<iostream>

int plus(int l,int r){return l+r;}
int minus(int l,int r){return l-r;}
int multiply(int l,int r){return l*r;}
int division(int l,int r){return r ? l/r : r;}
int main()
{
    int (*func_ptr[])(int,int)={plus,minus,multiply,division};
    for(int (*f_ptr)(int,int):func_ptr)
        std::cout<<"result :"<<f_ptr(20,10)<<std::endl;
}
```
実行結果は以下となります。
```cpp
result :30
result :10
result :200
result :2
```
一見すると何だかとても複雑な事をしているように見えなくもないですが、一つ一つ見ていくと、やっている事は単純です。まず、`main`関数の一番初めに、複雑怪奇的な宣言がされているように見えますが、これは**関数ポインターの配列**です。`plus`、`minus`、`multiply`、`division`という関数のアドレスを配列に格納しています。関数ポインターの配列の宣言には、上記の通り、関数ポインター名の後に`[]`が付けられていますね。ここに要素数を明示的に示す事も可能ですが、今回は省略しています。

そして、次に`range-for`ループがきました。ここでは単純に、`func_ptr`という関数ポインターの配列の要素1つ1つをループの度に、`f_ptr`という関数ポインターへコピーする事となります。そして、`f_ptr`に対して`20`と`10`が渡されています。

この時、配列`func_ptr`の要素は関数のアドレスです。それらの要素は`plus`、`minus`、`multiply`、`division`関数です。つまり、これらの関数を順番に呼びその度に`20`と`10`を渡すという処理を行う事になるのです。

その結果、上から順番に、`20+10`、`20-10`、`20*10`、`20/10`の演算結果が出力される事となるのです。

`division`関数だけ、条件演算子が使われていますね。
```cpp
int division(int l,int r){return r ? l/r : r;}
```
これは、ゼロ除算を防ぐための処置です。ゼロ除算とは、`x / 0`というように`0`で何かを割ってしまう事を言います。ゼロ除算の結果は不定/不能ですので、防ぐ必要があります。ゼロ除算が起きる場合というのは変数`r`が`0`である時ですから、その場合にはそのまま`r`を返す事でゼロ除算を防いでいます。

#### ゼロ除算
ゼロ除算とは先ほども述べた通り、$$0$$で何かを割ってしまう事です。プログラミングとは少し関係のない、数学の話になってしまいますが、何故$$0$$除算は不定/不能と言われているのでしょうか。(以下はC++コードではなく数式である事に注意してください。)

##### 不定

要点は以下の二つです。
* まず、仮に $$0/0=x$$ とします。
* また、$$A/B=C$$ は $$C*B=A$$ に書き換える事ができます。

この時、

$$ 0/0=X⇒X*0=0 $$

が成り立つ事となります。つまり、$$X$$には何を入れても式が成立する事となりますね。つまり、$$0/0$$の商は「全ての数」です。これは、**数が定まっていない**と言えます。

##### 不能
不能とは、つまり解がないという事です。例えば$$N$$という数値があったとします。$$N$$は$$0$$以外の数値とします。この時、以下のような式があったとします。

$$ N/0=X $$

ここでは、例として$$N$$は$$5$$だとします。すると、以下のようになります。

1. $$N=5,N/0=X$$

2. $$5/0=X$$

3. $$X*0=5$$

ゼロ乗算の積は0となるはずですが、3ではその法則が破綻してしまっています。つまり$$X$$にはどんな数値を入れても式は成立しません。よって$$N/0$$の商は「解なし」、つまり不能となってしまうのです。

##### ゼロ除算をプログラムで実行すると

実際に実行して見ると、実行時エラーが発生します。

### 7.1.9 ポインターの宣言
ポインターを連続的に宣言する時、以下のように記述したくなるかもしれません。
```cpp
int main()
{
	int a=42;
	int* ptr=&a,ptr1=&a,ptr2=&a;
}
```
しかし、残念ながらこれはコンパイルエラーとなります。何故なら、`ptr`は確かに`int`型のポインターとして宣言できていますが、`ptr1`以降はこの場合、`int`型の変数であるという意味になるのです。ポインターとするには変数名の前に`*`を明記しなければなりません。
```cpp
int main()
{
	int a=42;
	int* ptr=&a,*ptr1=&a,*ptr2=&a;
}
```

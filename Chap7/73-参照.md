# 7.5 参照

関数に何かデータを渡して、その何かを変更したい時、ポインターを使って同じアドレスの部分を操作する事で、関数に渡した先でも変更する事を実現していました。参照は、そのもう一つの方法です。
参照は、リファレンス(reference)とも言います。

## 7.5.1 参照の概念
参照は変数定義の際にアンパサンド(`&`)を付与する事でその意味を成します。
```cpp
int a=10;
int& ref=a; // refはaのリファレンス
```
このように定義して`ref`を操作すると、`a`の値も変更されます。
```cpp
int a=10;
int& ref=a;
ref=42;
a; // aは42
```
リファレンスは、定義時に初期化されなければなりません。よって、以下のように記述する事はできません。
```cpp
int& ref; // refは何かのリファレンス...というようには書けない。
```

## 7.5.2 関数の仮引数で参照を使う
冒頭で述べたような、渡した関数の先での変更操作を実現するためには、関数の引数にリファレンスを用いる事で、ポインターよりも直感的な記述が可能です。
```cpp
#include<iostream>
void f(int& a)
{
    a=10;
}
int main()
{
    int value=42;
    f(value);
    std::cout<<value<<std::endl;
}
```
実行結果は以下となります。
```cpp
10
```
`value`は`42`で初期化されていますが、`value`を関数`f`に対して参照で受け取らせています。その後`f`内で、その引数に対して`10`を代入していますから、`value`の値が変更されます。

## 7.5.3 const参照
参照に対して`const`を付与すると、変更を許さない参照として定義する事ができます。
```cpp
int a=10;
const int& ref=a;
```
ただただこれでは別名を増やしただけでリファレンスの意味がないじゃないか！と思うかもしれません。const参照は関数に渡す時に大いに役立つパターンです。
```cpp
void f(int a){}

int main()
{
    int value=10;
    f(value);
}
```
このように記述すると、関数`f`に渡した段階で`value`のコピーが`a`として新たに生成されます。しかし以下のように
```cpp
void f(const int& a){}
int main()
{
    int value=10;
    f(value);
}
```
参照型を仮引数型に指定する事で関数`f`に`value`を渡しても`a`が新たに`int`型分の領域を確保した変数として定義されるのではなく、`value`に対する参照とだけ定義されるので、コピーでは`int`二つ分の領域を使うのに対し、参照では`int`一つ文の領域しか使いません。ここで、`const`にしているのは、関数`f`内で誤ってデータを変更してしまう可能性を潰すためです。`const`として置く事でもしそのような誤った操作を行ってもコンパイル段階でエラーを吐いて教えてくれます。`const`参照とする事で、無駄なデータのコピーを減らしつつ、そのデータの内容は決して変更しないという、良いとこ取りのような実装を実現する事ができます。このようなオブジェクトを`const lvalue reference`と言ったりします。それについては、7.7 ムーブセマンティックスの章で説明しています。
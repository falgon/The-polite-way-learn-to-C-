# 7.5 参照

関数に何かデータを渡して、その何かを変更したい時、ポインターを使って同じアドレスの部分を操作する事で、関数に渡した先でも変更する事を実現していました。参照は、そのもう一つの方法です。
参照は、リファレンス(reference)とも言います。

## 7.5.1 参照の概念
参照は変数定義の際にアンパサンド(`&`)を付与する事でその意味を成します。
```cpp
int a=10;
int& ref=a; // refはaのリファレンス
```
このように定義して`ref`を操作すると、`a`の値も変更されます。
```cpp
int a=10;
int& ref=a;
ref=42;
a; // aは42
```
リファレンスは、定義時に初期化されなければなりません。よって、以下のように記述する事はできません。
```cpp
int& ref; // refは何かのリファレンス...というようには書けない。
```

## 7.5.2 関数の仮引数で参照を使う
冒頭で述べたような、渡した関数の先での変更操作を実現するためには、関数の引数にリファレンスを用いる事で、ポインターよりも直感的な記述が可能です。
```cpp
#include<iostream>
void f(int& a)
{
    a=10;
}
int main()
{
    int value=42;
    f(value);
    std::cout<<value<<std::endl;
}
```
実行結果は以下となります。
```cpp
10
```
`value`は`42`で初期化されていますが、`value`を関数`f`に対して参照で受け取らせています。その後`f`内で、その引数に対して`10`を代入していますから、`value`の値が変更されます。

## 7.5.3 const参照
参照に対して`const`を付与すると、変更を許さない参照として定義する事ができます。
```cpp
int a=10;
const int& ref=a;
```
ただただこれでは別名を増やしただけでリファレンスの意味がないじゃないか！と思うかもしれません。`const`参照は関数に渡す時に大いに役立つパターンです。
```cpp
void f(int a){}

int main()
{
    int value=10;
    f(value);
}
```
このように記述すると、関数`f`に渡した段階で`value`のコピーが`a`として新たに生成されます。しかし以下のように
```cpp
void f(const int& a){}
int main()
{
    int value=10;
    f(value);
}
```
参照型を仮引数型に指定する事で関数`f`に`value`を渡しても`a`が新たに`int`型分の領域を確保した変数として定義されるのではなく、`value`に対する参照とだけ定義されるので、コピーでは`int`二つ分の領域を使うのに対し、参照では`int`一つ文の領域しか使いません。ここで、`const`にしているのは、関数`f`内で誤ってデータを変更してしまう可能性を潰すためです。`const`として置く事でもしそのような誤った操作を行ってもコンパイル段階でエラーを吐いて教えてくれます。`const`参照とする事で、無駄なデータのコピーを減らしつつ、そのデータの内容は決して変更しないという、良いとこ取りのような実装を実現する事ができます。このようなオブジェクトを`const lvalue reference`と言ったりします。それについては、「7.7 ムーブセマンティックス」の章で説明しています。

## 7.5.4 ローカル変数を参照で返してはならない

参照という機能を使う中で注意しなければならないのが、**変数、オブジェクトの寿命**です。

「5.1 スコープ」でも述べたように、あるスコープ内で生成されたオブジェクトはそのスコープを過ぎると自動的に破棄されます。破棄されたものに対してアクセスする事は、どのような動作を起こすか定められていませんから、絶対にしてはなりません。

この事を頭の片隅に置きながら、ローカル変数を参照で返すとどのような事が起きてしまうか考えてみましょう。
```cpp
int& f()
{
    int a=42;
    return a;
}

int main()
{
    int i=f();
    std::cout<< i <<std::endl; // 何が起こるかわからない
}
```
このコードは、不正な領域へのアクセスを行ってしまう、良く無いコードです。

関数`f`で`a`という`int`型のオブジェクトを定義し、それを返していますが、関数`f`の返却型に注目してください。`int&`というように参照型となっています。**この場合、`return a;`によって返却される`a`はコピーして返却されるのではなく、`a`の参照を返却するのです**。

関数`f`の処理が終了した時には既に関数`f`内の`a`というオブジェクトは破棄されています。破棄されたものを読み取ると(`int i=f();`の部分)、不正なアクセスとなり、何が起こるかはもうわかりませんから、これは良く無いコードです。

もしローカル変数を返したいのであれば、参照を返すのではなくコピーをさせます。
```cpp
int f()
{
    int a=42;
    return a;
}

int main()
{
    int i = f();
    std::cout<< i <<std::endl; // 必ず42と出力される
}
```
関数`f`内のローカル変数で初期化しているように思えるかもしれませんが、そうではなく、戻り型を参照型でない`int`とすることによって、関数`f`が終了して`a`が破棄されても、`a`そのもの新たにコピーして`i`に格納するため、安全な格納となるのです。

この内容は、ポインターを使っても起こり得ます。例えば、ローカル変数を指し示しているポインターを返却すると、そのポインターの指し示した先は破棄される事となるので、何が起こるのかは未定義です。
```cpp
int* f()
{
    int a=42;
    int* p=&a;
    return a;
}

int main()
{
    int i = *(f()); // 未定義
    std::cout << i << std::endl;
}
```

では、参照やポインターを返却するといったシーンは全く無いのでしょうか？いいえ、ローカル変数を返却しないような場合ではそういったケースが好ましいこともあります。例えば以下のように。
```cpp
int& f(int& value)
{
    value+=10;
    return value;
}

int main()
{
    int a = 42;
    int i = f(a);
    std::cout << i << std::endl; // 52
}
```
この場合、関数`f`の引数で`int&`というように、`int`型の参照を引数に受け取っています。つまり、`value`とは、関数`f`の中で生成されたオブジェクトでは無いということです(この場合、`main`関数内の`a`の参照となる)。このような場合、関数`f`の処理が終了し、全ての関数`f`のローカルオブジェクトが破棄されたところで、`value`の参照先は呼び出し元の`main`関数内にあるため無関係です。よって、無駄なコピーもない、安全で効率的なコードと言えるのです。
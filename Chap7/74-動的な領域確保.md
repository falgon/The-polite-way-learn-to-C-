# 7.6 動的な領域管理

今までは変数を使う事で様々なデータの操作をしてきました。そしてそれらのデータは、メモリ上に確保される事で実現されていました。
```cpp
char a; // 1バイト分の領域を確保しその名前はa
```
しかし、よりもっと汎用的、開放的と言いますか、メモリは自由に使う事ができるのです。この項では、動的な領域管理の概念と利用法を説明しますが、まずは、何もとりあえず何も考えずに、以下のプログラムを見て見てください。
```cpp
#include<iostream>
int main()
{
    int* ptr=new int;
    *ptr=10;
    std::cout<<*ptr<<std::endl;
    delete ptr;
}
```
実行結果は以下となります。
```cpp
10
```
何やら、ポインタを`new int`というもので初期化しています。そして次に何とこのポインタを使って`10`を代入しています。その後何やら`ptr`の先を出力させていますが、代入された`10`が出力されています。その後、何やら、`delete`という記述があります。謎だらけですね。

ポインターは「7.1 ポインター」でも述べた通り、示している先が正常に確保された領域でなければ、それに対して操作を行ってはならないはずです。ということは、この`new int`というのはアクセス可能な何らかのアドレスを返すに違いありません。一体これは何者なのでしょうか？

## 7.6.1 new演算子
結論から言うと、**`new`はメモリから領域を確保する演算子**です。しかし、「メモリ領域を確保する」とはどういう事なのでしょうか。

メモリは、様々なプログラムが利用する事となります。例えば、あなたが作ったプログラムAと、他の人が作ったプログラムBを、同時に動かしている場合、メモリ上には少なくとも、あなたの作ったプログラムAと、他の人が作ったプログラムBがそれぞれ使うメモリ領域をそれぞれが必ず確保しています。

という事は当然ながら、あなたが作ったプログラムAのための領域を、他の人が作ったプログラムBが使って良い事はありません。逆も然ります。もしそのような事が許されてしまうと、プログラムAの処理データがプログラムBによって破壊されてしまい、プログラムAは正しく処理する事ができないからです。

よって、メモリ領域は使いたい分を好き勝手に取ってきて使うというわけにはいかないのです。どのアプリケーションも使っていない、未使用の領域を見立てて、他のプログラムと競合が起こらないようにする必要がありますね。そのためには、すべてのプログラムを管理するプログラムに許可を得る必要があります。すべてのプログラムを管理するプログラムとは、OSです。

プログラムが領域確保される段階で、プログラムはOSに対して「これだけメモリを使いたいんですけど...」とOSに頼む事でOSがその旨を把握して希望の領域を確保できるか確認し、出来次第許可します。それを「メモリ領域を確保する」と言います。
例えば、`int`型の領域を新たに確保したければ、以下のように記述します。
```cpp
int* ptr=new int; // 確保できる分の領域があれば確保し、そのアドレスを返す。
```
確保された領域の位置、つまりアドレスは`new`が返してくれます。これをポインタに入れておけば、新たに確保した領域がどこなのか分かるので、その後利用する事ができるのです。希望した領域がメモリ上のどこに確保されるかは、OSが全権を握っているため、こちらで操作する事はできません。しかし逆を言えば、OSが勝手に調節してくれるという事になります。

しかし当然ながら、他のプログラムが既にメモリ領域を確保しきっていたり、指定領域より小さい領域しか元々無ければ、当然ながら領域確保に失敗します。例えば8GBのRAMメモリーが搭載されたマシンで、8GB以上の領域を確保しようとするコードを記述して実行しようとしても、当然ながら実行されません。それはOSが、「メモリ領域が足りない」と感知するためです。

もしそのようにして領域確保に失敗した場合、new演算子は`std::bad_alloc`という例外を投げます。例外は、「第10章 例外処理とattribute」で説明しますので、今はまだ分からなくとも大丈夫です。

## 7.6.2 自動変数と動的確保した領域の違い
ところで今まで用いてきた自動変数は、あらかじめ自動変数用の領域が最初に用意され、そこに順次値を置いていくようになっています。よって、**プログラム起動時に**OSがその分の領域を確保できるか確認します。
```cpp
int main()
{
    char a; // プログラム起動時に1バイト分の領域を確保したいとOSに伝える
}
```
一方、`new`演算子による動的確保は、**プログラムを実行している最中**に新たにメモリを確保したい時に使います。
```cpp
new int;
```
OSからの許可が下りれば、そのメモリを使うことができるようになります。このように領域が確保されるタイミングの他に、確保される場所も異なります。
**自動変数などはスタック領域に確保される**のに対し、**動的に確保されるデータはヒープ領域**に確保されます。(メモリ領域に関する説明は「6.2.3 メモリ領域」を参照してください。)

また、このようにプログラムの実行中にメモリを確保することを「メモリを動的に確保する」と言います。

## 7.6.3 delete演算子
ここまで`new`で動的にメモリ領域を確保できる事を述べました。しかし、この確保したメモリ領域はあくまで「借り物」です。プログラムが終了する前に、その領域を返さなくてはならないのです。

今まで書いてきたプログラムも、この規則を守っています。「5.1 スコープ」でも述べた通り、自動変数は、スコープを外れた瞬間に確保されたデータ領域が自動的に解放されます。
```cpp
int main()
{
    int a; // 領域が確保される
} // スコープから外れるためaの領域は自動的に解放される。
```
しかし、動的に確保した領域はスコープから外れても、解放されません。
```cpp
int main()
{
    int* ptr=new int; // 動的に確保
} // スコープから外れても解放されない。
```
もっと言えば、プログラムが終了しても、解放される保証は一切ないのです。動的確保した領域を解放する仕事は、私たちプログラマーに託されています。

その解放するための演算子が`delete`です。
```cpp
delete アドレス;
```
このように、deleteには確保したメモリのアドレスを指定します。


## 7.6.4 動的確保と実践
さて、では領域を動的確保して少しばかり遊んで見ましょうか。サンプルコードを示していきます。

まずは、以下のコードを見て見ましょう。
```cpp
#include<iostream>
int main()
{
    int* ptr=new int;
    *ptr=10;
    std::cout<<*ptr<<std::endl;
    delete ptr;
}
```
実行結果は以下となります。
```cpp
10
```
これは、お行儀の良い、正しいプログラムです。確保した領域に対して`10`を代入し、その内容を見ていますから、10が出力されました。もうこのデータは使わないので、`delete`でプログラムが終わる前にちゃんと領域を解放しました。

次に以下のコードを見て見ましょう。
```cpp
#include<iostream>
int main()
{
    int* ptr=new int(10);
    std::cout<< *ptr <<std::endl;
    delete ptr;
}
```
実行結果は以下となります。
```cpp
10
```
`new int(10)`という記述がありますね。これは、動的に確保した領域を、値`10`で初期化しろという意味になります。よって、その後の出力も`10`となっています。
このコードを以下のようにしてみるとどうなるでしょうか。
```cpp
#include<iostream>
int main()
{
    int* ptr=new int;
    std::cout<< *ptr <<std::endl;
}
```
この結果は不定です。自動変数の定義と同じく、初期化も代入もされていない領域は不定となります。

では、次のコードを見て見ましょう。
```cpp
int main()
{
    int* ptr=new int;
    int a;
    
    ptr=&a;
    delete ptr;
}
```
このコードは正しく動きません。何をしてしまっているのか、順を追って見て見ましょう。
まず、`ptr`を、動的確保した領域のアドレスとして初期化しています。その後、それとは特に関係なく`a`という自動変数を定義しています。問題はその後の処理です。`new int`で確保した領域のアドレスを持っていたポインター`ptr`の指し示す先を、先ほど定義した`a`の領域に変更してしまいました。この部分で`new int`で確保された領域にはもう二度とアクセスする事ができなくなってしまったのです。`a`のアドレスで上書きしてしまっているので当然の動作を言えるでしょう。その後、`ptr`を`delete`していますが、その`ptr`に入ったアドレスは変数`a`のアドレスなので、自動的に破棄される自動変数を`delete`演算子で解放する事は許されないためどのような動作が起こるかは未定義です。また、解放する術を失ってしまった`new int`で確保された領域は、この先解放される事なく、二度と使えない領域となってしまうかもしれません。このように解放を忘れてしまう事を**メモリリーク**と言います。メモリリークはプログラマーが書いてはならない絶対的な要項の一つで、製品の品質を左右する事ともなります。**メモリリークは絶対に起こしてはならない**という事を肝に命じておかなければなりません。

ところで先ほどのメモリリークのコード例では、別のアドレスに書き換えてしまったがために、領域の解放する手段を失ってしまったのでした。この問題を避けるためには、ポインターの指し示す先を`const`としてしまう事がとても手っ取り早い解決法です。
```cpp
int main()
{
	int* const ptr=new int(0);
	int a;

	ptr=&a; // 示す先の変更を許さない。エラー！
	delete ptr;
}
```
指し示す先を固定する事で、動的確保された領域を指し示すポインターが無くなってしまう事を防ぐ事ができますね。

## 7.6.5 配列の動的確保
ここまでは、単一のオブジェクトを動的に確保しました。動的な領域確保は単一オブジェクトの他に複数の領域(配列)を確保する事が可能です。
規格では、配列の定義時に、要素数を動的に指定する事は禁止しています(一部のコンパイラの独自拡張ではこの機能を実装している)。指定する要素数は定数でなければなりません。
```cpp
int a=10;
int array[a]; // 禁止
```
よって、配列の要素数が実行時まで分からないというようであれば、動的に配列の領域を確保しなければなりません。配列の動的確保は以下のようにします。
```cpp
int* ptr=new int[10];
```
動的確保では、要素数を動的に指定する事ができます。
```cpp
int a=10:
int* ptr=new int[a];
```
初期化を行う場合は、以下のようにします。
```cpp
int* ptr=new int[10]{42,53}; // ptr[0]を42、ptr[1]を53で初期化
```
この場合、動的確保でない配列と同じように、一つ目の要素の値が`42`、二つ目の要素の値が`53`として初期化され、後の要素の値は0に初期化されます。全てを0で初期化したい場合は、これまた動的確保でない配列と同じように、以下のように記述します。
```cpp
int* ptr=new int[10]{}; // 要素を全て0で初期化
```
また配列でも同じく、使い終わったら動的に確保したものは自分で解放しなければなりません。動的に確保した配列の領域を解放するには、`delete`の後に`[]`を記述します。
```cpp
delete[] ptr;
```
こうする事で正しく削除が行えます。

さて、では実際に使って見ましょう。
```cpp

```
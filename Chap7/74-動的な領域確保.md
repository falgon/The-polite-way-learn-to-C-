# 7.6 動的な領域管理

今までは変数を使う事で様々なデータの操作をしてきました。そしてそれらのデータは、メモリ上に確保される事で実現されていました。
```cpp
char a; // 1バイト分の領域を確保しその名前はa
```
しかし、よりもっと汎用的、開放的と言いますか、メモリは自由に使う事ができるのです。この項では、動的な領域管理の概念と利用法を説明しますが、まずは、何もとりあえず何も考えずに、以下のプログラムを見て見てください。
```cpp
#include<iostream>
int main()
{
    int* ptr=new int;
    *ptr=10;
    std::cout<<*ptr<<std::endl;
    delete ptr;
}
```
実行結果は以下となります。
```cpp
10
```
何やら、ポインタを`new int`というもので初期化しています。そして次に何とこのポインタを使って`10`を代入しています。その後何やら`ptr`の先を出力させていますが、代入された`10`が出力されています。その後、何やら、`delete`という記述があります。謎だらけですね。

ポインターは「7.1 ポインター」でも述べた通り、示している先が正常に確保された領域でなければ、それに対して操作を行ってはならないはずです。ということは、この`new int`というのはアクセス可能な何らかのアドレスを返すに違いありません。一体これは何者なのでしょうか？

## 7.6.1 new演算子
結論から言うと、**`new`はメモリから領域を確保する演算子**です。しかし、「メモリ領域を確保する」とはどういう事なのでしょうか。

メモリは、様々なプログラムが利用する事となります。例えば、あなたが作ったプログラムAと、他の人が作ったプログラムBを、同時に動かしている場合、メモリ上には少なくとも、あなたの作ったプログラムAと、他の人が作ったプログラムBがそれぞれ使うメモリ領域をそれぞれが必ず確保しています。

という事は当然ながら、あなたが作ったプログラムAのための領域を、他の人が作ったプログラムBが使って良い事はありません。逆も然ります。もしそのような事が許されてしまうと、プログラムAの処理データがプログラムBによって破壊されてしまい、プログラムAは正しく処理する事ができないからです。

よって、メモリ領域は好き勝手に使いたい分を勝手に取ってきて使うというわけにはいかない事になります。どのアプリケーションも使っていない、未使用の領域を見立てて、他のプログラムと競合が起こらないようにする必要がありますね。そのためには、すべてのプログラムを管理するプログラムに許可を得る必要があります。すべてのプログラムを管理するプログラムとは、OSです。

プログラムが領域確保される段階で、プログラムはOSに対して「これだけメモリを使いたいんですけど...」とOSに頼む事で希望の領域を確保する事ができます。それを「メモリ領域を確保する」と言います。
例えば、`int`型の領域を新たに確保したければ、以下のように記述します。
```cpp
int* ptr=new int; // 確保できる分の領域があれば確保し、そのアドレスを返す。
```
確保された領域の位置、つまりアドレスは`new`が返してくれます。これをポインタに入れておけば、新たに確保した領域がどこなのか分かるので、その後利用する事ができるのです。メモリ上のどこに希望した領域を確保するかは、OSが全権を握っているため、こちらで操作する事はできません。しかし逆を言えば、OSが勝手に調節してくれるという事になります。

しかし当然ながら、他のプログラムが既にメモリ領域を確保しきっていたり、指定領域より小さい領域しかもともと無ければ、当然ながら領域確保には失敗します。例えば8GBのRAMメモリーが搭載されたマシンで、8GB以上の領域を確保しようとするコードを記述して実行しようとしても、当然ながら実行されません。それはOSが、「メモリ領域が足りない」と感知するためです。

もし領域確保に失敗した場合、new演算子は`std::bad_alloc`という例外を投げます。例外は、「第10章 例外処理とattribute」で説明しますので、今はまだ分からなくとも大丈夫です。

## 7.6.2 自動変数と動的確保した領域の違い
ところで今まで用いてきた自動変数は、あらかじめ自動変数用の領域が最初に用意され、そこに順次値を置いていくようになっています。つまり、**プログラム起動時に**OSにその分の領域を確保できるか確認させるわけです。
```cpp
int main()
{
    char a; // プログラム起動時に1バイト分の領域を確保したいとOSに伝える
}
```
一方`new`演算子というのは、**プログラムを実行している最中**に新たにメモリを確保したい時に使います。
```cpp
new int;
```
OSからの許可が下りれば、そのメモリを使うことができるようになります。このように、プログラムの実行中にメモリを確保することを「メモリを動的に確保する」と言います。

## 7.6.3 delete演算子
ここまで`new`で新たにメモリ領域を確保できる事を述べました。しかし、この確保したメモリ領域はあくまで「借り物」です。プログラムが終了する前に、その領域を返さなくてはならないのです。

今まで書いてきたプログラムも、この規則を守っています。「5.1 スコープ」でも述べた通り、自動変数は、スコープを外れた瞬間に確保されたデータ領域が自動的に解放されます。
```cpp
int main()
{
    int a; // 領域が確保される
} // スコープから外れるためaの領域は自動的に解放される。
```
しかし、動的に確保した領域はスコープから外れても、解放されません。
```cpp
int main()
{
    int* ptr=new int; // 動的に確保
} // スコープから外れても解放されない。
```
もっと言えば、プログラムが終了しても、解放される事はないのです。動的確保した領域を解放する仕事は、私たちプログラマーに託されています。

そのための演算子が`delete`です。
```cpp
delete アドレス;
```
このように、deleteには確保したメモリのアドレスを指定します。


## 7.6.3 動的確保と実践
さて、では領域を動的確保して少しばかり遊んで見ましょうか。
```cpp
#include<iostream>
int main()
{
    int *ptr=new int;
    *ptr=10;
    std::cout<<*ptr<<std::endl;
    delete ptr;
}
```
実行結果は以下となります。
```cpp
10
```

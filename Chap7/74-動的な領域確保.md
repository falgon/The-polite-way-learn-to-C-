# 7.6 動的な領域管理

今までは変数を使う事で様々なデータの操作をしてきました。そしてそれらのデータは、メモリ上に確保される事で実現されていました。
```cpp
char a; // 1バイト分の領域を確保しその名前はa
```
しかし、よりもっと汎用的、開放的と言いますか、メモリは自由に使う事ができるのです。この項では、動的な領域管理の概念と利用法を説明しますが、まずは、何もとりあえず何も考えずに、以下のプログラムを見て見てください。
```cpp
#include<iostream>
int main()
{
    int* ptr=new int;
    *ptr=10;
    std::cout<<*ptr<<std::endl;
    delete ptr;
}
```
実行結果は以下となります。
```cpp
10
```
何やら、ポインタを`new int`というもので初期化しています。そして次に何とこのポインタを使って`10`を代入しています。その後何やら`ptr`の先を出力させていますが、代入された`10`が出力されています。その後、何やら、`delete`という記述があります。謎だらけですね。

ポインターは「7.1 ポインター」でも述べた通り、示している先が正常に確保された領域でなければ、それに対して操作を行ってはならないはずです。ということは、この`new int`というのはアクセス可能な何らかのアドレスを返すに違いありません。一体これは何者なのでしょうか？

## 7.6.1 new演算子
結論から言うと、**`new`はメモリを確保する演算子**です。しかし、「メモリを確保する」とはどういう事なのでしょうか。

メモリは、様々なプログラムが利用する事となります。例えば、あなたが作ったプログラムAと、他の人が作ったプログラムBを、同時に動かしている場合、メモリ上には少なくとも、あなたの作ったプログラムAと、他の人が作ったプログラムBがそれぞれ使うメモリ領域をそれぞれが必ず確保しています。

という事は当然ながら、あなたが作ったプログラムAのための領域を、他の人が作ったプログラムBが使って良い事はありません。逆も然ります。もしそのような事が許されてしまうと、プログラムAの処理データがプログラムBによって破壊されてしまい、プログラムAは正しく処理する事ができないからです。

よってメモリ領域は好き勝手に使いたい分を勝手に取ってきて使うというわけでにもいかないのです。どのアプリケーションも使っていない、未使用の領域を見立てて、他のプログラムと競合が起こらないようにする必要があります。そのためには、すべてのプログラムを管理するプログラムに許可を得る必要があります。すべてのプログラムを管理するプログラムとは、OSです。

ですから、プログラムが領域確保される段階で、プログラムはOSに対して「これだけメモリを使いたいんですけど...」とOSに頼みます。それが「メモリ領域を確保する」という事です。

メモリ上のどこに希望した領域を確保するかはOSが全権を握っているため、こちらで操作する事はできませんが、逆を言えば、OSが勝手に調節してくれるという事になります。

関数や静的変数は、プログラムをメモリ上にロードするときにOSがそれらの領域を確認します。よって、例えば8GBのRAMメモリーが搭載されたマシンで8GB以上の領域を確保しようとするコードを記述して実行しようとしても、当然ながら実行されません。それはOSが、「メモリ領域が足りない」と感知するためです。

今まで用いてきた自動変数は、あらかじめ自動変数用の領域が最初に用意され、そこに順次値を置いていくようになっています。つまり、これもプログラムをメモリ上にロードする時にOSが確認するわけです。
```cpp
int main()
{
    char a; // プログラム起動時に1バイト分の領域を確保したいとOSに伝える
}
```
一方`new`演算子というのは、プログラムを実行している最中に新たにメモリを確保したいときに使います。
```cpp
new int;
```
OSが「使っていいよ」と言ってくれれば、そのメモリを使うことができるようになります。このように、プログラムの実行中にメモリを確保することを「メモリを動的に確保する」と言うのです。
確保されたメモリの位置、つまりアドレスは`new`が返してくれます。これをポインタに入れておけば、新たに確保したメモリを使えるようになるという事です。

この`new`で確保できるメモリのある領域の事をフリーストア（またはヒープ）と呼びます。

## 7.6.2 delete演算子
ここまで`new`で新たにメモリ領域を確保できる事を述べました。しかし、この確保したメモリ領域はあくまで「借り物」です。プログラムが終了する前に、その領域を返さなくてはならないのです。

今まで書いてきたプログラムも、この規則を守っています。今まで確保したきた領域は、自動変数です。自動変数は、スコープを外れた瞬間に確保されたデータ領域が自動的に解放されます。
```cpp
int main()
{
    int a; // 領域が確保される
} // スコープから外れるためaの領域は自動的に解放される。
```
しかし、動的に確保した領域はスコープから外れても、開放されないのです。
```cpp
int main()
{
    int* ptr=new int; // 動的に確保
} // スコープから外れても解放されない。
```

このように、借りたメモリ領域をOSに返す事を、「メモリを解放する」と呼びます。
そのメモリを解放するための演算子が`delete`です。
```cpp
delete アドレス;
```
このように、deleteには確保したメモリのアドレスを指定します。`delete`によりメモリが解放されて、プログラムをようやく正しく終わらせることができるのです。


## 7.6.3 動的確保と実践
さて、では領域を動的確保して少しばかり遊んで見ましょうか。
```cpp
#include<iostream>
int main()
{
    int *ptr=new int;
    *ptr=10;
    std::cout<<*ptr<<std::endl;
    delete ptr;
}
```
実行結果は以下となります。
```cpp
10
```

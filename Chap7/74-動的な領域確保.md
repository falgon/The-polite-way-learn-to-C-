# 7.6 動的な領域管理

今までは変数を使う事で様々なデータの操作をしてきました。そしてそれらのデータは、メモリ上に確保される事で実現されていました。

```cpp
char a; // 1バイト分の領域を確保しその名前はa
```

しかし、メモリはよりもっと自由に使う事ができるのです。この項では、動的な領域管理の概念と利用法を説明しますが、まずは何も考えずに、以下のプログラムを見て見てください。

```cpp
#include<iostream>
int main()
{
    int* ptr=new int;
    *ptr=10;
    std::cout<<*ptr<<std::endl;
    delete ptr;
}
```

実行結果は以下となります。

```cpp
10
```

何やら、ポインタを`new int`というもので初期化しています。そして次に何とこのポインタを使って`10`を代入しています。その後何やら`ptr`の先を出力させていますが、代入された`10`が出力されています。その後、何やら、`delete`という記述があります。謎だらけですね。

ポインターは「7.1 ポインター」でも述べた通り、示している先が正常に確保された領域でなければ、それに対して操作を行ってはならないはずです。ということは、この`new int`というのはアクセス可能な何らかのアドレスを返すに違いありません。一体これは何者なのでしょうか？

## 7.6.1 new演算子

結論から言うと、`new`**はメモリから領域を確保する演算子**です。しかし、「メモリ領域を確保する」とはどういう事なのでしょうか。

メモリは、様々なプログラムが利用する事となります。例えば、あなたが作ったプログラムAと、他の人が作ったプログラムBを、同時に動かしている場合、メモリ上には少なくとも、あなたの作ったプログラムAと、他の人が作ったプログラムBがそれぞれ使うメモリ領域をそれぞれが必ず確保しています。

という事は当然ながら、あなたが作ったプログラムAのための領域を、他の人が作ったプログラムBが使って良い事はありません。逆も然ります。もしそのような事が許されてしまうと、プログラムAの処理データがプログラムBによって破壊されてしまい、プログラムAは正しく処理する事ができないからです。

よって、メモリ領域は使いたい分を好き勝手に取ってきて使うというわけにはいかないのです。どのアプリケーションも使っていない、未使用の領域を見立てて、他のプログラムと競合が起こらないようにする必要がありますね。そのためには、すべてのプログラムを管理するプログラムに許可を得る必要があります。すべてのプログラムを管理するプログラムとは、OSです。

プログラムが領域確保される段階で、プログラムはOSに対して「これだけメモリを使いたいんですけど...」とOSに頼む事でOSがその旨を把握して希望の領域を確保できるか確認し、出来次第許可します。それを「メモリ領域を確保する」と言います。  
例えば、`int`型の領域を新たに確保したければ、以下のように記述します。

```cpp
int* ptr=new int; // 確保できる分の領域があれば確保し、そのアドレスを返す。
```

確保された領域の位置、つまりアドレスは`new`が返してくれます。これをポインタに入れておけば、新たに確保した領域がどこなのか分かるので、その後利用する事ができるのです。希望した領域がメモリ上のどこに確保されるかは、OSが全権を握っているため、こちらで操作する事はできません。しかし逆を言えば、OSが勝手に調節してくれるという事になります。

しかし当然ながら、他のプログラムが既にメモリ領域を確保しきっていたり、指定領域より小さい領域しか元々無ければ、当然ながら領域確保に失敗します。例えば8GBのRAMメモリーが搭載されたマシンで、8GB以上の領域を確保しようとするコードを記述して実行しようとしても、当然ながら実行されません。それはOSが、「メモリ領域が足りない」と感知するためです。

もしそのようにして領域確保に失敗した場合、new演算子は`std::bad_alloc`という例外を投げます。例外は、「第10章 例外処理とattribute」で説明しますので、今はまだ分からなくとも大丈夫です。

## 7.6.2 自動変数と動的確保した領域の違い

ところで今まで用いてきた自動変数は、あらかじめ自動変数用の領域が最初に用意され、そこに順次値を置いていくようになっています。よって、**プログラム起動時に**OSがその分の領域を確保できるか確認します。

```cpp
int main()
{
    char a; // プログラム起動時に1バイト分の領域を確保したいとOSに伝える
}
```

一方、`new`演算子による動的確保は、**プログラムを実行している最中**に新たにメモリを確保したい時に使います。

```cpp
new int;
```

OSからの許可が下りれば、そのメモリを使うことができるようになります。このように領域が確保されるタイミングの他に、確保される場所も異なります。  
**自動変数などはスタック領域に確保される**のに対し、**動的に確保されるデータはヒープ領域**に確保されます。\(メモリ領域に関する説明は「6.2.3 メモリ領域」を参照してください。\)

また、このようにプログラムの実行中にメモリを確保することを「メモリを動的に確保する」と言います。

## 7.6.3 delete演算子

ここまで`new`で動的にメモリ領域を確保できる事を述べました。しかし、この確保したメモリ領域はあくまで「借り物」です。プログラムが終了する前に、その領域を返さなくてはならないのです。

今まで書いてきたプログラムも、この規則を守っています。「5.1 スコープ」でも述べた通り、自動変数は、スコープを外れた瞬間に確保されたデータ領域が自動的に解放されます。

```cpp
int main()
{
    int a; // 領域が確保される
} // スコープから外れるためaの領域は自動的に解放される。
```

しかし、動的に確保した領域はスコープから外れても、解放されません。

```cpp
int main()
{
    int* ptr=new int; // 動的に確保
} // スコープから外れても解放されない。
```

もっと言えば、プログラムが終了しても、解放される保証は一切ないのです。動的確保した領域を解放する仕事は、私たちプログラマーに託されています。

その解放するための演算子が`delete`です。

```cpp
delete アドレス;
```

このように、deleteには確保したメモリのアドレスを指定します。

## 7.6.4 動的確保と実践

さて、では領域を動的確保して少しばかり遊んで見ましょう。サンプルコードを示していきます。

まずは、以下のコードを見て見ましょう。

```cpp
#include<iostream>
int main()
{
    int* ptr=new int;
    *ptr=10;
    std::cout<<*ptr<<std::endl;
    delete ptr;
}
```

実行結果は以下となります。

```cpp
10
```

これは、お行儀の良い、正しいプログラムです。確保した領域に対して`10`を代入し、その内容を見ていますから、10が出力されました。もうこのデータは使わないので、`delete`でプログラムが終わる前にちゃんと領域を解放しました。

次に以下のコードを見て見ましょう。

```cpp
#include<iostream>
int main()
{
    int* ptr=new int(10);
    std::cout<< *ptr <<std::endl;
    delete ptr;
}
```

実行結果は以下となります。

```cpp
10
```

`new int(10)`という記述がありますね。これは、動的に確保した領域を、値`10`で初期化しろという意味になります。よって、その後の出力も`10`となっています。  
このコードを以下のようにしてみるとどうなるでしょうか。

```cpp
#include<iostream>
int main()
{
    int* ptr=new int;
    std::cout<< *ptr <<std::endl;
}
```

この結果は不定です。自動変数の定義と同じく、初期化も代入もされていない領域は不定となります。

では、次のコードを見て見ましょう。

```cpp
int main()
{
    int* ptr=new int;
    int a;

    ptr=&a;
    delete ptr;
}
```

このコードは正しく動きません。何をしてしまっているのか、順を追って見て見ましょう。  
まず、`ptr`を、動的確保した領域のアドレスとして初期化しています。その後、それとは特に関係なく`a`という自動変数を定義しています。問題はその後の処理です。`new int`で確保した領域のアドレスを持っていたポインター`ptr`の指し示す先を、先ほど定義した`a`の領域に変更してしまいました。この部分で`new int`で確保された領域にはもう二度とアクセスする事ができなくなってしまったのです。`a`のアドレスで上書きしてしまっているので当然の動作を言えるでしょう。その後、`ptr`を`delete`していますが、その`ptr`に入ったアドレスは変数`a`のアドレスなので、自動的に破棄される自動変数を`delete`演算子で解放する事は許されないためどのような動作が起こるかは未定義です。また、解放する術を失ってしまった`new int`で確保された領域は、この先解放される事なく、二度と使えない領域となってしまうかもしれません。このように解放を忘れてしまう事を**メモリリーク**と言います。メモリリークはプログラマーが書いてはならない絶対的な要項の一つで、製品の品質を左右する事ともなります。**メモリリークは絶対に起こしてはならない**という事を肝に命じておかなければなりません。

ところで先ほどのメモリリークのコード例では、別のアドレスに書き換えてしまったがために、領域の解放する手段を失ってしまったのでした。この問題を避けるためには、ポインターの指し示す先を`const`としてしまう事がとても手っ取り早い解決法です。

```cpp
int main()
{
    int* const ptr=new int(0);
    int a;

    ptr=&a; // 示す先の変更を許さない。エラー！
    delete ptr;
}
```

指し示す先を固定する事で、動的確保された領域を指し示すポインターが無くなってしまう事を防ぐ事ができますね。

## 7.6.5 配列の動的確保

ここまでは、単一のオブジェクトを動的に確保しました。動的な領域確保は単一オブジェクトの他に複数の領域\(配列\)を確保する事が可能です。  
規格では、配列の定義時に、要素数を動的に指定する事は禁止しています\(一部のコンパイラの独自拡張ではこの機能を実装している\)。指定する要素数は定数でなければなりません。

```cpp
int a=10;
int array[a]; // 禁止
```

よって、配列の要素数が実行時まで分からないというようであれば、動的に配列の領域を確保しなければなりません。配列の動的確保は以下のようにします。

```cpp
int* ptr=new int[10];
```

動的確保では、要素数を動的に指定する事ができます。

```cpp
int a=10:
int* ptr=new int[a];
```

初期化を行う場合は、以下のようにします。

```cpp
int* ptr=new int[10]{42,53}; // ptr[0]を42、ptr[1]を53で初期化
```

この場合、動的確保でない配列と同じように、一つ目の要素の値が`42`、二つ目の要素の値が`53`として初期化され、後の要素の値は0に初期化されます。全てを0で初期化したい場合は、これまた動的確保でない配列と同じように、以下のように記述します。

```cpp
int* ptr=new int[10]{}; // 要素を全て0で初期化
```

また配列でも同じく、使い終わったら動的に確保したものは自分で解放しなければなりません。動的に確保した配列の領域を解放するには、`delete`の後に`[]`を記述します。

```cpp
delete[] ptr;
```

こうする事で正しく削除が行えます。

さてでは実際に、使って見ましょう。

```cpp
#include<iostream>

int main()
{
    unsigned int size=10;
    int* ptr=new int[size]{};

    std::cout<<sizeof(ptr)/sizeof(ptr[0])<<std::endl; // #1

    ptr[0]=42;
    *(ptr+1)=53;
    for(unsigned int i=0; i<size; ++i)std::cout<<ptr[i]<<" ";
    std::cout<<std::endl;

    delete[] ptr;
}
```

実行結果は以下となります。

```cpp
2
42 53 0 0 0 0 0 0 0 0 
```

基本的な操作の仕方は動的確保でない配列や、ポインターの操作と同じです。

この中でも注目して頂きたいのは、`#1`マークのついた部分、動的配列のサイズを`sizeof`で取得しようとした結果、`2`という意図せぬ数値が得られた点です\(処理系によりこの値は異なる可能性がある\)。このように、動的配列の要素数を取得するのに`sizeof`は使えません。何故なのかは、`sizeof`によってどのような数値が取得できたのかを見ると理解に容易いでしょう。

```cpp
#include<iostream>
int main()
{
    unsigned int size=10;
    int* ptr=new int[size]{};

    std::cout<<sizeof(ptr)<<std::endl;
    std::cout<<sizeof(ptr[0])<<std::endl;

    delete[] ptr;
}
```

実行結果は以下となります。

```cpp
8
4
```

この数値は処理系によって異なる場合がありますが、どんな数値にせよこの場合の`sizeof(ptr)`というのは、**配列全体のサイズではなく、ポインター単体のサイズ**を取得します。よって、ポインター単体のサイズから要素一つ文を除算したところで、なんの意味もないのです。

このように`sizeof`で動的配列のサイズを取得する事は不可能である事を述べましたが、実はそれに加えて、動的配列の要素数を、そのポインタから取得しようとする事自体が不可能なのです。

よって、動的配列のサイズを後に用いるというようであれば、そのサイズを予め変数に入れておくなどの対処が必要となります。

## 7.6.6 malloc / free などC言語由来の動的領域を行う関数

C言語由来である、malloc、freeなどの関数でリソース管理を行うこともできます。C言語では名前空間という概念が存在しないため、すべての関数はグローバルスコープに定義されていますが、C++では全ての標準機能は`std`名前空間内に定義されています\(一部異なる場合がある\)。malloc、freeなども同様、`std`名前空間内に定義されていますので、スコープ名を修飾する必要があります。

```cpp
#include<cstdlib>
#include<algorithm>
#include<iostream>

int main()
{
    unsigned int size=10;
    int* ptr=static_cast<int*>(std::malloc(size*sizeof(int))); // int型10個の配列を作成

    std::fill(ptr,ptr+size,42); // ptrからptr+size(ptrの終端)の要素を全て42で埋める。
    std::fill_n(ptr,size,42); // ptrからsize分の要素を全て42で埋める。実質的には上記と同じ。

    for(unsigned int i=0; i<size; ++i)std::cout<<ptr[i]<<" ";
    std::cout<<std::endl;

    std::free(ptr); // 解放
}
```

`malloc`が領域確保の関数で、`free`が解放の関数です。`malloc`関数は引数に取得するバイト数を指定することで領域を確保します。

```cpp
std::malloc(取得するバイト数)
```

また、`malloc`関数は、戻り型が`void*`のため、取得したい領域の型のポインター型にキャストしなければなりません。

その後、`std::fill`、`std::fill_n`という関数を使っていますが、詳しくは「第12章 STLと標準ライブラリ」で説明しますが、簡単に言えば指定範囲を任意の値で埋める関数です。

```cpp
std::fill(配列開始位置,配列終端位置,埋める値);
std::fill_n(配列開始位置,開始位置からの距離,埋める値);
```

というように使います。その後出力して、`std::free`関数で領域を解放しています。

```cpp
std::free(解放する領域へのポインター)
```

このように`malloc`関数で取得した領域は、`free`関数で解放しなければなりません。

また、`malloc`関数で領域を取得しようとして、もし取得に失敗した場合、`nullptr`を返します。よって、上記のプログラムは`nullptr`チェックを行うことでよりセキュアなプログラムとなります。

```cpp
int* ptr=static_cast<int*>(std::malloc(size));
if(!ptr){
    // 領域を取得できなかった場合
}
```

`malloc`関数は、取得した領域を初期化することができません。取得した領域を初期化するためには、`calloc`関数を使います。

```cpp
unsigned int size=10;
int* ptr=static_cast<int*>(std::calloc(size,sizeof(int)); // 取得した領域を0で初期化
if(ptr){
    // 領域を取得できなかった場合
}
// ...
std::free(ptr);
```

`calloc`関数を使うと、`0`初期化した動的領域が確保できます。しかし、任意の値で初期化する事はできません。そのような場合は、上記の通り`std::fill`、`std::fill_n`で埋める必要があります。

因みに、`std::memset`などで埋める方法もあります。

```cpp
unsigned int size=10;
int* ptr=static_cast<int*>(std::malloc(size*sizeof(int));
std::memset(ptr,42,size);
```

しかし、`memset`関数は、バイト単位で値を埋めるため、その分無駄な繰り返し処理となってしまったり、意図せぬ埋め方をしてしまう事があります。上記のような整数型であれば、バイト単位で埋めるよりも、その型の単位で埋める方が処理としては好ましいですから、`std::fill`もしくは`std::fill_n`を使うべきと言えます。

ところで、一度動的に確保した領域のリサイズを行いたくなる事もあるかもしれません。そういった場合は、`std::realloc`関数を使います。

```cpp
#include<cstdlib>
#include<iostream>

void print(int* const ptr,const unsigned int size) // 要素を出力する関数
{
    for(unsigned int i=0; i<size; ++i)
        std::cout<<ptr[i]<<" ";
    std::cout<<std::endl;
}

int main()
{
    const unsigned int size=10;

    int* ptr=static_cast<int*>(std::calloc(size,sizeof(int))); // 領域確保
    if(!ptr)return -1; // 失敗した場合終了
    std::fill_n(ptr,size,21); // 全要素を21で埋める

    print(ptr,size); // 出力

    int* tmp=static_cast<int*>(std::realloc(ptr,size*2*sizeof(int))); // size*2分の領域を再確保、拡張
    if(!tmp){ // 失敗した場合
        std::free(ptr); // 初めに確保した領域を解放
        return -1; // 終了させる
    }
    std::fill_n(tmp,size*2,42); // 42で埋める

    if(ptr!=tmp){ // 同じアドレスに領域を確保していなければ
        std::memcpy(tmp,ptr,size*2); // 値が保持される保証はないためコピーしておく
        std::free(ptr); // 初めに確保した領域を解放する
    }
    ptr=tmp; // 拡張された領域のアドレスを代入
    tmp=nullptr; // 使わないポインターにはnullptrを入れておく

    print(ptr,size*2);
    std::free(ptr); // 拡張された領域の解放
}
```

実行結果は以下となります。

```cpp
21 21 21 21 21 21 21 21 21 21 
42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 
```

`std::realloc`は拡張したい領域のアドレスと、希望のバイトサイズを指定する事でサイズの拡張を行います。細かい注意点はコメントにある通りですが一つ注意したいのが`realloc`関数は以前に確保したメモリの位置から拡張できるのであれば、そのアドレスから拡張しますが、拡張できなかった場合別のアドレスに領域を確保し直します。拡張に成功すれば以前のデータは保持されますが、別の場所に確保された場合、以前のデータは保持される保証がありません。よって、領域確保の場所に応じて、データをコピーしておかなければない事があります。

...と、ここまで様々な動的に領域を取得する関数を説明してきましたが、これらの関数は`C++`では一般的に使われません。何故ならば、これら全ての関数はC言語から歴史的経緯で受け継がれたもので、C++では`new`、`delete`演算子という言語機能で全てを補え、安全性も高いためです。唯一、`new`演算子に機能としてないのは`std::realloc`のような動的領域に対するリサイズです。もしそのような事をしたいのであれば、後に説明するoperator overloadという機能を使って`new`、`delete`を再定義するか\(推奨しない\)、そもそも自前で動的確保をせず、標準ライブラリに任せる\(最も推奨される\)という手段があります。標準ライブラリに任せる方法は、「第12章 STLと標準ライブラリ」で説明しています。

## 7.6.7 Placement new / delete\(配置new/delete\)による確保済みな領域の活用

最後に、ここまで説明してきたものとは少し異なる領域の確保/活用方法を説明します。

ここまでで説明してきた動的な領域確保は、主に**ヒープ領域から**使うぶんの領域を確保していました。ここで、ヒープ領域の短所を考察してみます。

* まず、ヒープ領域から領域を確保するのは一般的にスタック領域から確保するよりも低速です。

## 7.6.8 メモリリソースの断片化

**リソース領域から多くの回数領域の確保、解放の操作を繰り返すと、断片化が発生してしまい**、希望する領域サイズ分が、リソース中の空き領域の合計サイズと同等以上あったとしても、連続した領域で確保する事ができないため\(ある程度のサイズのデータ領域を確保しようとした時、私たちに与えられている領域確保の方法は配列であり、配列は連続した領域に確保されるという事を思い出してください。\)、領域の確保に失敗すると行った事が起こり得るようになります。

断片化していくメモリの様子を図に示しました。

実際に断片化しやすいコードを書いてみました。わかりやすくするために、ヒープ領域からの確保ではなく、placement newを用いてスタック領域からリソースを確保しています。

このような事を防ぐためには、二つの方法が考えられますね。

* 断片化を防止する
* 断片化したリソースを整理し再利用可能にする

まず断片化がおきないように領域確保を行うこと、これは可能であれば最も好ましい解決方法でしょう。後術する断片化したリソースの再整理は、再整理するだけの処理能力をやはり覆わなくてはなりません。それをなしに、初めから効率の良いリソース確保ができるのであれば、それが最も良いそれが最も良いパフォーマンスの出し方であることは創造型やすいでしょう。


次に、断片化を整理する、**デフラグ**という操作を行う事で再利用可能にする方法です。デフラグの手法は様々ですが、内容としては断片化したリソース領域を一方方向に全てずらして詰めてあげる(メモリコンパクション)といった具合に行います。デフラグの方法については、まだ説明していませんが、主に演算子オーバーロードなどを用いて領域確保の手法や管理方法を各個人が再定義する事で可能となりますが、これについての詳細はまた一つ大きな分野であるため、本章では取り扱いません。
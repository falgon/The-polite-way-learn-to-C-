## 7.4 ムーブセマンティックス

これまでに、コピー、アドレス/参照など、様々な方法でデータに対する操作を行ってきましたが、それに加えてもう一つ、ムーブという概念について説明します。ムーブの概要を理解したら、その仕組みを理解するためglvalueとrvalue、そしてそれぞれが内包している細かい概念を説明していきます。

### 7.4.1 ムーブの概念とその利用

### 7.4.2 用語とムーブセマンティックスの種明かし

#### glvalue
glvalueとは、generalized lvalueの略です。この概念は以下に説明する概念を内包した総合的なlvalueの総称と言えます。

##### lvalue
そもそも、lvalueをまだ説明していませんでした。
lvalueとはlocator valueの略です。
```cpp
// 変数iが宣言されているとする...

i = 42;
// iは式のうちiの値を格納した場所に対して名付けられた識別子名。
// locator(場所) valueを略してlvalue
```
この場合、`i`がlvalueです。
`i`は`i`の値を格納した場所に対して名付けられた識別子名です。よって`i`はlocator valueと言えます。lvalueの定義は以上です。至ってシンプルですね。

しかし、しばしば、lvalueはleft valueの略であるとされる事があります。
```cpp
// 変数iが宣言されているとする...

i = 42;
// iは式のうち左にある値。
// left(左) valueを略してlvalue
```
しかし、これは現代的なセマンティックを考えると、適切な言い方とは言えません。何故ならばleft valueというワードは、かつてムーブという概念がなかった時、単に「左の」値、「右の」値というだけの単純な区分をしていた時代背景に起因しています。よって、より現代的な捉え方として適切な用語は、left valueではなく、locator valueであると言えるのです。

また、lvalueは日本語に訳した場合、主に「左辺値」と呼ばれる事があります。しかし、その意味合いとしてはleft value的なニュアンスを含んでいる事になるため、上記の理由から現代的なlvalueに対する日本語の呼称として、「左辺値」というワードを用いる事は、厳密に精査するとあまり適切な翻訳とは言えません。

しかしそもそも、lvalueであっても右に来る事は当然ながらあるじゃないか、昔の人達のlvalueに対する定義は、元から曖昧なのでは？と思うかもしれません。
```cpp
i = 0;
a = i; // iはlvalueなのに右辺にある...!
```
が、実は曖昧ではないのです。勿論左辺にはlvalueが、右辺にはrvalueがなければならないのです。
```cpp
i = 0; // iはlvalue
a = i; // aもlvalue。iはlvalueだがlvalueに対してlvalueを代入する?
```
しかし、上記コードは`a`に対して`0`を代入(iの値のコピー)するという人間により直感的な動きをします。今まで普通に見て来たコードも、何だかそう考えてみると不思議に思えて来ますね。何故このような事ができるのでしょうか。それは、**lvalueが右辺に来た場合、その右辺にあるlvalueの場所から値を取り出すという処理をするから**です。そして、その取り出した値はrvalueですから、

$$lvalue : rvalue=左辺 :s 右辺$$

という関係が成立します。このような処理のお陰で、上の関係性を保ちながら人間により直感的な動作を実現する事ができるのです。この処理を、用語としては**lvalue-to-rvalue conversion**(lvalueからrvalueへの変換)と言ったりします。

##### xvalue
xvalueはeXpiring valueの略です。意味合いとしては死にかけ(expiring)の値といったところでしょうか。まずどういう事かを理解するために、`std::move`/ムーブ操作の種明かしをする事とします。実は`std::move`/ムーブ操作は、単なるrvalue referenceへのキャストだったのです。以下のように記述する事で実はオブジェクトをムーブする事(std::moveを使うのと同じ事)ができます。
```cpp
int i=0; // iはlvalue。
int a=static_cast<int&&>(i); // rvalue referenceへのキャスト(ムーブ)。
```
この時、`i`はムーブされます。ムーブを行うという事は、ムーブされた元のオブジェクトは未定義となるのですから、それはもはや死んだ(破棄された)も同然ですね。このように、lvalueでありながら直ぐ破棄されると分かるような余命宣言をされているようなオブジェクトはxvalueとされます。


#### rvalue
rvalueはxvalueとprvalueが含んだそれらの総称です。rvalueにも前述したxvalueが含まれます。死にかけの値はlvalueともrvalueとも捉える事ができますからrvalueにもxvalueが含まれます。

##### prvalue
prvalueは、pure rvalueの略です。一時的に生成される無名のオブジェクトを示します。
```cpp
int(); // intのprvalue
42; // intのprvalue
3.14; // doubleのprvalue
nullptr; // std::nullptr_tのprvalue
```
また、参照以外を返却する関数の呼び出しなども含まれます。
```cpp
int f();
f(); // intのprvalue
10+20; // intのprvalue
new int; // int*のprvalue
```

### 7.4.5 glvalue、rvalueの練習
以上の知識を用いて、以下の式が何valueであるか、少し練習してみましょう。(x)がそれぞれ何valueであるか考えて見てください。
```cpp
int f(){}

int main()
{
    int i;
    i; // (1)
    42; // (2)
    int(); // (3)
    f(); // (4)
}
```


### 7.4.4 相関図
以上の説明から、主にglvalue、rvalueらの相関図は以下のように捉える事が出来ます。
![](/assets/value.jpeg)
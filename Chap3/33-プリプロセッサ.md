# 3.3 プリプロセッサ

「3.1.1 インクルード」などで`#include`について触れました。この項では、さらに深くプリプロセスの概要と、`#include`以外のプリプロセッサ命令を見ていきます。

## 3.3.1 プリプロセスとは
プリプロセスとは「1.1.2 プログラミングからアプリケーションの実行/終了の流れ」の項で実行ファイルを生成するまでの一連の流れを示した通り、コンパイル(構文解析)の前にされる処理です。そしてプリプロセスを行う機構をプリプロセッサと言います。そしてそれに対する命令をプリプロセッサ命令と言います。プリプロセッサ命令をする事で何ができるのかと言うと、`#include`のように文字列の置換であったり、その他無効化、情報の出力などを行うことができます。gcc や clang++ でプリプロセッサーの様子を見たい場合、以下のようにコマンドを指定することで可能です。
```cpp
$ g++ -E -P file.cpp
$ clang++ -E -P file.cpp
```

## 3.3.2 #include
まず`#include`命令を見てみましょう。何度か述べている通り、`#include`は指定されたファイルの中身をそのままその部分に置換します。
```cpp
// a.hpp
void f(){}
```
```cpp
// a.cpp
#include"a.hpp"
void f();
int main(){}
```
これをコンパイルすると、
```cpp
$ g++ -E -P a.cpp
```
以下のように出力されます。
```cpp
void f(){}

void f();
int main()
{
 f();
}
```
a.hppの内容がそのままa.cppに置換されている事がわかります。この時`#include`の部分で`"`を使っていますね。しかし例えば`iostream`をインクルードするときは、`<>`を使っていました。これらには動作の違いがあります。

`"`でファイル名を囲んだ場合、処理中のファイルからの相対パス(処理中ファイルの主観から見たファイル位置)でその指定ファイルを探し、その中で見つからなかった場合、事前に組み込まれた標準ライブラリのパスや、追加で渡されたインクルードパスを探します。

`<>`でファイル名を囲んだ場合、**インクルードパスのみ**を探索します。

インクルードパスは、コマンドオプションで指定することができます。例えば、以下のように。
```cpp
$ g++ -I < file path > file.cp
```
`< file path >`の部分にパスを指定します。以下に例を示します。
```cpp
// a.hpp
void f(){}
```
```cpp
// a.cpp
#include<a.hpp> // インクルードパスのみを探索
void f();
int main(){}
```
以下のように実行します。
```cpp
$ g++ -E -P -I . a.cpp
```
`-I`オプションの後に追加するインクルードパスに`.`として自分自身のいる場所とすることで、ファイルを見つける事ができていますね。


`iostream`などの標準で搭載されているヘッダーファイルは、標準的にインクルードパスとされていますので、`<>`が使われています。
しかし以下のようにも勿論できます。
```cpp
#include"iostream"
```
しかし、`"`はインクルードパス以外のパスも探索してしまいますので、効率的とは言えません。よってインクルードパス内のファイルを`#include`するのであれば`<>`を使うべきとなります。

## 3.3.3 #define
`#define`は文字どおり、定義する事ができます。主に**マクロ**を定義します。マクロは以下の二つの使い方が可能です。

### オブジェクト形式マクロ
```cpp
#define ONE 1
#define STRING string
```
このようにマクロを定義した場合、ONEという文字列が1に置き換えられます。試しに使って見ましょう。
```cpp
#define ONE 1
#define INT int
#define VALUE value
#include<iostream>
int main()
{
	INT VALUE=10;
	std::cout<< VALUE <<std::endl;
	std::cout<< ONE <<std::endl;
}
```
実行結果は以下となります。
```cpp
10
1
```
`ONE`は`1`に、`INT`は`int`に、`VALUE`は`value`に置き換わっていますね。マクロ名は空白や記号（`_`を除く）で区切られた文字列が該当します。従って、ソースファイル中に例えば`NOT_ONE`という文字列が出現しても、`NOT_1`に置換されることはありません。

### 関数形式マクロ
例えば以下のような使い方があります。
```cpp
#define PLUS(x) x+x
```
使って見るとわかりやすいです。
```cpp
#define PLUS(x) x+x
#define PLUS_LR(x,y) x+y
#include<iostream>

int main()
{	
	std::cout<< PLUS(10) <<std::endl;
	std::cout<< PLUS_LR(10,20) <<std::endl;
}
```
実行結果は以下となります。
```cpp
20
30
```
`PLUS(x)`とすると、`x+x`に置換され、`PLUS_LR(x,y)`とすると`x+y`に置換されます。よって上記のような出力結果が得られます。

オブジェクト形式、関数形式マクロはそのまま内容が置換されるためこれらの機能を利用した所謂悪用をされる事があります。
```cpp
#define double int
#define signed unsigned
```
これは極端な例ですが、このように、言語仕様に登録されているキーワードすら無関係に置換できてしまいます。
```cpp
#include<iostream>
#define signed unsigned
#define double int
int main()
{	
	signed int a=-100;
	double b=3.14;
	std::cout<<a<<" "<<b<<std::endl;
}
```
実行結果は以下となります。
```cpp
4294967196 3
```
`signed`が`unsigned`に、`double`が`int`になってしまいますから`a`はアンダーフローしてしまい、`b`は切り捨てられます。
このように、キーワードをプリプロセッサで再定義してはなりません。

ここまで`#define`マクロを説明してきましたが、可能な限り**用いるべきではありません**。
理由の一つに、名前の衝突が起きてしまう事が危惧されるためです。プリプロセッサ命令はグローバルな空間にしか定義する事は出来ません(グローバルな空間については「第5章 スコープと名前空間」で扱っています)。よって全ての範囲から用いる事が出来てしまいますので、重複してしまう可能性が高まります。
また、もう一つの理由として可読性が下がる事です。マクロは非常に強力なため何でもできてしまいます。C++の文法や規則を無視するようなマクロ定義してしまえば言語仕様を完全に無視する事ができてしまいます。よって、可能な限り、用いるべきではないのです。

## 3.3.4 #undef
`#undef`はすでに定義された`#define`を無効化する事ができます。例えば以下のように使います。
```cpp
#undef signed
#undef double
```
実際に使って見ましょう。
```cpp
#include<iostream>
#define signed unsigned
#define double int
int main()
{
	signed int a=-100;
	double b=3.14;
#undef signed
#undef double
	signed int c=-100;
	double d=3.14;
	std::cout<<a<<" "<<b<<" "<<c<<" "<<d<<std::endl;
}
```
実行結果は以下となります。
```cpp
4294967196 3 -100 3.14
```
`a`と`b`は型に対する可笑しな`#define`が適用されているため意図した通りなりませんが、その後の`c`と`d`の段階では、`#undef`がされているため可笑しな`#define`がそれ以降無効化されるため意図した通りになりました。これは、可笑しな`#define`に対する対抗のため実用性があるとは思えないかもしれませんが、例えばファイル単位に`#define`を限定したい場合などに使う事ができます。
```cpp
// a.hpp
#include<iostream>
#define FAVORITE_VALUE 1
void f()
{
	std::cout<<FAVORITE_VALUE<<std::endl;
}
```
```cpp
// a.cpp
#include"a.hpp"
void f();
int main()
{
	f();
	FAVORITE_VALUE;
}
```
これは、コンパイルに成功します。a.cppをインクルードしているためa.cppから`FAVORITE_VALUE`を見る事ができます。そこで、a.hppを以下のように改変します。
```cpp

```
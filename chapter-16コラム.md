# コラム
このチャプターではちょっとした小ネタを紹介します。

## strict aliasing rule
C/C++言語には、strict aliasing ruleと言われるルールが存在します。
そのルールは、**ミュータブルなオブジェクトに対して変更を加えた時、どのような場合にその変更が別の変数に影響を与えないと、安全に仮定できるか**を定めた規則です。具体的に述べると、**どのような場合に二つのオブジェクトが同じメモリ位置を参照するかもしれないと仮定すべきか**を定めたルールです。

まず、**aliasing**とはなんでしょうか。以下は二つの変数が**aliasing**であると言える例です。
```cpp
int i=0;
int* ptr=&i;
```
「7.1.2 ポインターの基本」でも述べた通り、ポインタ`ptr`に対して何か変更操作を行なったその後に変数`i`から値を読み取ると、その`ptr`に対する操作に依存して当然`i`から読み取る値も変動するはずです。何故なら`i`と`ptr`の示すメモリ位置は同一だからです。このような同一のメモリ位置を2つ以上のlvalueが示す事を**aliasing**と言います。
以下に更に例を示します。
```cpp
int a;
void f(int& b,int& c);
f(a,a);
```
`f`の両方の引数に`a`を指定しています。この時、`f`内では`b`と`c`は、同一のメモリ位置を示すため**aliasing**となります。
ここで、コンパイラ製作者の気持ちになって見てください。例えば以下のコードは、どのように最適化できると考えられるでしょうか。
```cpp
int a;
int f(double* ptr)
{
    a=10;
    *ptr=20.0;
    return a;
}
```
`a`には10を代入しています。その後、全く関係のないように思われる`ptr`に`20.0`を代入し、その後`a`を返しました。つまり`a`は初めから`10`である、つまりイミュータブルなオブジェクトであると仮定する事は安全であるように思えます。よって以下のように最適化できます。(実際にはC++コードに対して最適化を行うのではなくアセンブリコードの生成に対して最適化を行います。以下は便宜上のイメージです。）
```cpp
int a;
int f(double* ptr)
{
    a=10;
    *ptr=20.0;
    return 10;
}
```
変数`a`に対して読み込みを行なってからその値を返すよりも、コンパイル時に`10`という値であると決めつけてしまった方が良いパフォーマンスとなります。これでめでたく高速な実行ファイルが生成されました、めでたしめでたし...とも現実ではいきませんでした。

例えばもし以下のように、実は`ptr`が`a`と同じメモリ位置を指していて、それに対して変更操作を行なったら、当然値は変動してしまいます。（以下は極端な例です)
```cpp
int a;
int f(double* ptr)
{
    a=10;
    ptr=reinterpret_cast<double*>(&a);
    *ptr=20.0;
    return 10; // ...とは出来ない。
}
```
やはりそう考えると、`a`のデータを再度動的に読み込むしかありません(上のコードで言えばreturn文の部分)。それが例え、**aliasingな変数や変更操作が無かったとしても**...

そこで、aliasを行えるある条件を定めてしまい、それに従わない全てのケースではコンパイラ製作者がlvalue間のaliasingが無いと仮定する事を許容する事にしたのです。この決まりに従う事で、プログラマーは適切な最適化の恩恵を授かる事ができるのです。

* オブジェクトは、下記に示されたいずれかの型をもつlvalue式によってのみアクセスされ、格納された値を持たなけれればならない
    * オブジェクトの有効な型と互換性のある型
    * 修飾された(const,volatailなど)オブジェクトの有効な型と互換性のある型
    * signedまたunsignedのオブジェクトの有効な型に対応する型
    * オブジェクトの有効な型の修飾バージョンに対応するsignedまたはunsignedな型
    * そのメンバとして前述のいずれかの型を含むアグリゲート(class,struct)またはunion型（サブアグリゲートや包含するunionのメンバも再帰的に含まれる）
    * 文字型
    * 派生された動的型(dynamic type)の修飾された/されない(const,volatailなど)基底クラス

全ての


この条件に合致しない場合はlvalue間のaliasingが無いと仮定して良いので、コンパイラ製作者はその仮定に基づいたオプティマイザを自由に実装できます。条件に合致した場合、aliasingの可能性をコンパイラ製作者は考慮しなければなりません。

前述したコード
```cpp
int a;
int f(double* ptr)
{
    a=10;
    *ptr=20.0;
    return a;
}
```
で考えると、strict aliasing(標準規格)の下では、非互換(incompatible)な型である`double`と`int`はaliasになりえないため、コンパイラ製作者には関数`f`を最適化する自由度が与えられます。もし`f`を`f(reinterpret_cast<double*>(&a))`のように呼び出したら、上記の条件に合致してしまうため最適化の余地は与えられません。


よって総括すると、全てのプログラマーは極力strict aliasing ruleに完璧に従うべきです。従わなかった場合、コンパイラ製作者はそれに従って最適化を実装する(SHOUD)ため、期待通りに動かない可能性を孕むかもしれません。例えば、以下はstrict aliasing ruleに背いたコードです。
```cpp
```
これに対して例えばGCCで最適化オプションを付与した場合、以下のように最適化されます。
これは、プログラマの意図した動きではありませんね。しかし、もちろんコンパイラのバグではありません。strict aliasing ruleに背いたプログラマーに全ての責任は帰結するのです。
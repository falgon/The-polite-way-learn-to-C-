# コラム
このチャプターではちょっとした小ネタを紹介します。

## strict aliasing rule
C/C++言語には、strict aliasing ruleと言われるルールが存在します。
そのルールは、**ミュータブルなオブジェクトに対して変更を加えた時、どのような場合にその変更が別の変数に影響を与えないと、安全に仮定できるか**を定めた規則です。具体的に述べると、**どのような場合に二つのオブジェクトが同じメモリ位置を参照するかもしれないと仮定すべきか**を定めたルールです。

まず、**aliasing**とはなんでしょうか。以下は二つの変数が**aliasing**であると言える例です。
```cpp
int i=0;
int* ptr=&i;
```
「7.1.2 ポインターの基本」でも述べた通り、ポインタ`ptr`に対して何か変更操作を行なったその後に変数`i`から値を読み取ると、その`ptr`に対する操作に依存して当然`i`から読み取る値も変動するはずです。何故なら`i`と`ptr`の示すメモリ位置は同一だからです。このような同一のメモリ位置を2つ以上のlvalueが示す事を**aliasing**と言います。
以下に更に例を示します。
```cpp
int a;
void f(int& b,int& c);
f(a,a);
```
`f`の両方の引数に`a`を指定しています。この時、`f`内では`b`と`c`は、同一のメモリ位置を示すため**aliasing**となります。
ここで、コンパイラ製作者の気持ちになって見てください。例えば以下のコードは、どのように最適化できると考えられるでしょうか。
```cpp
int a;
int f(double* ptr)
{
    a=10;
    *ptr=20.0;
    return a;
}
```
`a`には10を代入しています。その後、全く関係のないように思われる`ptr`に`20.0`を代入し、その後`a`を返しました。つまり`a`は初めから`10`である、つまりイミュータブルなオブジェクトであると仮定する事は安全であるように思えます。つまり、以下のように最適化できます。(実際にはC++コードに対して最適化を行うのではなくアセンブリコードの生成に対して最適化を行います。以下は便宜上のイメージです。）
```cpp
int a;
int f(double* ptr)
{
    a=10;
    *ptr=20.0;
    return 10;
}
```
変数`a`に対して読み込みを行なってからその値を返すよりも、コンパイル時に`10`という値であると決めつけてしまった方が良いパフォーマンスとなります。これでめでたく高速な実行ファイルが生成されました、めでたしめでたし...とも現実ではいかないのです。
もし以下のように、型は違っても`ptr`が`a`を指して、それに対して変更操作を行なったら、当然値は変動してしまいます。
```cpp
int a;
int f(double* ptr)
{
    a=10;
    ptr=reinterpret_cast<double*>(&a);
    *ptr=20.0;
    return a; // aは何だ...?
}
```


    


この決まりは主に、コンパイラ製作者がコードをよりよく最適化するための規則です。これは標準規格で定められた規則ですから極力守られるべきです。
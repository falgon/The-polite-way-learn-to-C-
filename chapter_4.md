# 第 4 章 初期化と式、演算子

C++では、初期化と代入の違いを理解する事はとても重要です。また、C++には様々な演算子があり、それらを活用する事でより表現力の高いソースコードの記述を行う事ができます。本章では、初期化と代入についてと、演算子についてを見ていきます。演算子の説明では、一式の流れを理解するため、まずそのそもそもである式という概念を説明します。本章の流れは、以下のようになっています。

1. 初期化と代入
2. 式
3. 演算子(operator)

## 4.2 式

C++には、式(expression)という概念があります。式と聞くと、どうも数学的な式を思い浮かべてしまうかもしれませんが、C++での式という概念はそれとは全く異なるものです。初めに見るとこれは少し理解が難しい概念かもしれません。ハッキリ完全に分からなくてもプログラムを書いていく内に理解できるようになりますので少しずつ理解していきましょう。<br />

C++での式とは、以下のような目的の中から1つ以上用いられる連続的な文の事を言います。

* 定数、変数からの値の計算

* 変数、オブジェクトまたは関数の指定

* 変数、オブジェクトの値を変更するなどといった式の評価以外の操作

それに加えて、式は、プログラム中に単独で存在する事が許されていません。式は、通常文にしなければならないのです。そして文にするためには、<code>;</code>を使います。<br />

箇条書きで書かれた内容を実際のコードにしてみると、わかりやすくなります。<br />まず定数、変数からの計算というのは、こういったものです。

```cpp
10+20; // 定数からの値の計算
int x=10,y=20;
x+y; // 変数からの値の計算
```

お分かりになったかもしれませんが、この<code>10</code>や<code>20</code>といったものを定数と言います。定数とはつまり、今後変わる事のない一定の値の事を表しています。<br />

<code>x</code>と<code>y</code>は定数ではありません。何故ならコード内では<code>x</code>には10を、<code>y</code>には20として初期化していますが、その後<code>x</code>と<code>y</code>に別の値を代入する事ができるので<code>x</code>と<code>y</code>は一定とは言えません。実は、これらの変数を定数として宣言する方法も存在しますが、話が飛びすぎてしまいますので後述する事とします。<br />

次に、変数、オブジェクトまたは関数の指定とはなんでしょうか。それはつまりこういったものです。

```cpp
void f(){}
int main()
{
	int x=10;
	x; // 変数の指定
	f(); // 関数の指定
}
```

<code>void f(){}</code>やら<code>f();</code>といった見た事のない文が出てきましたが、これはこれから関数という章で説明していく内容ですので今はまだ理解する必要はありません。関数という概念を理解した後に、ああ関数もこの式の定義の中に含まれるんだな程度に思っていただければ大丈夫です。<br />

変数の指定は分かると思います。<code>x</code>を10で初期化した後に、ただ単に<code>x;</code>と書いていますが、これは結果的には何も起こりません。何故なら<code>x;</code>とする事でxの中身を参照しようとしていますが、参照した後に特に変数に格納するわけでもなく、出力も入力もしていないからです。<br />

最後に、変数、オブジェクトの値を変更するなどといった式の評価以外の操作とはなんでしょうか。それは、こういったものです。

```cpp
int x=10;
x=20; // 代入によって値を変更
```

<code>x</code>は10で初期化されていますが、その後<code>x=20;</code>とする事で<code>x</code>の値を20に変更しています。何も難しい事はないですね。<br />

以上の三つの定義を1つ以上含むものをC++では、式と読んでおり、冒頭でも説明した通り<code>;</code>を使って式を文にする事で、プログラムは成り立っています。

## 4.3 演算子(operator)

演算子(operator)には様々な種類があります。それぞれ算術演算子、論理演算子、条件演算子、比較演算子、ビット演算子に分類する事が出来ます。それぞれの演算子について解説していきます。

### 4.3.1 算術演算子

| 演算子 | 種別 | 例 | 意味 | 
| -- | -- | -- | -- | 
| `+` | 加算 | `x + y` | `x`に`y`を加える |
| `-` | 減算 | `x - y` | `x`から`y`を引く | 
| `*` | 乗算 | `x * y` | `x`に`y`をかける | 
| `/` | 除算 | `x / y` | `x`を`y`で割る | 
| `%` | 剰余算 | `x % y` | `x`を`y`で割った余りを求める | 

実際にC++で使って見ましょう。

```cpp
#include<iostream>
int main()
{
	int x=10,y=3;
	std::cout << x + y << '\n' << 
		x - y << '\n' << 
		x * y << '\n' << 
		x / y << '\n' << 
		x % y << std::endl;
}
```

実行結果は以下となります。

```cpp
13
7
30
3
1
```

上から、加算、減算、乗算、除算、剰余算の演算結果となります。算術演算子と名付けられている通り、それぞれ数値演算が行われている事が分かると思います。

### 4.3.2 論理演算子

| 演算子 | 種別 | 例 | 意味 | 
| -- | -- | -- | -- | 
| `&&` | 論理積（AND） | `a && b` | `a`と`b`が共に真の場合「真」| 
| &#124;&#124; | 論理和（OR） | a &#124;&#124; b | `a`または`b`が真の場合「真」| 
| `!` | 否定（NOT） | `!a` | `a`が偽の場合「真」、`a`が真の場合「偽」|

C++で使って見ましょう。

```cpp
#include<iostream>
int main()
{
	std::cout << std::boolalpha << ( true && true ) <<  // (1)
	'\n' << ( true || false ) <<  // (2)
	'\n' << ( ! false ) << std::endl; // (3)
}
```

実行結果は以下となります。

```cpp
true
true
true
```

こちらも表に書かれている意味合いのままですが、念のため詳しく解説します。

<ol>

    <li><code>&&</code>演算子は<code>&&</code>に対応する左右の値が<code>true</code>である時に、<code>true</code>となるものです。大雑把な意味合いとしては「どちらも<code>true</code>である時」と捉える事ができます。</li>

    <li><code>||</code>演算子は<code>||</code>に対応する左右のどちらかの値が<code>true</code>である時に、<code>true</code>となるものです。これは、「どちらかが<code>true</code>である時」と捉える事ができますね。</li>

    <li><code>!</code>演算子は<code>!</code>に対応する値が<code>false</code>である時に、<code>true</code>となるものです。また、<code>true</code>である時に、<code>false</code>となるものです。これは、「意味合いを逆転する」と捉える事ができますね。</li>

</ol>

### 4.3.3 条件演算子

| 演算子 | 種別 | 例 | 意味 | 
| -- | -- | -- | -- | 
| `? :` | 条件演算子 | `a ? b : c` | `a`が真なら`b`が実行、`a`が偽なら`c`が実行。|

C++で使ってみましょう。

```cpp
#include<iostream>
int main()
{
	int a=true?10:20; // (1)
	std::cout << a << std::endl;
	a=false?10:20; // (2)
	std::cout << a << std::endl;
}
```

実行結果は以下となります。

```cpp
10
20
```

条件演算子は、<code>?</code>の左側にくる値が<code>true</code>である場合、<code>?</code>の右側の式が実行され、そうでない場合は<code>:</code>の右側にある式が実行されます。上記のプログラム<code>(1)</code>では、<code>true</code>を置いていますので、<code>10</code>で初期化されます。<code>(2)</code>では、<code>false</code>を置いていますので、<code>20</code>が代入されます。

### 4.3.4 比較演算子

| 演算子 | 種別 | 例 | 意味 | 
| -- | -- | -- | -- | 
|`<` | 小なり | `a < b` | `a`は`b`より小さい | 
| `<=` | 小なりイコール | `a <= b` | `a`は`b`以下 | 
| `>` | 大なり | `a > b` | `a`は`b`より大きい | 
| `>=` | 大なりイコール | `a >= b` | `a`は`b`以上 | 
| `==` | イコール | `a == b` | `a`と`b`は等しい | 
| `!=` | ノットイコール | `a != b` | `a`と`b`は異なる |

C++で使って見ましょう。

```cpp
#include<iostream>
int main()
{
	std::cout << std::boolalpha << (10 < 20) << // (1)
		'\n' << (10 <= 10) << // (2)
		'\n' << (20 > 10) << // (3)
		'\n' << (10 >= 10) << // (4)
		'\n' << (10 == 10) << // (5)
		'\n' << (10 != 20) << std::endl; // (6)
}
```

実行結果は以下となります。

```cpp
true
true
true
true
true
true
```

それぞれ、以下のようになります。

1. 10は20よりも小さいので<code>true</code>です。

2. 10は10以下であるので<code>true</code>です。

3. 20は10よりも大きいので<code>true</code>です。

4. 10は10以上であるので<code>true</code>です。

5. 10は10と等しいので<code>true</code>です。

6. 10は20と異なるので<code>true</code>です。

### 4.3.5 ビット演算子

| 演算子 | 種別 | 例 | 意味 | 
| -- | -- | -- | -- | 
| `&` | ビット毎のAND | `a & b` | `a`と`b`のビット単位のAND | 
| `｜` | ビット毎のOR | `a ｜ b` | `a`と`b`のビット単位のOR | 
| `^` | ビット毎の排他的OR | `a ^ b` | `a`と`b`のビット単位の排他的OR | 
| `~` | ビット単位の反転 | `~a` | `a`の各ビットを反転 | 
| `<<` | 左シフト | `a << b` | `a`を`b`ビット分、左へシフト | 
| `>>` | 右シフト | `a >> b` | `a`を`b`ビット分、右へシフト |

C++で使って見ましょう。

```cpp
#include<iostream>
#include<bitset>
#include<climits>
#define SCCT_BIT(x) static_cast<std::bitset<CHAR_BIT&>>(x)
int main()
{
	unsigned char a=0b10101010;
	std::cout << "& :" << SCCT_BIT( a & 0b11110000 ) << // (1)
		'\n' << "| :" << SCCT_BIT( a | 0b11110000 ) << // (2)
		'\n' << "^ :" << SCCT_BIT( a ^ 0b00001111 ) << // (3)
		'\n' << "~ :" << SCCT_BIT( ~ a) << // (4)
		'\n' << "<< :" << SCCT_BIT( a << 2 ) << // (5)
		'\n' << ">> :" << SCCT_BIT( a >> 2 ) << std::endl; // (6)
}
```

実行結果は以下となります。

```cpp
& :10100000
| :11111010
^ :10100101
~ :01010101
<< :10101000
>> :00101010
```

何やら<code>bitset</code>や<code>climits</code>といったヘッダファイルをインクルードしていますね。さらにその下には、<code>#define SCCT_BIT(x) static_cast&lt;std::bitset&lt;CHAR_BIT&gt;&gt;(x)</code>なる、よくわからないものがありますが、これは後に説明する、マクロ、キャスト、テンプレートといった概念が含まれていますので、現時点では気にしなくて大丈夫です。意味合いとしては、標準出力へ出力する際に、2進数表記のまま数値を出力しろというものになります。<br />また、変数<code>a</code>の初期化値、<code>0b10101010</code>とはなんでしょうか。これは二進数リテラルという概念を用いた、二進数表記の数値です。これについても後述しますが、二進数リテラルを簡単に説明すると、<code>0b</code>を実際の二進数値の前に付与する事で、この数値は二進数表記された数値であるとコンパイラに伝える事ができます。今回のコードで二進数表記を用いているのは、ビット演算の考察において通常の10進数表記の値よりも便宜的だからです。どう便宜的なのかは読み進めていけば理解できます。<br /><br />

さて、ビット演算子は、少し理解しにくいかもしれませんが、整数型の数値に対してビット単位で演算を行うための演算子となります。<br />

それぞれ解説していきます。

**(1)**&nbsp;<code>&</code>演算子の機能はつまり、「両方のビット値が1のときのみ結果が1になるビット演算」です。このコードでは、<code>10101010</code>に対して<code>11110000</code>という数値を<code>&</code>演算子を用いて適用しています。<code>&</code>演算子は「両者のビット値が1のときのみ結果が1になる」のですから、その演算結果は<code>10100000</code>となります。両者の数値を見比べて見るとその様子が理解できるでしょう。分かりやすく図にすると以下のようになります。

| 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 
| -- | -- | -- | -- | -- | -- | -- | 
| & | & | & | & | & | & | & | & | 
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 
| ↓ | ↓ | ↓ | ↓ | ↓ | ↓ | ↓ | ↓ | 
| 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |

**(2)**&nbsp;<code>|</code>演算子の機能はつまり、「いずれかのビット値が1なら結果が 1になるビット演算」です。このコードでは、<code>10101010</code>に対して<code>11110000</code>という数値を<code>|</code>演算子を用いて適用しています。<code>|</code>演算子は、「いずれかのビット値が1なら結果が1になる」のですから、その演算結果は<code>11111010</code>となります。

**(3)**&nbsp;<code>^</code>演算子の機能はつまり、「両方のビット値が異なるときに結果を1にするビット演算」です。このコードでは、<code>10101010</code>に対して<code>00001111</code>という数値を<code>^</code>演算子を用いて適用しています。<code>^</code>演算子は、「両方のビット値が異なるときに結果を1にする」のですから、その演算結果は<code>10100101</code>となります。

**(4)**&nbsp<code>~</code>演算子の機能はつまり、「ビット値の反転を行うビット演算」です。このコードでは、<code>10101010</code>に対して<code>~</code>演算子を適用しています。<code>~</code>演算子は「ビット値の反転を行う」のですから、その演算結果は<code>01010101</code>となります。

**(5)**&nbsp;<code>&lt;&lt;</code>演算子は左シフト演算子とも呼ばれます。<code>10101010</code>に対して、<code>&lt;&lt;</code>演算子を用いて<code>2</code>を指定する事で、<code>10101010</code>を2ビット左へシフトしろという意味になります。2ビット左へシフトとは、<code>10101010</code>の頭2ビット分を捨て、後ろ2ビット分を入れるという事です。その後ろには値として0が入ります。図で表すと、このようになります。

* 左シフト演算前

| 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 
| -- | -- | -- | -- | -- | -- | -- |

* 左シフト演算実行

頭2ビット分消滅。後ろにその2ビット分が入る。値は0が入る。

| &nbsp; | &nbsp; | 1 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 
| -- | -- | -- | -- | -- | -- | -- | 

* 演算結果

| 1 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 
| -- |

**(6)**&nbsp;<code>&gt;&gt;</code>演算子は右シフト演算子とも呼ばれます。<code>(5)</code>によって変数<code>a</code>の値は<code>10101000</code>となっています。この数値に対して、<code>&gt;&gt;</code>演算子を用いて<code>2</code>を指定する事で、<code>10101000</code>を2ビット右へシフトしろという意味になります。2ビット右へシフトとは、<code>10101000</code>の後ろ2ビット分を捨て、頭2ビット分を入れるという事です。図で表すと、このようになります。

* 右シフト演算前

| 1 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 
| -- | 

 

* 右シフト演算実行

後ろ2ビット分消滅。頭にその2ビット分が入る。空いた部分にはその値が符号無しなら 0が入ります。値が符号付きなら、算術シフトを行う処理系では1が入り、論理シフトを行う処理系では0が埋められます。算術シフトと論理シフトの詳細については現時点で理解する必要はありませんが、左シフトの演算処理が均一である事に対し、右シフトは処理系によって異なりますので、注意しましょう。

| 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | &nbsp; | &nbsp; | 
| -- |

* 演算結果

| 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 
| -- |

符号付きの数値である場合を見て見ましょう。

```cpp
#include<iostream>
#include<bitset>
#include<climits>
#define SCCT_BIT(x) static_cast<std::bitset>CHAR_BIT>>(x)
int main()
{
	signed char a=0b11110110;
	std::cout << SCCT_BIT( a >> 2 ) << std::endl;
}
```

実行結果は以下となります。

```cpp
11111101
```

1で埋められている事が確認できますね。

## 4.4 sizeof演算子

| 演算子 | 例 | 意味 | 
| -- | 
| `sizeof` | `sizeof(a)` | `a`のバイト長を演算する |

C++で使って見ましょう。

```cpp
#include<iostream>
int main()
{
	char a; int b; double c; bool d;
	std::cout<< sizeof(a) << '\n' <<
		sizeof(b) << '\n' <<
		sizeof(c) << '\n' << 
		sizeof(d) << '\n' << 
		sizeof(main()) << std::endl;
}
```

実行結果は以下となります。

```cpp
1
4
8
1
4
```

上から<code>char</code>、<code>int</code>、<code>double</code>、<code>bool</code>型のバイト長が出力されていますね。2.2 変数とデータ型の項に書かれている表と見比べると、その通りに出力されている事がわかります。<br />

最後の<code>sizeof</code>式では、<code>main()</code>と書いていますね。この出力結果は4バイトと出力されていますがなぜでしょうか。<br />

実は、これはmain関数の戻り値、つまり<code>int</code>のサイズが出力されているのです。では、これは何が出力されるでしょうか。

```cpp
char f(){}
int main()
{
	sizeof(f());
}
```

実行結果は以下となります。

```cpp
1
```

<code>f</code>という関数は戻り値が<code>char</code>型であるので、そのバイト長である1が出力されます。<br />

このコードは、これから説明する関数という概念を用いていますので現時点で理解する必要はありませんが、<code>sizeof</code>演算子に関数を入れると、その戻り値型のバイト長が得られるという事が理解していただければと思います。<br />

この内容については、関数の章で再度取り上げます。

## 4.5 演算子の優先順位規則

それぞれの演算子には優先順位というものがあります。例えば、以下のコードはどのように処理されるでしょうか。

```cpp
#include<iostream>
int main()
{
    std::cout << 42 + 10 * 10 << std::endl;
}
```

実行結果は以下となります。

```cpp
142
```

出力結果から、加算よりも乗算の方が先に行われるという数式の性質が現れている事が確認できます。このように、演算子には全て処理、評価される優先順位が全て決められています。

では以下に、演算子の優先順位を網羅した表を掲示します。中にはまだ見たことのない演算子もありますが、後に説明していきますので大丈夫です。

#### 最高優先順位である演算子(結合性なし)

| 演算子 | 機能 | オーバーロード |  
| -- | -- | -- | 
| `::` | スコープの解決 | × |  

#### 第二優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- | 
| `()` | 関数呼び出し | ○ | 
| `[]` | 配列添字参照 | ○ | 
| `.` | 直接メンバーアクセス | × | 
| `->` | 間接メンバーアクセス |  ○ | 
| `++` | 後置インクリメント | ○ | 
| `--` | 後置デクリメント | ○ | 
| `typeid` | 実行時型情報 | × | 
| `const_cast` | 型キャスト(const外し) | × | 
| `dynamic_cast` | 型キャスト(静的/動的キャスト) | × | 
| `static_cast` | 型キャスト(静的キャスト) | × | 
| `reinterpret_cast` | 型キャスト(強制キャスト) | × | 
| `(型)` | 型キャスト | - | ○ |

#### 第三優先順位である演算子(右から左へ結合)

| 演算子 | 機能 | オーバーロード | 
| -- | -- | -- | 
| `++` | 前置インクリメント | ○ | 
| `--` | 前置デクリメント | ○ | 
| `+` | 単項プラス | ○ | 
| `-` | 単項マイナス | ○ | 
| `~` | ビット否定 | ○ | 
| `!` | 論理否定 | ○ | 
| `&` | アドレス取得 | ○ | 
| `*` | 間接参照、参照外し | ○ | 
| `(型)` | 型キャスト | ○ | 
| `sizeof` | サイズの取得 | × | 
| `new` | 動的な領域確保 | ○ | 
| `new[]` | 動的な配列領域確保 | ○ | 
| `delete` | 動的な領域開放 | ○ | 
| `delete[]` | 動的な配列領域開放 | ○ | 

#### 第四優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード | 
| -- | -- | -- | 
| `.*` | メンバーへのポインター | × | 
| `->*` | メンバーへのポインター | ○ |

#### 第五優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード | 
| -- | -- | -- | 
| `*` | 乗算 | ○ | 
| `/` | 除算 | ○ | 
| `%` | 剰余 | ○ |

#### 第六優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード | 
| -- | -- | -- | 
| `+` | 加算 | ○ | 
| `-` | 減算 | ○ | 

#### 第七優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード | 
| -- | -- | -- | 
| `<<` | 左シフト | ○ | 
| `>>` | 右シフト | ○ |

#### 第八優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード | 
| -- | -- | -- | 
| `<` | 小なり | ○ | 
| `<=` | 小なりイコール | ○ | 
| `>` | 大なり | ○ | 
| `>=` | 大なりイコール | ○

#### 第九優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード | 
| -- | -- | -- | 
| `==` | イコール(等価) | ○ | 
| `!=` | ノットイコール(不等価) | ○ | 

#### 第十優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード | 
| -- | -- | -- | 
| `&` | ビット積(AND) | ○ | 

#### 第十一優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード | 
| -- | -- | -- | 
| `^` | ビット排他的論理和(XOR) | ○ | 

#### 第十二優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード | 
| -- | -- | -- | 
| `｜` | ビット和(OR) | ○ |

#### 第十三優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード | 
| -- | -- | -- |
| `&&` | 論理積 | ○ | 

#### 第十四優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード | 
| -- | -- | -- |
| `｜｜` | 論理和 | ○ |

#### 第十五優先順位である演算子(右から左へ結合)

| 演算子 | 機能 | オーバーロード | 
| -- | -- | -- |
| `? :` | 条件演算子 | × | 

#### 第十六優先順位である演算子(右から左へ結合)

| 演算子 | 機能 | オーバーロード | 
| -- | -- | -- | 
| `=` | 代入 | ○ | 
| `*=` | 乗算代入 | ○ | 
| `/=` | 除算代入 | ○ | 
| `%=` | 剰余代入 | ○ | 
| `+=` | 加算代入 | ○ | 
| `-=` | 減算代入 | ○ | 
| `<<=` | 左シフト代入 | ○ | 
| `>>=` | 右シフト代入 | ○ | 
| `&=` | ビット積代入 | ○ | 
| `^=` | ビット排他的論理和代入 | ○ | 
| `｜=` | ビット和代入 | ○ | 

#### 第十七優先順位である演算子(結合性なし)

| 演算子 | 機能 | オーバーロード | 
| -- | -- | -- | 
| `throw` | 例外送出 | × | 

#### 第十七優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- | 
| `,` | 順次演算子 | ○ |
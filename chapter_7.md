# 第 7 章 ポインター、配列、参照
本章ではポインターと参照について説明します。この二つの概念はC++言語の最も重要な概念の1つと言えます。またポインターと参照は強い結びつきがあり、同時に学ぶ事でその関係性に気付けるでしょう。またこの章をマスターした暁には、今までよりもずっと効率的なプログラムを書けるようになるでしょう。
この章では以下の様な流れで説明していきます。

* ポインターの概念
* 配列の概念
* 参照の概念
    * lvalue reference
    * rvalue reference
* ムーブセマンティックス
    * glvalueとrvalue
    * lvalue、xvalue、prvalue

## 7.1 ポインター
まず、ポインターとは、単純に英語単語から考えて、どういう意味でしょうか。ポインターはポイント(point)をする者ですね。つまり、ポインター(pointer)とは何かを指し示すものなのです。誰もが使う身近なものから例えると、デスクトップなどにあるショートカットアイコンが良い例です。例えば何かブラウザのショートカットアイコンをダブルクリックすると、そのブラウザが起動しますね。しかしショートカット自体は、アプリケーションの実体ではありません。実体のアプリケーションの居場所を指し示しているのです。当然の事を、何を言っているのだと思うかもしれません。しかし、分からなくなってしまったら、この事を思い出して見てください。少し頭の中で整理できるかもしれませんから。

### 7.1.1 メモリアドレス
「第1章 基礎知識」で触れたように、コンピューターにはメモリーと言われる装置があります。メモリーは1バイト単位で区分けされていて、そのそれぞれに**アドレス**が割り当てられています。**アドレス**は実際には数値です。この章までのサンプルコードで何度も様々な変数や関数などの宣言/定義などを行ってきましたが、それらは全てメモリ上のどこかのアドレスに格納されているのです。これは、「6.2.3 メモリ領域」でも少し触れました。実は、このアドレスを実際に見る事ができるのです。コードは以下となります。
```cpp
#include<iostream>
int main()
{
    int a;
    std::cout<<&a<<std::endl;
}
```
`&`演算子によってアドレスを取得する事ができます。尚、実行結果は実行時/実行環境によって変動します。何故かというと、どこのアドレスへ領域を確保するかはその時々によってCPUが勝手に判断するためです。しかし何やら、よく分からない数値が出力されたと思います。それが、変数`a`が領域確保されたメモリ上のアドレスなのです。ここで、変数`a`がどれぐらいの領域を`&a`で出力されたメモリから使っているのか少し調べて見ましょう。まず、`sizeof`で`int`型のサイズを見て見ます。(int型のサイズは規格によって定められておらず、環境によって変動します。)
```cpp
#include<iostream>
int main()
{
    int a;
    std::cout<<sizeof(a)<<std::endl;
}
```
筆者の環境では以下のように出力されました。
```cpp
4
```
便宜上、ここでは`int`型を4バイトとして話を進めます。先ほどメモリーは1バイト単位で区切られていると述べました。という事はつまり、変数`a`は**論理的には**`&a`で出力された値から4バイト分を使っているという事になりますね。...さて、理解を深めるためにさらに以下のコードを見て見ましょう。`static_cast`については今は気にしなくても大丈夫です。
```cpp
#include<iostream>
int main()
{
    char a;
    double b;
    std::cout<<sizeof(a)<<std::endl;
    std::cout<<sizeof(b)<<std::endl;
    std::cout<<static_cast<void*>(&a)<<std::endl;
    std::cout<<&b<<std::endl;
}
```
筆者の環境では以下のように出力されました。(`char`型は必ず1バイトです。)
```cpp
1
8
0x7fff53a1558f
0x7fff53a15580
```
`char`型は1バイトです。なので、この時変数`a`はアドレス、`0x7fff53a1558f`を使います。`double`型は8バイトと出力されました。なのでこの時、変数`b`は`0x7fff53a15580`から`0x7fff53a15588`までを使うという事になります。今の所はなんとなくメモリをどのように占有するのか、イメージが出来れば大丈夫です。

### 7.1.2 ポインターの基本
変数のアドレスを`&`演算子によって得る事ができました。
```cpp
int main()
{
    int a=42;
    &a; // アドレス取得
}
```
アドレスはつまりその変数の居場所を示しています。という事は、そのアドレスの居場所を目当てに何か操作すれば変数`a`を使わなくても変数`a`の中身を操作できるという事になりますね。やってみましょう。それには、まず変数`a`のアドレスをメモって置いて、そのアドレスに対して操作をすると良いかもしれません。メモるために、アドレスを格納する用の変数があったら便利ですね。それが、C++にはあります。そして、それをポインターを言うのです。
```cpp
int main()
{
    int a=42;
    int* a_ptr=&a; // アドレスをa_ptrに格納。
}
```
`型* 識別子`とする事で、その型のアドレスを格納するポインターと宣言する事ができます。そして、ポインター(この場合、`a_ptr`)が指している(この場合、変数`a`)値を取得するには以下の様に書きます。
```cpp
#include<iostream>
int main()
{
    int a=42;
    int* a_ptr=&a;
    std::cout<< *a_ptr <<std::endl; // *によって値を取得。
}
```
実行結果は以下となります。
```cpp
42
```
`*`演算子をポインターに付与する事で、そのポインター(この場合`a_ptr`)が指している(この場合、変数`a`)値を取得する事ができます。という事は、`a_ptr`は変数`a`のアドレスを挿しているのですから、変数`a`の値を変えた場合、`a_ptr`から取得できる値も変わるという事です。**メモリの同じ場所にあるデータを別のモノから見ようとしているだけ**なのですから、当然ですね。
```cpp
#include<iostream>
int main()
{
    int a=42; // aを42で初期化
    int* a_ptr=&a; // aのアドレスを格納
    std::cout<< *a_ptr <<std::endl; // aのアドレスにある値を見る

    a=50; // aに50を代入
    std::cout<< *a_ptr <<std::endl; // するとaと同じアドレスを見ているのだから50が得られる
}
```
実行結果は以下となります。
```cpp
42
50
```
逆に、ポインターを使って、そのポイントしている場所へ値を代入する事もできます。
```cpp
#include<iostream>
int main()
{
    int a;
    int* a_ptr=&a;

    *a_ptr=42; // ポインタを使ってaと同じところに値42を代入
    std::cout<< a <<std::endl;
    *a_ptr=50; // 同じ
    std::cout<< a <<std::endl;
}
```
実行結果は以下となります。
```cpp
42
50
```
実際の値の代入にも`*`演算子を使います。この関係性が分かれば、とても良い調子で理解できていると言えます。ちなみに、以下の様にすると何が出力されるでしょうか。
```cpp
#include<iostream>
int main()
{
    int a=42;
    int* a_ptr=&a;
    std::cout<< a_ptr <<std::endl; // * 演算子がない
}
```
これははたまた実行時/実行環境によって変動します。何故ならばその出力された値というのは、単にそのポインターが指しているアドレスだからです。以下の様にして見て見ましょう。
```cpp
#include<iostream>
int main()
{
    int a=42;
    int* a_ptr=&a;
    std::cout<< &a <<std::endl;
    std::cout<< a_ptr <<std::endl;
}
```
出力される値は実行時/実行環境によって変動します。しかし、全く同じ数値が出力されます。この結果から、変数`a`と変数`a_ptr`が全く同じメモリアドレス領域を使っている事が分かるでしょう。また、以下の様な事もできます。
```cpp
#include<iostream>
int main()
{
    int a=10,b=20,c=30;
    int *ptr=&a; // 変数aと同じ場所を指す。
    
    *ptr=100; // aと同じ場所に対して値100を代入
    std::cout<<a<<std::endl; // 100
    
    ptr=&b; // 指す先を変数aからbへ変更。変数bと同じ場所を指す。
    *ptr=200; // bと同じ場所に対して値200を代入
    std::cout<<b<<std::endl; // 200

    ptr=&c; // 指す先を変数bからcへ変更。変数cと同じ場所を指す。
    *ptr=300; // cと同じ場所に対して値300を代入
    std::cout<<c<<std::endl;
}
```
実行結果は以下となります。
```cpp
100
200
300
```
なんと、変数`a`、`b`、`c`を初めにそれぞれ`10`、`20`、`30`として初期化したのに、それぞれの変数に一切直接手をつけずにそれぞれの値を変えてしまいました。ポインターとして宣言されたポインタ変数は、`*`無しで代入する事で指す先のアドレスを変更する事ができます。よって初めに変数`a`のアドレスを持っていたとしてもその後に変数`b`のアドレスを同じポインターにまた代入する事ができるのです。それにより、`ptr`という同じポインタ変数名でありながら、指し示しているアドレスが変わっているのです。そして、`*`演算子を使って実際の値を代入していますから、それぞれの変数の値が変わるのというのはよくよく考えれば当然の事ですね。

### 7.1.3 nullptr
突然ですが、以下に壊滅的なコードを示します。
```cpp
#include<iostream>
int main()
{
    int* ptr;
    std::cout<< *ptr <<std::endl;;
}
```
これをコンパイル、実行してはいけません。ポインタは、何かを指すものです。しかし、このコードでは`ptr`というポインタが何を指すのか示されていません。「4.1.2 不定値」で説明したのと同じ様に、ポインタ変数であっても初期化、代入を行わなかった場合、どんな値が入っているかは規定されていません。つまり、プログラムが使って良いと許可されていない領域のアドレスを示すような値が入っていても、全くおかしくはないのです。C++言語は元々C言語の拡張言語として開発された言語ですが、許可されていないアドレスへのアクセスを行ってしまうというのはC言語時代からあるとても典型的で最も致命的なバグの1つです。これは、絶対的に未然に防がなければなりません。未然に防ぐ手段を考えて見ましょう。問題は、そのポインターが不正なアドレスを持った状態でそのアドレスへ操作を行う事です。では、そのポインターが不正なアドレスを持っているかどうかを確かめ、不正なアドレスでない場合のみ操作を行うとすれば良いのではないでしょうか？実際にやってみましょう。
```cpp
#include<iostream>
int main()
{
    int* ptr=nullptr; // nullptrを入れておく
    if(ptr!=nullptr)std::cout<< *ptr <<std::endl; // ptrはnullptrのままなのでこの一文は実行されない
}
```
`nullptr`は標準規格で予め定められているキーワードです。
一般的に、`null`というワード自体は「空」だとか、「何も初期化されていない」といったニュアンスで使われます。`nullptr`はつまり、「何も初期化されていないポインタ」という意味と捉える事ができます。コードでは、`nullptr`を`int`型のポインター型へ予め代入しています。つまり、`nullptr`は`int`型の数値なのだろうかと考えられるかもしれません。それは実は考え方によっては合っています。ここまでの知識のみだと、`nullptr`自体の仕組みを理解することはできません。ですので今はとにかく、まずは`nullptr`を代入しておく事で、そのポインターが不正なアドレス値を持っていないかどうかを確認する事ができる、と認識してください。`nullptr`の詳細については、「第12章 STLと標準ライブラリ」にて再度取り上げます。

### 7.1.4 ポインターの利用
ここまでで、ポインターの基本を知ったところで一体この機能は何に使えるんだ？と思ったかもしれません。しかも、不正なアドレスを持ったポインタを誤って使ってしまう可能性もありますからただただリスクがあるだけで何も良いところは無いじゃないかと思うかもしれません。しかし、ポインタの概念を使わなければ出来ない事もあるのです。例題として以下のコードを見て見ましょう。
```cpp
#include<iostream>
void swap(int a,int b)
{
    int tmp=b;
    b=a;
    a=tmp;
}

int main()
{
    int a=10,b=20;
    swap(a,b);
    std::cout<<a<<std::endl<<b<<std::endl;
}
```
変数`a`と変数`b`の値を入れ替える`swap`という関数を定義しました。`a`は`10`、`b`は`20`で初期化しています。実行結果は以下となります。
```cpp
10
20
```
残念ながら意図通りに動いていませんね。しかし、何故でしょうか。コードを見る限りやろうとしている事は正しい様に思えます。これを理解するにはコピーという概念を知らなくてはなりません。

#### コピー
コピーとはどのような意味でしょうか。翻訳するならば「複製」ですね。プログラムの世界では、新しい変数に対して元の変数の**値**を適用した状態を複製と言うのです。まずは以下のコードを見てください。
```cpp
int main()
{
    int x=10;
    int y=x;
}
```
この時、yの値は何でしょうか。`10`です。当然ですね。しかしこの時、xの値は何でしょうか。それは、`10`です。...何を言っているのか分からないかもしれませんが、「コピー」とはこの事を言います。変数`y`に対して変数`x`を代入しています。しかしその後変数`x`が使えなくなるわけではないですよね。何故ならば、複製しているからです。**同じ値を持つ変数を別の領域に確保させているからです。**

#### コピーと仮引数
先ほど、コピーとは同じ値を持つ変数を別の領域に確保していると述べました。関数で以下の様に書いた場合、**関数に渡された変数はコピーされます**。
```cpp
void f(int x) // xはコピーされた変数。main関数の変数aではない。
{
    x;
}
int main()
{
    int a=10;
    f(a);
}
```
ここで冒頭に述べた`swap`関数がうまく動かない理由が理解できたかもしれません。要するに、冒頭で述べた`swap`関数が意図した通りに動かなかった理由は、**コピーされた別の変数同士の値を入れ替えているだけで、渡された変数の値を入れ替えていたわけではなかったから**なのです。
```cpp
#include<iostream>
void swap(int a,int b) // a、bはswap関数内で新たに複製されたコピーであって、決してmain関数内で定義されたaとbではない。
{
    int tmp=b;
    b=a;
    a=tmp;
}
int main()
{
    int a=10,b=20;
    swap(a,b);
    std::cout<<a<<std::endl<<b<<std::endl;
}
```
コピーされた変数の値を変更しても、コピー元は変わりません。当然です。データXがあったとします。Xのバックアップを取っておいて(コピー/複製)、それをYとします。Yに対して何か破壊的な事をしてしまい、Yは壊れてしまいました。その時、Xは壊れているでしょうか。当然ながら、壊れていませんよね。といった単純な事です。それではコピーではなく、変数そのものを渡したい場合はどのようにすれば良いのでしょうか。解決方法の1つとして先ほどから学んできたポインターが使えるのです。
```cpp
#include<iostrem>
void swap(int* a,int* b)
{
    int tmp = *b;
    *b = *a;
    *a = tmp;
}
int main()
{
    int a=10,b=20;
    swap(&a,&b);
    std::cout<<a<<std::endl<<b<<std::endl;
}
```
実行結果は以下となります。
```cpp
20
10
```
このように`swap`関数の仮引数を、アドレスを受け取るように定義しました。変数のアドレスをポインターで受け取って、そのポインタからアドレスへアクセスすれば、変数自体を弄るのと同等になりましたね(「7.1.2 ポインターの基本」)。それを利用して変数をコピーするのではなく、アドレスを渡してそれに対して操作を行う事で、その変数自身の値を操作するのと同等の機能を実現しています。

### 7.1.5 ポインターのポインター
ポインターは、変数に`&`演算子を用いた値を代入する事でその変数と同じ領域を指す事ができました。
```cpp
int main()
{
    int a;
    int* a_ptr = &a;
}
```
ところでポインタとは変数ですね。当たり前の事を言っているように思えるかもしれませんが、もう一度言います、ポインタ自体も任意のアドレスを格納しておける変数です。そして、変数には`&`演算子を使う事でその変数が使う領域のアドレスを取得する事が出来ました。という事はつまり、ポインターに`&`演算子を使った場合はポインターのアドレスを取得できるのでしょうか。やってみましょう。
```cpp
int main()
{
    int a;
    int* ptr = &a;
    int** pptr = &ptr;
}
```
`int**`とする事で`int`型のデータを指すポインターを指すポインターを定義しています。何度も言っていますが、ポインタ自体も変数です。という事はつまりポインタ自体もメモリのどこかに領域を使って格納されているのです。メモリ領域を使っているのであれば、そのアドレスを取得する事は当然ながら可能です。では、ポインタ自体はどれだけの領域を使っているのでしょうか。実際に`sizeof`で見てみましょう。
```cpp
#include<iostream>
int main()
{
    std::cout<<sizeof(int*)<<std::endl<<
    sizeof(char*)<<std::endl<<
    sizeof(double*)<<std::endl<<
    sizeof(float*)<<std::endl<<
    sizeof(bool*)<<std::endl;
}
```
実行結果は、32ビットOSか、64ビットOSかで変動します。筆者の環境(64ビット)では実行結果は以下となりました。
```cpp
8
8
8
8
8
```
32ビットOSであれば全て`4`が出力されるでしょう。このように、ポインターの型によってそのポインターが使うサイズはそれぞれ全く変わりません。どんな型のポインターであっても、32ビットOSであれば`4`バイトであり、64ビットOSであれば`8`バイトの領域を使います。何故でしょうか。よくコンピューターを購入しようと検討している時などに、**32ビットOSではメモリー容量を4GBまでしか読み込めない**と聞いた事はないでしょうか。これはメモリのアドレス1バイトずつ全てに数値を割り当てようとした時、32ビットの容量の数値では4GB領域までしかアドレスを割り当てる/表現する事ができないからです。分かりやすくするため少し例え話を交えて解説します。

#### 環境によって何故ポインター変数の使う領域が変動するのか
「7.1.1 アドレス」でも述べたように、メモリーには全てアドレスという数値が割り当てられています。前提として、**もし割り当てなければ、つまり認識不可能という事になりますので、コンピューターはその領域を作業領域として使う事はできません**。例えば現実的には有りえない話ですが、1ビットOSがあったとします。1ビットで表せるのは、`0`か`1`のみです。(二進数で考える事を想定としています。二進数表記で使える数字は`0`と`1`のみでしたね。何故二進数で考える必要があるのかは、コンピューターの記憶の最小単位に起因しています。「2.2.5 バイト、ビット」などを参照して下さい。)

`0`か`1`の2種類しか使えないので、メモリーには2バイト分(2つ分)のアドレスを割り振る事ができます。よって、このOSが認識できるメモリー容量は2バイトという事になります。この話でメモリを図式化すると、以下のようになります。

| 0 | 1 |
| -- | -- | 

次に、2ビットOSがあったとします。2ビットで表せる数値を列挙してみましょう。`00`と`01`と`10`と`11`ですね。つまり、2ビットOSでは4種類のパターンが存在するので4バイト分(4つ分)にアドレスを割り振る事ができます。

| 00 | 01 | 10 | 11 | 
| -- | -- | -- | -- | 

このように、**1ビットずつ増えるたびに扱える数値は2倍になりますから、その分割り当てられるアドレスの数も2倍になります。**
念のため3ビットOSの場合も考えてみましょうか。ここまで読んできていれば簡単ですね。単に列挙すれば良いだけです。

| 000 | 001 | 010 | 011 | 100 | 101 | 110 | 111 |
| -- | -- | -- | -- | -- | -- | -- | -- |

つまり、8バイト分(8つ分)にアドレスを割り振る事ができますね。これらの事象の法則性を考えましょう。

* 1ビットOS: 2 &#8727; 1
* 2ビットOS: 2 &#8727; 2
* 3ビットOS: 2 &#8727; 2 &#8727; 2 ...

となっていますから、要するにこれは**2の乗数で表す事ができる**と考えられますね。

* $$2^1$$
* $$2^2$$
* $$2^3$$ ...

では、32ビットの場合どうなるでしょうか。数式は以下となりますね。

$$2^{32}$$

これを計算すると、`4294967296`となります。この数値の単位は**バイト**です。順番にギガバイトへ単位を変換していきます。バイトをキロバイトに変換するためには、`1024`で除算すれば良いのです。(これについては慣習的な単語の使われ方と単位に関する正確な規格の狭間を行くかのような事を言っています。つまり、厳密に言うとこの言われ方は正しくないのです。これについては、後述しています。）

$$4294967296/1024$$

この数式では、`4194304`という数値が得られます。これは、単位としてはキロバイトです。それでは次にメガバイトへ変換しましょう。メガバイトへ変換するには更に`1024`で除算します。

$$4194304/1024$$

この数式では`4096`という数値が得られます。単位としてはメガバイトです。それでは最後にギガバイトへ変換しましょう。ギガバイトへ変換するには更に`1024`で除算します。

$$4096/1024$$

この数式では`4`という数値が得られます。単位はギガバイトです。ここで、やっと謎か解けたでしょうか。つまり、冒頭で述べた「**32ビットOSではメモリー容量を4GBまでしか読み込めない**」というのはこういった事情から起因しているのです。よって、ポインターが環境によって変動する理由の結論は、**ポインターの中に入る数値が32ビットで表せるアドレス範囲の数値なのか、64ビットで表せるアドレス範囲の数値なのかに起因している**からなのです。
この結論から、要するにポインター自体がどれだけの領域を有するのかさえ調べてしまえば、(実際のコードではsizeofで調べたように)そのコンピューターに搭載されたOSが何ビットなのか知る事ができるという事ですね。

#### 厳密な単位定義

バイトをキロバイトに変換し、その後メガバイト、ギガバイトへと変換しました。バイト、キロバイト、メガバイト、ギガバイトというのは単位の単語ですね。しかし、この場合、厳密に言うと実は使われ方としては正しくないのです。(国際標準規格 JIS Z8203「国際単位系 (SI) 及びその使い方」より。)
正確には、キロバイトとは**キビバイト**、メガバイトとは**メビバイト**、ギガバイトとは**ギビバイト**の事を示して今までこの単語を用いてきました。それぞれの単位/単語は、`1024`を単位として使う時の、バイト単位に対する上位単位です。

元々、**キロ**という単語は、`1000`を単位として使う単語です。これは、確かに10進数表記が普遍的に使われる社会ではとても使いやすい区切りと言えます。しかし、コンピューターは主に2進数を基準として処理をしますから10進数で言うところの`1000`では、単位としての区切りが悪いのです。そこでコンピューター寄りの単位で考える時、慣習的に$$2^{10}$$(つまり1024)を1単位としてみなして、`1024`バイトを`1`**キロ**バイトとみなすのです。しかしそれだと**キロ**という単位は`1000`と`1024`の異なる数字を表す事になり、10進数と2進数の**キロ**という単位には24の誤差が出てしまう事になるのです。考え方によって異なる意味合いを持つ同じ単語を、厳密な単位の単語として用いるべきではありませんね。そこで標準規格では、既存の各単位に2進数を表わす「バイナリー(binary)」を付けて表す事としました。例えば、$$2^{10}$$(つまり1,024)は、キロバイナリー(Kilobinary、別名：キビ(Kibi))です。
この決まりによって、1000バイトは1キロバイト(1KB)、1024バイトは1キビバイト(1KiB)と区別できるようになりました。

...が、これらの単位は一般には普及しておらず、1000の乗数と1,024の乗数の区別なしに、キロバイト、メガバイト…という単位が用いられているのです。


### 7.1.6 ポインターへのポインターの利用
ここまででポインター自体について詳しく見てきましたが、まだ実際にはそのポインターを使ってはいませんでしたね。使ってみましょう。
```cpp
#include<iostream>
int main()
{
    int a = 42;
    int* a_ptr = &a;
    int** a_pptr = &a_ptr;

    **a_pptr = 100;
    std::cout<< a << std::endl <<
        *a_ptr << std::endl <<
        **a_pptr << std::endl;
}
```
実行結果は以下となります。
```cpp
100
100
100
```
`a`は`42`で初期化されています。そのアドレスを`a_ptr`が指しています。そして`a_ptr`のアドレスを`a_pptr`が指しています。そして、`a_pptr`に対して`*`演算子を2つ使っています。すると、まず、`a_pptr`は`a_ptr`を指していますからそれにアクセスします。そして、`a_ptr`は`a`を指していますのでそこに`100`を代入する事で全ての出力が`100`となります。全て同じメモリーの場所をアクセスしているのですから、当然ですね。それでは、以下のように記述した場合、どのような実行結果が得られでうでしょうか。
```cpp
#include<iostream>
int main()
{
    int a=42;
    int* a_ptr=&a;
    int** a_pptr=&a_ptr;

    int b=50;
    *a_pptr=&b;

    std::cout<< a << std::endl <<
        *a_ptr << std::endl <<
        **a_pptr << std::endl;
}
```
実行結果は以下となります。
```cpp
42
50
50
```
`*a_pptr=&b;`の部分で訳がわからなくなるかもしれませんが、順番に考えていけば理解できるはずです。元々、`a_pptr`はポインターへのポインターなのです。ですから、`*`を1つ使った場合に入れる値もアドレスのはずです。そしてそのアドレスは元々、変数`a`を指している`a_ptr`でした。しかし、`*a_pptr`(つまりa_ptr)、に変数`b`のアドレスを代入していますので、`*a_ptr`と`**a_pptr`は最終的に変数`b`を辿る事となり、`50`が二度出力されるのです。

## 7.2 配列
「2.4 配列を触ってみる」にて配列には少し触れましたね。ここでは、更に深く配列について触れていきます。まずは配列の特徴を捉えるために、配列を定位してその各要素のアドレスを見てましょう。
```cpp
#include<iostream>
int main()
{
    int array[5];
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
    std::cout<< &array[i] <<std::endl;
}
```
実行結果は例のごとく実行時/実行環境によって左右しますが、ある特徴があるのです。筆者の環境では以下のように出力されました。
```cpp
0x7fff503b8590
0x7fff503b8594
0x7fff503b8598
0x7fff503b859c
0x7fff503b85a0
```
配列`array`のそれぞれの要素のアドレス値が出力されています。この時、アドレスのそれぞれの末尾を見比べて見てください。
```
0x...8590
0x...8594
0x...8598
0x...859c
0x...85a0
```
`90`、`94`、`98`...というように`4`バイトずつそれぞれが領域を使っていてかつ順序良く並んでいる事に気付きましたでしょうか。何故`4`バイトずつなのでしょうか。それは、`int`型だからです。配列の型を、例えば`char`型にしてもう一度見て見ましょう。(`static_cast`については今は気にしなくても大丈夫です)
```cpp
#include<iostream>
int main()
{
    char array[5];
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
        std::cout<< static_cast<void*>(&array[i]) <<std::endl;
}
```
筆者の環境では以下のように出力されました。
```cpp
0x7fff5cfbb597
0x7fff5cfbb598
0x7fff5cfbb599
0x7fff5cfbb59a
0x7fff5cfbb59b
```
末尾の数値を見てください。`char`型は1バイトの領域を使うためそれぞれの要素が1バイトずつ綺麗に並んでいる事が分かります。このように配列を宣言すると、論理的には、**その要素は必ず順序良く並んでメモリ上に置かれます**。では次に、以下のコードを見て見ましょう。
```cpp
#include<iostream>
int main()
{
    int array[5];
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
        std::cout<< &array[i] <<std::endl;

    std::cout<<"----------------"<<std::endl;
    
    for(unsigned int i=0; i<sizeof(array)/sizeof(array[0]); ++i)
        std::cout<< &array[0]+i << std::endl;
}
```
筆者の環境では以下のように出力されました。
```cpp
0x7fff56311590
0x7fff56311594
0x7fff56311598
0x7fff5631159c
0x7fff563115a0
----------------
0x7fff56311590
0x7fff56311594
0x7fff56311598
0x7fff5631159c
0x7fff563115a0
```
上の結果がそれぞれの要素のアドレスです。下は、なんとアドレスに対して変数`i`を加算しています。アドレスに数値を足すと一体どういったことが起きるのでしょうか。
```cpp
int main()
{
    int array[5];
    &array[0]+1;
}
```
これは、**`array[0]`のアドレスから`4`バイト分先のアドレスへアクセスする**という意味になるのです。先ほど、配列を宣言すると順序良くそのデータ型サイズ分をあけて並べられると述べました。よって`array[0]`のアドレスに対して`1`を加算することで実際には`array[1]`のデータへアクセスする事ができるのです。つまり`array[数値]`は、`&array[0]+数値`と同じ場所を示しているという事になります。今回は、配列`array`が`int`型の配列であると宣言されているため、`1`を加算すると`array[0]`のアドレスから4バイト分先のアドレスへ進みますが、配列の型が例えば`char`型だった場合、`1`を加算した時に進むバイト数は`1`バイトです。このように、型によって適切に次の要素へ進めるようになっているのです。
```cpp
#include<iostream>
int main()
{
    int array[]={1,2,3,4,5};
    int* ptr = &array[0]+1;
    std::cout<< *ptr <<std::endl;
}
```
実行結果は以下となります。
```cpp
2
```
`array[0]`のアドレスから1要素分(4バイト)進んだ先、つまり`array[1]`のアドレスを`ptr`というポインタに代入しています。それを出力しているのですから、`2`が出力されますね。

### 7.2.1 配列の概念から考えるポインタごとの型の必要性

そもそも、ここまででポインターの変数型は全て32ビットであれば4バイト、64ビットであれば8バイトであると述べました。「サイズが全て同じであるならポインタの型は何でも良いじゃないか！」と思うかもしれません。しかしそれにはここまでに述べてきた通り、**何型のポインタなのか**を適切に指定しなければ、そのデータの実体の1単位の区切りを適切にコンピュータは知り得る事ができません。またそのような理由から、アドレスに対して`1`を加算した時、その型のバイト数分を進む事ができないのです。(reinterpret_castについては気にしなくても大丈夫です)
```cpp
#include<climits>
#include<iostream>
int main()
{
    int array[]={INT_MAX,42};
    char* ptr=reinterpret_cast<char*>(&array[0]); // int型のデータがある領域のアドレスを強引にchar型のポインターへ代入
    std::cout<< *(ptr+1) << std::endl; // うまく動かない
}
```
このプログラムは、正しく動作しません。`int`型は一つにつき`4`バイトのサイズを使います。よってそのアドレスに+1された場合、`4`バイト分進まなければ次の要素にアクセスする事はできません。しかし、`char`型のポインタ型に強引に代入してアクセスした事で、`1`バイト分のデータを読み取ろうとしてしまいます。また、+1しても進むのは`4`バイト分ではなく、`1`バイトのため、正しくアクセスする事はできないのです。このために、各型に対するポインタ型というものが必要となるのです。
```cpp
#include<iostream>
int main()
{
    int array[]={1,2};
    int* ptr=&array[0]; // int型へのポインターとして宣言、array[0]のアドレスで初期化
    std::cout<< *(ptr+1) << std::endl; // 2が出力される。
}
```

### 7.2.2 配列とポインタの関係性
以下のように記述すると何が出力されるでしょうか。
```cpp
#include<iostream>
int main()
{
    int array[2];
    std::cout << &array[0] << std::endl;
    std::cout << array << std::endl;
}
```
筆者の環境では以下のように出力されました。
```cpp
0x7fff5daba5a0
0x7fff5daba5a0
```
同じ値が出力されていますね。そうです、実は宣言された配列名を添え字([])無しに使うと配列の先頭アドレスへを表すため、全く同じ数値が得られます。つまり、このように使うこともできますね。
```cpp
#include<iostream>
int main()
{
    int array[]={10,20};
    std::cout << array[1] << std::endl;
    std::cout << *(&array[0]+1) << std::endl;
    std::cout << *(array+1) << std::endl;
}
```
実行結果は以下となります。
```cpp
20
20
20
```
記述法の関係性が見えてきましたでしょうか。つまり、`配列名[添え字]`は`*(配列名+添え字)`と同じという事です。ここで、`*(添え字+配列)`は同じになるでしょうか。当然ながら、同じです。加算の場合、数値を入れ替えてもその演算結果は変わりませんね。では、`添え字[配列名]`は同じになるでしょうか。実はこれも、同じになるのです。
```cpp
#include<iostream>
int main()
{
    int array[]={10,20};
    std::cout << *(1+array) << std::endl;
    std::cout << 1[array] << std::endl;
}
```
実行結果は以下となります。
```cpp
20
20
```
`1[array]`という不思議な記述がありますが、先程も述べた通り、これは文法的には全く問題のない記述なのです。ただ、単純に視覚的な意味で分かりにくいので、あまりこのような記述をわざわざする機会はありません。

### 7.2.3 多次元配列


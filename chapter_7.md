# 第 7 章 ポインター、配列、参照
本章ではポインターと参照について説明します。この二つの概念はC++言語の最も重要な概念の1つと言えます。またポインターと参照は強い結びつきがあり、同時に学ぶ事でその関係性に気付けるでしょう。またこの章をマスターした暁には、今までよりもずっと効率的なプログラムを書けるようになるでしょう。
この章では以下の様な流れで説明していきます。

* ポインターの概念
* 配列の概念
* 参照の概念
    * lvalue reference
    * rvalue reference
* ムーブセマンティックス
    * glvalueとrvalue
    * lvalue、xvalue、prvalue

## 7.1 ポインター
まず、ポインターとは、単純に英語単語から考えて、どういう意味でしょうか。ポインターはポイント(point)をする者ですね。つまり、ポインター(pointer)とは何かを指し示すものなのです。誰もが使う身近なものから例えると、デスクトップなどにあるショートカットアイコンが良い例です。例えば何かブラウザのショートカットアイコンをダブルクリックすると、そのブラウザが起動しますね。しかしショートカット自体は、アプリケーションの実体ではありません。実体のアプリケーションの居場所を指し示しているのです。当然の事を、何を言っているのだと思うかもしれません。しかし、分からなくなってしまったら、この事を思い出して見てください。少し頭の中で整理できるかもしれませんから。

### 7.1.1 メモリアドレス
「第1章 基礎知識」で触れたように、コンピューターにはメモリーと言われる装置があります。メモリーは1バイト単位で区分けされていて、そのそれぞれに**アドレス**が割り当てられています。**アドレス**は実際には数値です。この章までのサンプルコードで何度も様々な変数や関数などの宣言/定義などを行ってきましたが、それらは全てメモリ上のどこかのアドレスに格納されているのです。これは、「6.2.3 メモリ領域」でも少し触れました。実は、このアドレスを実際に見る事ができるのです。コードは以下となります。
```cpp
#include<iostream>
int main()
{
    int a;
    std::cout<<&a<<std::endl;
}
```
`&`演算子によってアドレスを取得する事ができます。尚、実行結果は実行時/実行環境によって変動します。何故かというと、どこのアドレスへ領域を確保するかはその時々によってCPUが勝手に判断するためです。しかし何やら、よく分からない数値が出力されたと思います。それが、変数`a`が領域確保されたメモリ上のアドレスなのです。ここで、変数`a`がどれぐらいの領域を`&a`で出力されたメモリから使っているのか少し調べて見ましょう。まず、`sizeof`で`int`型のサイズを見て見ます。(int型のサイズは規格によって定められておらず、環境によって変動します。)
```cpp
#include<iostream>
int main()
{
    int a;
    std::cout<<sizeof(a)<<std::endl;
}
```
筆者の環境では以下のように出力されました。
```cpp
4
```
便宜上、ここでは`int`型を4バイトとして話を進めます。先ほどメモリーは1バイト単位で区切られていると述べました。という事はつまり、変数`a`は**論理的には**`&a`で出力された値から4バイト分を使っているという事になりますね。...さて、理解を深めるためにさらに以下のコードを見て見ましょう。`static_cast`については今は気にしなくても大丈夫です。
```cpp
#include<iostream>
int main()
{
    char a;
    double b;
    std::cout<<sizeof(a)<<std::endl;
    std::cout<<sizeof(b)<<std::endl;
    std::cout<<static_cast<void*>(&a)<<std::endl;
    std::cout<<&b<<std::endl;
}
```
筆者の環境では以下のように出力されました。(`char`型は必ず1バイトです。)
```cpp
1
8
0x7fff53a1558f
0x7fff53a15580
```
`char`型は1バイトです。なので、この時変数`a`はアドレス、`0x7fff53a1558f`を使います。`double`型は8バイトと出力されました。なのでこの時、変数`b`は`0x7fff53a15580`から`0x7fff53a15588`までを使うという事になります。今の所はなんとなくメモリをどのように占有するのか、イメージが出来れば大丈夫です。

### 7.1.2 ポインターの基本
変数のアドレスを`&`演算子によって得る事ができました。
```cpp
int main()
{
    int a=42;
    &a; // アドレス取得
}
```
アドレスはつまりその変数の居場所を示しています。という事は、そのアドレスの居場所を目当てに何か操作すれば変数`a`を使わなくても変数`a`の中身を操作できるという事になりますね。やってみましょう。それには、まず変数`a`のアドレスをメモって置いて、そのアドレスに対して操作をすると良いかもしれません。メモるために、アドレスを格納する用の変数があったら便利ですね。それが、C++にはあります。そして、それをポインターを言うのです。
```cpp
int main()
{
    int a=42;
    int* a_ptr=&a; // アドレスをa_ptrに格納。
}
```
`型* 識別子`とする事で、その型のアドレスを格納するポインターと宣言する事ができます。そして、ポインター(この場合、`a_ptr`)が指している(この場合、変数`a`)値を取得するには以下の様に書きます。
```cpp
#include<iostream>
int main()
{
    int a=42;
    int* a_ptr=&a;
    std::cout<< *a_ptr <<std::endl; // *によって値を取得。
}
```
実行結果は以下となります。
```cpp
42
```
`*`演算子をポインターに付与する事で、そのポインター(この場合`a_ptr`)が指している(この場合、変数`a`)値を取得する事ができます。という事は、`a_ptr`は変数`a`のアドレスを挿しているのですから、変数`a`の値を変えた場合、`a_ptr`から取得できる値も変わるという事です。**メモリの同じ場所にあるデータを別のモノから見ようとしているだけ**なのですから、当然ですね。
```cpp
#include<iostream>
int main()
{
    int a=42; // aを42で初期化
    int* a_ptr=&a; // aのアドレスを格納
    std::cout<< *a_ptr <<std::endl; // aのアドレスにある値を見る

    a=50; // aに50を代入
    std::cout<< *a_ptr <<std::endl; // するとaと同じアドレスを見ているのだから50が得られる
}
```
実行結果は以下となります。
```cpp
42
50
```
逆に、ポインターを使って、そのポイントしている場所へ値を代入する事もできます。
```cpp
#include<iostream>
int main()
{
    int a;
    int* a_ptr=&a;

    *a_ptr=42; // ポインタを使ってaと同じところに値42を代入
    std::cout<< a <<std::endl;
    *a_ptr=50; // 同じ
    std::cout<< a <<std::endl;
}
```
実行結果は以下となります。
```cpp
42
50
```
実際の値の代入にも`*`演算子を使います。この関係性が分かれば、とても良い調子で理解できていると言えます。ちなみに、以下の様にすると何が出力されるでしょうか。
```cpp
#include<iostream>
int main()
{
    int a=42;
    int* a_ptr=&a;
    std::cout<< a_ptr <<std::endl; // * 演算子がない
}
```
これははたまた実行時/実行環境によって変動します。何故ならばその出力された値というのは、単にそのポインターが指しているアドレスだからです。以下の様にして見て見ましょう。
```cpp
#include<iostream>
int main()
{
    int a=42;
    int* a_ptr=&a;
    std::cout<< &a <<std::endl;
    std::cout<< a_ptr <<std::endl;
}
```
出力される値は実行時/実行環境によって変動します。しかし、全く同じ数値が出力されます。この結果から、変数`a`と変数`a_ptr`が全く同じメモリアドレス領域を使っている事が分かるでしょう。また、以下の様な事もできます。
```cpp
#include<iostream>
int main()
{
    int a=10,b=20,c=30;
    int *ptr=&a; // 変数aと同じ場所を指す。
    
    *ptr=100; // aと同じ場所に対して値100を代入
    std::cout<<a<<std::endl; // 100
    
    ptr=&b; // 指す先を変数aからbへ変更。変数bと同じ場所を指す。
    *ptr=200; // bと同じ場所に対して値200を代入
    std::cout<<b<<std::endl; // 200

    ptr=&c; // 指す先を変数bからcへ変更。変数cと同じ場所を指す。
    *ptr=300; // cと同じ場所に対して値300を代入
    std::cout<<c<<std::endl;
}
```
実行結果は以下となります。
```cpp
100
200
300
```
なんと、変数`a`、`b`、`c`を初めにそれぞれ`10`、`20`、`30`として初期化したのに、それぞれの変数に一切直接手をつけずにそれぞれの値を変えてしまいました。ポインターとして宣言されたポインタ変数は、`*`無しで代入する事で指す先のアドレスを変更する事ができます。よって初めに変数`a`のアドレスを持っていたとしてもその後に変数`b`のアドレスを同じポインターにまた代入する事ができるのです。それにより、`ptr`という同じポインタ変数名でありながら、指し示しているアドレスが変わっているのです。そして、`*`演算子を使って実際の値を代入していますから、それぞれの変数の値が変わるのというのはよくよく考えれば当然の事ですね。

### 7.1.3 nullptr
突然ですが、以下に壊滅的なコードを示します。
```cpp
#include<iostream>
int main()
{
    int* ptr;
    std::cout<< *ptr <<std::endl;;
}
```
これをコンパイル、実行してはいけません。ポインタは、何かを指すものです。しかし、このコードでは`ptr`というポインタが何を指すのか示されていません。「4.1.2 不定値」で説明したのと同じ様に、ポインタ変数であっても初期化、代入を行わなかった場合、どんな値が入っているかは規定されていません。つまり、プログラムが使って良いと許可されていない領域のアドレスを示すような値が入っていても、全くおかしくはないのです。C++言語は元々C言語の拡張言語として開発された言語ですが、許可されていないアドレスへのアクセスを行ってしまうというのはC言語時代からあるとても典型的で最も致命的なバグの1つです。これは、絶対的に未然に防がなければなりません。未然に防ぐ手段を考えて見ましょう。問題は、そのポインターが不正なアドレスを持った状態でそのアドレスへ操作を行う事です。では、そのポインターが不正なアドレスを持っているかどうかを確かめ、不正なアドレスでない場合のみ操作を行うとすれば良いのではないでしょうか？実際にやってみましょう。
```cpp
#include<iostream>
int main()
{
    int* ptr=nullptr; // nullptrを入れておく
    if(ptr!=nullptr)std::cout<< *ptr <<std::endl; // ptrはnullptrのままなのでこの一文は実行されない
}
```
`nullptr`は標準規格で予め定められているキーワードです。
一般的に、`null`というワード自体は「空」だとか、「何も初期化されていない」といったニュアンスで使われます。`nullptr`はつまり、「何も初期化されていないポインタ」という意味と捉える事ができます。コードでは、`nullptr`を`int`型のポインター型へ予め代入しています。つまり、`nullptr`は`int`型の数値なのだろうかと考えられるかもしれません。それは実は考え方によっては合っています。ここまでの知識のみだと、`nullptr`自体の仕組みを理解することはできません。ですので今はとにかく、まずは`nullptr`を代入しておく事で、そのポインターが不正なアドレス値を持っていないかどうかを確認する事ができる、と認識してください。`nullptr`の詳細については、「第12章 STLと標準ライブラリ」にて再度取り上げます。

### 7.1.4 ポインターの利用
ここまでで、ポインターの基本を知ったところで一体この機能は何に使えるんだ？と思ったかもしれません。しかも、不正なアドレスを持ったポインタを誤って使ってしまう可能性もありますからただただリスクがあるだけで何も良いところは無いじゃないかと思うかもしれません。しかし、ポインタの概念を使わなければ出来ない事もあるのです。例題として以下のコードを見て見ましょう。
```cpp
#include<iostream>

void swap(int a,int b)
{
    int tmp=b;
    b=a;
    a=tmp;
}

int main()
{
    int a=10,b=20;
    swap(a,b);
    std::cout<<a<<std::endl<<b<<std::endl;
}
```
変数`a`と変数`b`の値を入れ替える`swap`という関数を定義しました。`a`は`10`、`b`は`20`で初期化しています。実行結果は以下となります。
```cpp
10
20
```
残念ながら意図通りに動いていませんね。しかし、何故でしょうか。コードを見る限りやろうとしている事は正しい様に思えます。これを理解するには
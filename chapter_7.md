# 第 7 章 ポインター、配列、参照
本章ではポインターと参照について説明します。この二つの概念はC++言語の最も重要な概念の1つと言えます。またポインターと参照は強い結びつきがあり、同時に学ぶ事でその関係性に気付けるでしょう。またこの章をマスターした暁には、今までよりもずっと効率的なプログラムを書けるようになるでしょう。

* ポインターの概念
* 配列の概念
* 参照の概念
    * lvalue reference
    * rvalue reference
* ムーブセマンティックス
    * glvalueとrvalue
    * lvalue、xvalue、prvalue

## 7.1 ポインター
まず、ポインターとは、単純に英語単語から考えて、どういう意味でしょうか。ポインターはポイント(point)をする者ですね。つまり、ポインター(pointer)とは何かを指し示すものなのです。誰もが使う身近なものから例えると、デスクトップなどにあるショートカットアイコンが良い例です。例えば何かブラウザのショートカットアイコンをダブルクリックすると、そのブラウザが起動しますね。しかしショートカット自体は、アプリケーションの実体ではありません。実体のアプリケーションの居場所を指し示しているのです。当然の事を、何を言っているのだと思うかもしれません。しかし、分からなくなってしまったら、この事を思い出して見てください。少し頭の中で整理できるかもしれませんから。

### 7.1.1 メモリアドレス
「第1章 基礎知識」で触れたように、コンピューターにはメモリーと言われる装置があります。メモリーは1バイト単位で区分けされていて、そのそれぞれに**アドレス**が割り当てられています。**アドレス**は実際には数値です。この章までのサンプルコードで何度も様々な変数や関数などの宣言/定義などを行ってきましたが、それらは全てメモリ上のどこかのアドレスに格納されているのです。これは、「6.2.3 メモリ領域」でも少し触れました。実は、このアドレスを実際に見る事ができるのです。コードは以下となります。
```cpp
#include<iostream>
int main()
{
    int a;
    std::cout<<&a<<std::endl;
}
```
`&`演算子によってアドレスを取得する事ができます。尚、実行結果は実行時/実行環境によって変動します。何故かというと、どこのアドレスへ領域を確保するかはその時々によってCPUが勝手に判断するためです。しかし何やら、よく分からない数値が出力されたと思います。それが、変数`a`が領域確保されたメモリ上のアドレスなのです。ここで、変数`a`がどれぐらいの領域を`&a`で出力されたメモリから使っているのか少し調べて見ましょう。まず、`sizeof`で`int`型のサイズを見て見ます。(int型のサイズは規格によって定められておらず、環境によって変動します。)
```cpp
#include<iostream>
int main()
{
    int a;
    std::cout<<sizeof(a)<<std::endl;
}
```
筆者の環境では以下のように出力されました。
```cpp
4
```
便宜上、ここでは`int`型を4バイトとして話を進めます。先ほどメモリーは1バイト単位で区切られていると述べました。という事はつまり、変数`a`は**論理的には**`&a`で出力された値から4バイト分を使っているという事になりますね。...さて、理解を深めるためにさらに以下のコードを見て見ましょう。`static_cast`については今は気にしなくても大丈夫です。
```cpp
#include<iostream>
int main()
{
    char a;
    double b;
    std::cout<<sizeof(a)<<std::endl;
    std::cout<<sizeof(b)<<std::endl;
    std::cout<<static_cast<void*>(&a)<<std::endl;
    std::cout<<&b<<std::endl;
}
```
筆者の環境では以下のように出力されました。(`char`型は必ず1バイトです。)
```cpp
1
8
0x7fff53a1558f
0x7fff53a15580
```
`char`型は1バイトです。なので、この時変数`a`はアドレス、`0x7fff53a1558f`を使います。`double`型は8バイトと出力されました。なのでこの時、変数`b`は`0x7fff53a15580`から`0x7fff53a15588`までを使うという事になります。今の所はなんとなくメモリをどのように占有するのか、イメージが出来れば大丈夫です。

## 7.1.2 ポインターの基本
変数のアドレスを`&`演算子によって得る事ができました。
```cpp
int main()
{
    int a=42;
    &a; // アドレス取得
}
```
アドレスはつまりその変数の居場所を示しています。という事は、そのアドレスの居場所を目当てに何か操作すれば変数`a`を使わなくても変数`a`の中身を操作できますね。少し面白いかもしれません。やってみましょう。それには、まず変数`a`のアドレスをメモって置くと良いかもしれません。メモるために、アドレスを格納する用の変数があったら便利ですね。それが、C++にはあります。
```cpp
int main()
{
    int a=42;
    int* a_ptr=&a; // アドレスをa_ptrに格納
}
```
`型* 識別子`と、`*`する事で、その型のアドレスを格納するポインターとして宣言する事ができます。そして、a_ptrが指している(この場合、変数`a`)値を取得するには以下の様に書きます。
```cpp
#include<iostream>
int main()
{
    int a=42;
    int* a_ptr=&a;
    std::cout<< *a_ptr <<std::endl; // *によって値を取得。
}
```
実行結果は以下となります。
```
42
```
`*`演算子をポインターに付与する事で、そのポインターが指している(この場合、変数`a`)値を取得する事ができます。という事は、`a_ptr`は変数`a`のアドレスを挿しているのですから、変数`a`の値を変えた場合、`a_ptr`から値を取得できる値も変わるという事です。メモリの同じ部分にある値を別のモノから見ようとしているだけなのですから、当然ですね。
```
#include<iostream>
int main()
{
    int a=42;
    int* a_ptr=&a;
    std::cout<< *a_ptr <<std::endl;

    a=50;
    std::cout<< *a_ptr <<std::endl;
}
```
実行結果は以下となります。
```cpp
42
50
```
逆に、ポインターを使ってポイントしている場所へ値を代入する事もできます。
```cpp
#include<iostream>
int main()
{
    int a;
    int* a_ptr=&a;

    *a_ptr=42; // ポインタを使ってaと同じところに値42を代入
    std::cout<< a <<std::endl;
    *a_ptr=50; // 同じ
    std::cout<< a <<std::endl;
}
```
実行結果は以下となります。
```cpp
42
50
```
この関係性が分かれば、とても良い調子で理解できていると言えます。
# 11.1 関数テンプレート
C++はとても型による制約が頑丈な言語です。その頑丈な型システムによって、プログラマーが無意識のうちに生み出してしまった不用意なバグの根源を見つけ出す事ができるのです。(できない時もあります)。

しかし、この型システムによって、コードが非常に冗長となってしまう例もあります。例えば、以下のようなコードは冗長です。
```cpp
int plus(const int a,const int b)
{
    return a+b;
}
double plus(const double a,const double b)
{
    return a+b;
}
float plus(const float a,const float b)
{
    return a+b;
}
// .....無限に続く
```
C++には頑丈な型システムがあります。どんなものでも保持する事のできる型は一般的に存在しません(それを再現した型はありますがそれは後述しています)。よって、このように、意味合いは異なっても同じ記述で処理を実現できる同じような実装を、型ごとにどんどん増やしていかなければならないのです。プロセスの自動化を図るのがプログラミングであり、それを記述するのがプログラマーです。このような仕様では、プログラミングを自動化してしまいたくなりますね(確かに一部ではそういう取り組みもある)。

大丈夫です、C++は実行時の速度だけでなく、コードの意味合いを明快に深めつつも、記述の冗長性をどんどん省いていく事にとても積極的な言語です。前置きが長くなってしまいましたが、そんなわけで、C++にはとても強力な言語機能、**テンプレート**が存在します。

## 11.1 テンプレート関数の概要
さて、まずはもう先延ばしせずに、どのように使えるのかを示してしまいましょう。
```cpp
template<class T>
void f(T a){}
```
まず、`template`と記述してから`<`と`>`で囲み、その中に推論するテンプレート引数を記述します。テンプレート引数の宣言には`class`か`typename`を使います。つまり、上記のテンプレート引数宣言は以下のように書いても全く同じ意味となります。
```cpp
template<typename T> // classでもtypenameでもどちらでも良い
void f(T a){}
```
そして、そのテンプレート仮引数の名前を、`T`としています。この部分は、今まで通り自身の分かりやすい名前にすることが可能です。この場合は`T`としていますので、テンプレート仮引数名は`T`となります。

さて理解を深めるために、まずは、この機能を使って、先ほどの冗長なコードをテンプレートにして見ましょう。
```cpp
#include<iostream>
template<class T>
T plus(T a,T b)
{
    return a+b;
}
int main()
{
    std::cout<< plus(10,20) <<std::endl;
    std::cout<< plus(10.1,20.1) <<std::endl;
    std::cout<< plus(10.1f,20.1f) <<std::endl;
}
```
実行結果は以下となります。
```cpp
30
30.2
30.2
```
上記のように、もちろん、関数の引数をいくつも設定することが可能です。三度`plus`関数を呼び出していますが、どれも毎回与えている値の型は異なっています。しかし、テンプレートの機能によってそれぞれの型を正しく推論するのでそれぞれ全て正しく処理することができるのです。

また、何気なく`T plus(T a,T b)`というように`plus`の関数宣言の前に`T`とありますが、これは今までと同じように、戻り型を意味しています。型`T`と型`T`の加算結果は、この場合型`T`となりますから戻り型に`T`を指定しているのです。

さて、では

## 11.x ユニバーサル参照
「7.5 参照」や「7.7 ムーブセマンティックス」でも述べたように、C++には様々な参照(リファレンス）が存在します。特にrvalueという概念は特筆すべき内容でした。
```cpp
void f(int&& a)
{
//...
}

int main()
{
    int a=10;
    f(std::move(a));
}
```
`std::move`によってrvalueへキャストする事で、コピーや参照に加えてムーブという概念を新たに取り入れる事ができます。

さて、「7.7 ムーブセマンティックス」までは、上記コードのように、仮引数としてrvalueを受け取る記述をしていましたが、すると**その関数はrvalueしか受け取る事ができない**のです。
```cpp
void f(int&& a)
{
// ...
}
int main()
{
    int a=10;
    f(a); // エラー！aはlvalueなのでrvalue referenceで束縛できない。
}
```
`f`に渡すデータ型が必ずしもrvalueではないかもしれない、lvalueでも渡せるようにしたい、というようであれば、lvalueを受け取れる関数をオーバーロードしなければなりません。
```cpp
void f(int& a) // for lvalue
{
// ...
}
void f(int&& a) // for rvalue
{
// ...
}

int main()
{
    int a=10;
    f(a) // for lvalueを呼び出す
    f(std::move(a)); // for rvalueを呼び出す
}
```
因みに「7.7 ムーブセマンティックス」ではconst lvalue referenceでもrvalueを束縛する事ができると述べました。では、以下のコードはどのように動くでしょうか。
```cpp
void f(const int& a){std::cout<<"const int"<<std::endl;}
void f(int&& a){std::cout<<"int&&"<<std::endl;}
int main()
{
    int a=10;
    f(std::move(a));
}
```
実行結果は以下となります。
```cpp
int&&
```
これは期待通り、rvalue referenceを受けとる方が優先的にオーバーロード解決され呼び出されます。

さてさて、ここからが本題です。ここまで学んできました、テンプレート関数ではどうなるでしょうか。テンプレート関数でもアンパサンドを二つ使って引数型を指定する事ができます。
```cpp
template<class T>
void f(T&& a){}
```
しかし、これはとても興味深い動きをする事となります。以下のコードを見て見てください。
```cpp
#include<type_traits>
#include<iostream>

template<class T>
void f(T&&)
{
	constexpr bool result=std::is_lvalue_reference<T>::value;
	std::cout<<std::boolalpha<<result<<std::endl;
}

int main()
{
	int a=0;
	f(a);
	f(std::move(a));
}
```
`std::is_lvalue_reference`は、推論された型`T`が、lvalueであるかどうかを判定し、lvalueであれば`true`を、そうでなければ`false`を返します。これに関しては、この時点でまだ説明していない概念を含んでいますので、今はそういう機能があるという事だけ認識すれば大丈夫です。
実行結果は以下となります。
```cpp
true
false
```
まず、`T&&`としているのに、`f(a);`というように、lvalueを渡せています。そして、何やらlvalueを渡した時はlvalue型であると推論されたようですが、rvalueを渡した時はlvalue型ではないという判定結果が実行結果から分かります。

これは、今までの理解を疑わせるような、不可思議な挙動ですね！しかし、これは意外と簡単な法則で成り立っています。それは、**推論される型(ここではTとする)がT&&と記述された場合、渡されたデータの型がlvalue(const volatileなどの属性があろうとも)でも、rvalueでも、束縛する事ができる**という法則です。そのようなT&&を**ユニバーサル参照(Universel reference)**と言うのです。
```cpp
template<class T>
void f(T&& param){} // paramはユニバーサル参照
```
要するに、lvalueだろうがrvalueだろうが全て受け取れるというのが、このユニバーサル参照というものです。

ユニバーサル参照の特徴としてとても重要なのが、「**推論される型が**」という部分です。つまり、以下のように型を明記した場合は、ユニバーサル参照とはなれません。
```cpp
void f(int&& param){} // paramはユニバーサル参照ではない
```
何故ならば、`int&&`は推論された型ではなく、プログラマーによって明記された型だからです。よって、このように型を明記しながらlvalueでもrvalueでも受け取れるようにしたい場合は、冒頭で述べたように、新たにlvalueを受け取れる関数を、オーバーロードを利用して定義しなければなりません。
```cpp
void f(int&& param){} // for rvalue
void f(int& param){} // 新たに定義
```
しかし、ユニバーサル参照の形であれば一つの定義でその実装が済む事になります。(テンプレートとした事で`int`型以外の型も素通りさせてしまう事になるため、全く同じ意味合いとはなりません。しかしテンプレートを使ってユニバーサル参照を使いつつ推論させた型に対する制約を設けるテクニックも存在します。それについては、「11.x SFINAE」で述べています。)
```cpp
template<class T>
void f(T&& param){} // paramはユニバーサル参照のためlvalueでもrvalueでも受け取る事ができる。
```

さて、このように型を推論する場面でアンパサンドを二つ記述すると、ユニバーサル参照という特別な参照となる決まりがある事を学びましたが、lvalueとrvalueでそれぞれの実装を分けなくても良い事以外に、一体これは何の役に立つのでしょうか。

## 11.x Perfect forwarding

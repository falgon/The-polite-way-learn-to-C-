# 11.1 関数テンプレート
C++はとても型による制約が頑丈な言語です。その頑丈な型システムによって、プログラマーが無意識のうちに生み出してしまった不用意なバグの根源を見つけ出す事ができるのです。(できない時もあります)。

しかし、この型システムによって、コードが非常に冗長となってしまう例もあります。例えば、以下のようなコードは冗長です。
```cpp
int plus(const int a,const int b)
{
    return a+b;
}
double plus(const double a,const double b)
{
    return a+b;
}
float plus(const float a,const float b)
{
    return a+b;
}
// .....無限に続く
```
C++には頑丈な型システムがあります。どんなものでも保持する事のできる型は一般的に存在しません(それを再現した型はありますがそれは後述しています)。よって、このように、意味合いは異なっても同じ記述で処理を実現できる同じような実装を、型ごとにどんどん増やしていかなければならないのです。プロセスの自動化を図るのがプログラミングであり、それを記述するのがプログラマーです。このような仕様では、プログラミングを自動化してしまいたくなりますね(確かに一部ではそういう取り組みもある)。

大丈夫です、C++は実行時の速度だけでなく、コードの意味合いを明快に深めつつも、記述の冗長性をどんどん省いていく事にとても積極的な言語です。前置きが長くなってしまいましたが、そんなわけで、C++にはとても強力な言語機能、**テンプレート**が存在します。

## 11.1 テンプレート関数の概要
さて、まずはもう先延ばしせずに、どのように使えるのかを示してしまいましょう。
```cpp
template<class T>
void f(T a){}
```
まず、`template`と記述してから`<`と`>`で囲み、その中に推論するテンプレート引数を記述します。テンプレート引数の宣言には`class`か`typename`を使います。つまり、上記のテンプレート引数宣言は以下のように書いても全く同じ意味となります。
```cpp
template<typename T> // classでもtypenameでもどちらでも良い
void f(T a){}
```
そして、そのテンプレート仮引数の名前を、`T`としています。この部分は、今まで通り自身の分かりやすい名前にすることが可能です。この場合は`T`としていますので、テンプレート仮引数名は`T`となります。

さて理解を深めるために、まずは、この機能を使って、先ほどの冗長なコードをテンプレートにして見ましょう。
```cpp
#include<iostream>
template<class T>
T plus(T a,T b)
{
    return a+b;
}
int main()
{
    std::cout<< plus(10,20) <<std::endl;
    std::cout<< plus(10.1,20.1) <<std::endl;
    std::cout<< plus(10.1f,20.1f) <<std::endl;
}
```
実行結果は以下となります。
```cpp
30
30.2
30.2
```
上記のように、もちろん、関数の引数をいくつも設定することが可能です。三度`plus`関数を呼び出していますが、どれも毎回与えている値の型は異なっています。しかし、テンプレートの機能によってそれぞれの型を正しく推論するのでそれぞれ全て正しく処理することができるのです。

また、何気なく`T plus(T a,T b)`というように`plus`の関数宣言の前に`T`とありますが、これは今までと同じように、戻り型を意味しています。型`T`と型`T`の加算結果は、この場合型`T`となりますから戻り型に`T`を指定しているのです。

さて、では

## 11.x ユニバーサル参照
「7.5 参照」や「7.7 ムーブセマンティックス」でも述べたように、C++には様々な参照(リファレンス）が存在します。特にrvalueという概念は特筆すべき内容でした。
```cpp
void f(int&& a)
{
//...
}

int main()
{
    int a=10;
    f(std::move(a));
}
```
`std::move`によってrvalueへキャストする事で、コピーや参照に加えてムーブという概念を新たに取り入れる事ができます。

さて、「7.7 ムーブセマンティックス」までは、上記コードのように、仮引数としてrvalueを受け取る記述をしていましたが、すると**その関数はrvalueしか受け取る事ができない**のです。
```cpp
void f(int&& a)
{
// ...
}
int main()
{
    int a=10;
    f(a); // エラー！aはlvalueなのでrvalue referenceで束縛できない。
}
```
`f`に渡すデータ型が必ずしもrvalueではないかもしれない、lvalueでも渡せるようにしたい、というようであれば、lvalueを受け取れる関数をオーバーロードしなければなりません。
```cpp
void f(int& a) // for lvalue
{
// ...
}
void f(int&& a) // for rvalue
{
// ...
}

int main()
{
    int a=10;
    f(a) // for lvalueを呼び出す
    f(std::move(a)); // for rvalueを呼び出す
}
```
因みに「7.7 ムーブセマンティックス」ではconst lvalue referenceでもrvalueを束縛する事ができると述べました。では、以下のコードはどのように動くでしょうか。
```cpp
void f(const int& a){std::cout<<"const int"<<std::endl;}
void f(int&& a){std::cout<<"int&&"<<std::endl;}
int main()
{
    int a=10;
    f(std::move(a));
}
```
実行結果は以下となります。
```cpp
int&&
```
これは期待通り、rvalue referenceを受けとる方が優先的にオーバーロード解決され呼び出されます。

さてさて、ここからが本題です。ここまで学んできました、テンプレート関数ではどうなるでしょうか。テンプレート関数でもアンパサンドを二つ使って引数型を指定する事ができます。
```cpp
template<class T>
void f(T&& a){}
```
しかし、これはとても興味深い動きをする事となります。以下のコードを見て見てください。
```cpp
#include<type_traits>
#include<iostream>

template<class T>
void f(T&&)
{
	constexpr bool result=std::is_lvalue_reference<T>::value;
	std::cout<<std::boolalpha<<result<<std::endl;
}

int main()
{
	int a=0;
	f(a);
	f(std::move(a));
}
```
`std::is_lvalue_reference`は、推論された型`T`が、lvalueであるかどうかを判定し、lvalueであれば`true`を、そうでなければ`false`を返します。これに関しては、この時点でまだ説明していない概念を含んでいますので、今はそういう機能があるという事だけ認識すれば大丈夫です。
実行結果は以下となります。
```cpp
true
false
```
まず、`T&&`としているのに、`f(a);`というように、lvalueを渡せています。そして、何やらlvalueを渡した時はlvalue型であると推論されたようですが、rvalueを渡した時はlvalue型ではないという判定結果が実行結果から分かります。

これは、今までの理解を疑わせるような、不可思議な挙動ですね！しかし、これは意外と簡単な法則で成り立っています。それは、**推論される型(ここではTとする)がT&&と記述された場合、渡されたデータの型がlvalue(const volatileなどの属性があろうとも)でも、rvalueでも、束縛する事ができる**という法則です。そのようなT&&を**ユニバーサル参照(Universel reference)**と言うのです。
```cpp
template<class T>
void f(T&& param){} // paramはユニバーサル参照
```
要するに、lvalueだろうがrvalueだろうが全て受け取れるというのが、このユニバーサル参照というものです。

ユニバーサル参照の特徴としてとても重要なのが、「**推論される型が**」という部分です。つまり、以下のように型を明記した場合は、ユニバーサル参照とはなれません。
```cpp
void f(int&& param){} // paramはユニバーサル参照ではない
```
何故ならば、`int&&`は推論された型ではなく、プログラマーによって明記された型だからです。よって、このように型を明記しながらlvalueでもrvalueでも受け取れるようにしたい場合は、冒頭で述べたように、新たにlvalueを受け取れる関数を、オーバーロードを利用して定義しなければなりません。
```cpp
void f(int&& param){} // for rvalue
void f(int& param){} // 新たに定義
```
しかし、ユニバーサル参照の形であれば一つの定義でその実装が済む事になります。(テンプレートとした事で`int`型以外の型も素通りさせてしまう事になるため、全く同じ意味合いとはなりません。しかしテンプレートを使ってユニバーサル参照を使いつつ推論させた型に対する制約を設けるテクニックも存在します。それについては、「11.x SFINAE」で述べています。)
```cpp
template<class T>
void f(T&& param){} // paramはユニバーサル参照のためlvalueでもrvalueでも受け取る事ができる。
```

さて、このように型を推論する場面でアンパサンドを二つ記述すると、ユニバーサル参照という特別な参照となる決まりがある事を学びましたが、lvalueとrvalueでそれぞれの実装を分けなくても良い事以外に、一体これは何の役に立つのでしょうか。

## 11.x Perfect forwarding
さて、ではまずユニバーサル参照でない場合の例から考えて見ましょう。まず、例えば関数`f`がrvalueを受け取る関数だとします。
```cpp
void f(int&&);
```
関数`f`は関数`g`に呼ばれるとします。
```cpp
void g(int&& a)
{
    f(/* aを渡す */);
}
```
この時、関数`g`にrvalueを渡すためには、`a`を`rvalue`にしなければなりません(何度も述べていますが、`a`の型はrvalue referenceですが、`a`自体はlvalueです。)。そのためには、`std::move`を使います。
```cpp
void f(int&&){}
void g(int&& a)
{
    f(std::move(a)); // aをrvalue referenceにして渡す。転送。
}
int main()
{
    int a=10;
    g(std::move(a));
}
```
この時、起動される関数`g`の受け付ける引数型は`int&&`であるため、引数にはrvalueのみが渡されるとわかりきっています。なので、何も考えずに全てをrvalueへ変換し、転送してしまっても構わないという事となりますので単純です。

さて、では次にユニバーサル参照である場合を考えて見ましょう。先ほどと同じような構造で、関数`g`が関数`f`を呼び出します。
```cpp
template<class T>
void f(T&&){}
template<class T>
void g(T&& a)
{
    f(/* aを渡す */);
}
```
ユニバーサル参照は前述したように、lvalueだろうがrvalueだろうがなんでも渡せます。ではこの場合でも、rvalueが渡ってきた時を考えて、`a`を渡す際にムーブして置きましょう。
```cpp
template<class T>
void f(T&&){}
template<class T>
void g(T&& a)
{
    f(std::move(a)); // はいはい、ムーブムーブ！
}
```
もう一度言いますが、ユニバーサル参照はlvalueだろうがrvalueだろうがどちらでも渡す事ができます。rvalueが渡った場合はこのコードでも大丈夫ですが、もしlvalueが渡ってきた場合は、恐らく意図しない動作となるでしょう。
```cpp
template<class T>
void f(T&&){}
template<class T>
void g(T&& a)
{
    f(std::move(a));
}
int main()
{
    int a=10,b=10;
    g(std::move(a)); // aをムーブしている事を明記。この後にaを使った場合の動作は未定義。プログラマの意識下にムーブがあるので良い。
    g(b); // bはムーブしていないように見えるが、関数g内でムーブされてしまうため、この後にbを使った場合の動作は未定義になる。プログラマの意識下にムーブはない。
}
```
このように、lvalueを渡した場合、ムーブなど行っていないつもりなのに内部でムーブが行われてしまうため未定義動作に繋がってしまうのです。問題を解決するためには、テンプレートで推論された型がlvalue referenceであればムーブせず(lvalueのまま)、rvalue referenceであればムーブする(rvalueにする)という動作です。それを実現した機能というのが、`std::forward`であり、ユニバーサル参照によって実現できる汎用的で効率的な記述法なのです。
```cpp
template<class T>
void f(T&&){}
template<class T>
void g(T&& a)
{
    f(std::forward<T>(a)); // 型がlvalue referenceならlvalueのまま、rvalue referenceならrvalueへキャストし関数fに渡す
}
int main()
{
    int a=10,b=10;
    g(std::move(a)); // ムーブ。rvalueとして機能する。
    g(b); // ムーブしていない。lvalueとして機能する。
}
```
このようにして、渡されたオブジェクトの型を認識して、余計な一時オブジェクトやリファレンスの実態を作る事なく最後の呼び出し(上記コードでは関数`f`)まで到達させる事を、**Perfect Forwarding**と言います。

ところで、この`std::forward`、まるで魔法のように思えるかもしれませんが、実装は以下のようになっています。
```cpp
template<class T>
T&& forward(std::remove_reference_t<T>& param)
{
    return static_cast<T&&>(param);
}
```
`std::remove_reference_t`という見たことのない機能が書かれていますが、この機能についてはまだ触れていない概念を含んでいるため深くは突っ込んで説明しませんが、簡単に言えば、型からリファレンスを削除する機能です。
```cpp
int main()
{
    std::remove_reference_t<int&> a; // aはint型
}
```
`<>`内に指定された型から参照を全て取り除きます。これについては、現時点では深く理解しなくとも大丈夫ですが、参照を取り除くものだと認識はしてください。

さて話は戻って、`forward`の型による処理の分岐を理解するためには、参照の圧縮というものを理解しなければなりません。
参照の圧縮とは、テンプレートが推論される流れを追っていく事で理解が容易くなります。以下のように、関数`f`に対して実行するとした時の、テンプレートの型推論を順を追って見て見ましょう。
```cpp
template<class T>
void f(T&& param){}

int main()
{
    int a=0;
    f(a);
}
```
この時、関数`f`はまず以下のように推論されます。
```cpp
template<class T>
void f(int& && param){}
```
参照の参照というような見たことのない形となりました。通常、私たちが参照の参照をコードで記述することは、言語規格で許されていません。しかし、このようにユニバーサル参照のテンプレートを推論する段階で、一時的に内部表現として参照の参照を用いることは許されているのです。参照の参照が許されるということは、参照の種類は四種類になる事となります(lvalue referenceのlvalue reference、rvalue referenceのlvalue reference、lvalue referenceのrvalue reference、rvalue referenceのrvalue reference)。ただ、やはり推論が完全に完了する頃には参照の参照をなくし、最終的なシグネチャとして確立しなければならないので、その時に、参照の圧縮というルールが適用されます。参照の圧縮ルールを以下に示します。

* 二つある参照のいずれかがlvalue referenceであれば、圧縮結果はlvalue referenceとなる。いずれともlvalue referenceでなかった場合、rvalue referenceとなる。

さて、このルールを頭に置いて置きつつ、先ほど述べた`forward`関数を使って見ましょう。
```cpp
template<class T>
T&& forward(std::remove_reference_t<T>& param)
{
    return static_cast<T&&>(param);
}

int main()
{
    int a;
    forward(a);
}
```
`forward`は、以下のように推論されます。
```cpp
int& && forward(std::remove_reference_t<int&>& param)
{
    return static_cast<int& &&>(param);
}
```
`a`はlvalueですから、この時`T`はlvalue referenceとして推論されます。ここで、`remove_reference_t`の適用結果を以下に示します。
```cpp
int& && forward(int & param)
{
    return static_cast<int& &&>(param);
}
```
`remove_reference_t<int&>&`によって、`int&`から参照が削除され、`int`となりますが、その後`&`が付いていますので、再度`int&`となります。

ここから、参照の圧縮のルールの基、圧縮を行いましょう。
```cpp
int& forward(int& param)
{
    return static_cast<int&>(param);
}
```
これで、全ての型推論、実体化が完了しました！このように、lvalue referenceを渡した時は、lvalue referenceが返されるようになりましたね。

では次に、`forward`に対して、rvalueを渡して見ましょう。
```cpp
template<class T>
T&& forward(std::remove_reference_t<T>& param)
{
    return static_cast<T&&>(param);
}

int main()
{
    int a;
    forward(std::move(a)); // aはrvalueへキャストされforwardへ渡す
}
```

# 11.1 関数テンプレート
C++はとても型による制約が頑丈な言語です。その頑丈な型システムによって、プログラマーが無意識のうちに生み出してしまった不用意なバグの根源を見つけ出す事ができるのです。(できない時もあります)。

しかし、この型システムによって、コードが非常に冗長となってしまう例もあります。例えば、以下のようなコードは冗長です。
```cpp
int plus(const int a,const int b)
{
    return a+b;
}
double plus(const double a,const double b)
{
    return a+b;
}
float plus(const float a,const float b)
{
    return a+b;
}
// .....無限に続く
```
C++には頑丈な型システムがあります。

## ユニバーサル参照
「7.5 参照」や「7.7 ムーブセマンティックス」でも述べたように、C++には様々な参照(リファレンス）が存在します。特にrvalueという概念は特筆すべき内容でした。
```cpp
void f(int&& a)
{
//...
}

int main()
{
    int a=10;
    f(std::move(a));
}
```
`std::move`によってrvalueへキャストする事で、コピーや参照に加えてムーブという概念を新たに取り入れる事ができます。

さて、「7.7 ムーブセマンティックス」までは、上記コードのように、仮引数としてrvalueを受け取る記述をしていましたが、すると**その関数はrvalueしか受け取る事ができない**のです。
```cpp
void f(int&& a)
{
// ...
}
int main()
{
    int a=10;
    f(a); // エラー！aはlvalueなのでrvalue referenceで束縛できない。
}
```
`f`に渡すデータ型が必ずしもrvalueではないかもしれない、lvalueでも渡せるようにしたい、というようであれば、lvalueを受け取れる関数をオーバーロードしなければなりません。
```cpp
void f(int& a) // for lvalue
{
// ...
}
void f(int&& a) // for rvalue
{
// ...
}

int main()
{
    int a=10;
    f(a) // for lvalueを呼び出す
    f(std::move(a)); // for rvalueを呼び出す
}
```
因みに「7.7 ムーブセマンティックス」ではconst lvalue referenceでもrvalueを束縛する事ができると述べました。では、以下のコードはどのように動くでしょうか。
```cpp
void f(const int& a){std::cout<<"const int"<<std::endl;}
void f(int&& a){std::cout<<"int&&"<<std::endl;}
int main()
{
    int a=10;
    f(std::move(a));
}
```
実行結果は以下となります。
```cpp
int&&
```
これは期待通り、rvalue referenceを受けとる方が優先的にオーバーロード解決され呼び出されます。

さてさて、ここからが本題です。ここまで学んできました、テンプレート関数ではどうなるでしょうか。テンプレート関数でもアンパサンドを二つ使って引数型を指定する事ができます。
```cpp
template<class T>
void f(T&& a){}
```
しかし、これはとても興味深い動きをする事となります。以下のコードを見て見てください。
```cpp
#include<type_traits>
#include<iostream>

template<class T>
void f(T&&)
{
	constexpr bool result=std::is_lvalue_reference<T>::value;
	std::cout<<std::boolalpha<<result<<std::endl;
}

int main()
{
	int a=0;
	f(a);
	f(std::move(a));
}
```
`std::is_lvalue_reference`は、推論された型`T`が、lvalueであるかどうかを判定し、lvalueであれば`true`を、そうでなければ`false`を返します。これに関しては、この時点でまだ説明していない概念を含んでいますので、今はそういう機能があるという事だけ認識すれば大丈夫です。
実行結果は以下となります。
```cpp
true
false
```
まず、`T&&`としているのに、`f(a);`というように、lvalueを渡せています。そして、何やらlvalueを渡した時はlvalue型であると推論されたようですが、rvalueを渡した時はlvalue型ではないという判定結果が実行結果から分かります。

これは、今までの理解を疑わせるような、不可思議な挙動ですね！しかし、これは意外と簡単な法則で成り立っています。それは、**推論される型(ここではTとする)がT&&と記述された場合、渡されたデータの型がlvalue(const volatileなどの属性があろうとも)でも、rvalueでも、束縛する事ができる**という法則です。そのようなT&&を**ユニバーサル参照(Universel reference)**と言うのです。
```cpp
template<class T>
void f(T&& param){} // paramはユニバーサル参照
```
要するに、lvalueだろうがrvalueだろうが全て受け取れるというのが、このユニバーサル参照というものです。

ユニバーサル参照の特徴としてとても重要なのが、「**推論される型が**」という部分です。つまり、以下のように型を明記した場合は、ユニバーサル参照とはなれません。
```cpp
void f(int&& param){} // paramはユニバーサル参照ではない
```
何故ならば、`int&&`は推論された型ではなく、プログラマーによって明記された型だからです。よって、このように型を明記しながらlvalueでもrvalueでも受け取れるようにしたい場合は、冒頭で述べたように、新たにlvalueを受け取れる関数を、オーバーロードを利用して定義しなければなりません。
```cpp
void f(int&& param){} // for rvalue
void f(int& param){} // 新たに定義
```
しかし、ユニバーサル参照の形であれば一つの定義でその実装が済む事になります。(テンプレートとした事で`int`型以外の型も素通りさせてしまう事になるため、全く同じ意味合いとはなりません。しかしテンプレートを使ってユニバーサル参照を使いつつ推論させた型に対する制約を設けるテクニックも存在します。それについては、「11.x SFINAE」で述べています。)
```cpp
template<class T>
void f(T&& param){} // paramはユニバーサル参照のためlvalueでもrvalueでも受け取る事ができる。
```

さて、このように型を推論する場面でアンパサンドを二つ記述すると、ユニバーサル参照という特別な参照となる決まりがある事を学びましたが、lvalueとrvalueでそれぞれの実装を分けなくても良い事以外に、一体これは何の役に立つのでしょうか。

## Perfect forwarding

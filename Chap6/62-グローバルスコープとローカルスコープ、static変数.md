## 6.2 グローバルスコープとローカルスコープ、static変数

この項ではスコープという概念について説明します。今まで変数を宣言/定義する時、全て関数の中に記述をしてきました。

```cpp
int main(){ int x;}
```
実は、関数外にも変数を宣言する事ができるのです。

```cpp
int x;
int main(){}
```
この時、変数`x`はグローバルスコープにあると言えます。ではローカルスコープとはどのような事を言うのでしょうか。それは、以下のような時を言います。

```cpp
int main()
{
    int x;
}
```
変数`x`は`main`関数というローカルスコープにあると言えます。たったこれだけの事です。たったこれだけの事なのですが、実は両者は全くの別物なのです。

### 6.2.1 ローカルスコープ
まず、グローバルスコープの理解のためにローカルスコープを説明します。前述した通りローカルスコープとは、例えば以下のような事を言います。
```cpp
int main()
{
    int x=10;
}
```
この場合、他のスコープからは`main`関数内の変数`x`を見つける事はできません。
```cpp
int f();
int main()
{
    int x=10;
}
int f()
{ 
    return x+1; // エラー。関数fのスコープでxは定義されていない
}
```
通常、別のスコープへ値を渡したい場合は、関数の引数として渡す事で実現できます。
```cpp
int f(int);
int main()
{
    int x=10;
    f(x);
}
int f(int x)
{
    return x+1;
}
```
このようなスコープ内の領域を**ローカルスコープ**と言います。

### 6.2.2 グローバルスコープ
グローバルスコープに変数を宣言/定義しそれを使って見ます。
```cpp
int x=10;
void func()
{
    x=20;
}
int main()
{
    func();
    std::cout<<x<<std::endl;
}
```
実行結果は以下となります。
```cpp
20
```
このコードから分かる事は、グローバル領域に宣言/定義された変数はどのスコープからでも見えるという事です。このようなスコープ外の領域を**グローバルスコープ**と言います。ローカルスコープの変数はその内包している関数の終端で破棄されますが、グローバル変数はプログラムが完全に終了するまで破棄されないため、グローバルスコープに宣言された変数はローカル変数よりも寿命が長いと言えます。

### 6.2.3 メモリ領域
メモリ領域の観点から見ると、グローバルスコープとローカルスコープの違いは歴然です。その違いを理解するために、まずメモリ領域について説明します。以下は、C++言語で扱うメモリの論理的な模式図です。
![](/assets/memory.jpg)
各領域の役割は、以下の通りです。
* テキスト領域：機械語に翻訳されたプログラム本体が格納されます。
* 静的領域：グローバル変数、static変数などの静的変数が置かれる。
* ヒープ領域：メモリの動的管理 (malloc関数、new 演算子によってメモリを確保する事) に利用されます。
* スタック領域：CPUのレジスタの内容を一時的に退避させたり、自動変数 (多くのローカル変数) の格納、管理に用いられます。

各領域の役割の内には、まだ現時点では説明していない概念が含まれていますが、後々全て説明していきますので、今は分からなくても大丈夫です。このようにメモリ領域の観点から考えると、グローバル変数とローカル変数は格納される領域がそれぞれ異なります。それでは、実際のC++コードからそれぞれがどの領域に格納されるのかを見て見ましょう。
```cpp
int plus(int x,int y)
{
    return x+y;
}
int global_variable; // グローバル変数
int main()
{
    int x=10,y=20;
    int result=plus(x,y);
} 
```
それぞれ、以下のように各領域が格納されています。(関数アドレスについては、また後に説明します。)

| 静的領域(グローバルスコープ) | スタック領域(ローカルスコープ) |
| -- | -- |
| `plus`関数アドレス | `plus`関数内変数x |
| `main`関数アドレス | `plus`関数内変数y |
| 変数`global_variable` | `main`関数内変数x | 
| | `main`関数内変数y |
| | `main`関数内変数`result` |

### 6.2.4 領域毎のOne Definition
ところで、グローバル領域とローカル領域で同じ名前の識別子を使用する事はできるでしょうか。
```cpp
int x;
int main()
{
    int x;
}
```
これは、できます。グローバル領域の`x`とローカル領域の`x`は、領域がそれぞれ違うので別物として扱う事ができます。これは「5.1 スコープ」で説明した内容と同じです。

### 6.2.5 static変数
例えば、ある関数があったとします。その関数は呼ばれる度に、自身が何回呼ばれたのかを出力する関数だとします。
```cpp
#include<iostream>
void func()
{
    int i=1;
    std::cout<< i++ <<std::endl;
}
int main()
{
    for(unsigned int a=0; a<5; ++a)
        func();
}
```
実行結果は以下となります。
```cpp
11111
```
これは失敗ですね。
`for`文で`func`関数を5度呼び出していますが、うまくカウントできていません。理由は単純です。カウントする関数`func`内の変数`i`は、`func`内のローカル変数だからです。何か哲学的な事を言っているように聞こえるかもしれませんが、これは事実です。要するに、カウントするための変数`i`は`func`関数が実行されると`0`で初期化され、その後、後置インクリメントによって遅延的に`i`の値は`1`となりますが、そこで関数が終了してしまうため、変数`i`は破棄されてしまうのです。その後、また関数`f`が呼ばれ、同じ事を繰り返すのですから、永遠に0から変わらないのは当然です。これを解決する一つの方法として、プログラムが終了するまで、確保した領域が破棄されない変数を使うという方法がありますね。まずは、先ほどから紹介している、**グローバル変数**を用いる方法があるでしょう。
```cpp
#include<iosteram>
int i=1;
void func()
{
    std::cout<< i++ <<std::endl;
}
int main()
{
    for(unsigned int a=0; a<5; ++a)func();
}
```
実行結果は以下となります。
```cpp
12345
```
グローバル領域に変数を宣言したため、プログラムが終了するまでその変数は破棄されません。また、どこからでもその変数を見る事ができます。その結果、意図した通りの処理を行う事ができました。しかし、グローバル変数とは別の手段で、プログラムが終了するまで破棄されない変数を定義する方法があるのです。それが、**static変数**です。
```cpp
void func()
{
    static int i=1; std::cout<< i++ <<std::endl;
}
int main()
{
    for(unsigned int a=0; a<5; ++a)func();
}
```
実行結果は以下となります。
```cpp
12345
```
`static`指定子を変数宣言時の型の前に付与する事で、その変数をstatic変数とする事ができます。`static`変数は、グローバル変数と同様、プログラムが終了するまでその変数は破棄されません。しかし、グローバル変数とは違ってスコープは`func`関数内にありますので、例えば上記コードの場合、`main`関数から変数`i`を見つける事はできません。因みに、ローカル変数は初期化も代入もせずその変数を参照しようとすると、どんな値が入っているかは分かりませんでしたが、
```cpp
#include<iostream>
int main()
{
    int x;
    std::cout<<x<<std::endl; // 何が出力されるか未定義
}
```
グローバル変数や`static`変数は初期化時に勝手に値0で初期化される事が決まっています。
```cpp
#include<iostream>
int a;
int main()
{
    static int b;
    std::cout<<a<<std::endl; // 0
    std::cout<<b<<std::endl; // 0
}
```

### 6.2.6 static指定子の別のセマンティック
セマンティックとはかなり簡潔に述べると意味論といったところです。実は、`static`指定子には別の意味合いもあります。それは、**そのファイル内でしかそのデータにアクセスする事はできない**という意味合いです。例えば以下のように記述されているファイルがあったとします。それは`test.hpp`という名前だとします。
```cpp
// test.hpp
static int data;
```
これをインクルードして変数`data`を使って見ましょう。
```cpp
#include"test.hpp"
int main()
{
    data=10;
}
```
...という事ができないようにする事ができるます。つまり、変数`data`にアクセスできるのは`test.hpp`というファイルの中だけで、インクルードした先でその変数に対してアクセスする事はできません。これは、ファイルごとの動作の安全性を確立するためにある機能であり、例えば変数をそのファイル内のグローバルスコープには起きたいが、他のファイルからはその変数を使えないようにしたいといった時に効力を発揮します。これは関数などでも同じです。しかしこの機能は、`static`変数とはまた異なって`static`というキーワードに異なる機能/意味合いを持たせていることからあまり分かりやすいとは言えません。`static`キーワードは、本来は記憶クラスを静的にする意味の修飾子です。しかしこのように特例として、宣言した時点で最初から記憶クラスが静的なものにstaticをつけた場合、名前をファイルスコープに制限する意味となります。このように変則的に意味が変わるのはあまり分かりやすいとは言えません。そこで、そのファイル中でしかアクセスする事ができないようにするという機能は、別の方法で実現する事ができるようになっています。それは後ほど、名前空間の項で説明します。

### 6.2.7 領域の概念から考察する設計デザイン
このようにグローバル領域に宣言されたデータと`static`指定子が付与されたデータはプログラムが終了するまで破棄されません。しかし逆を言えば、両者ともプログラムが終了するまで破棄されないで欲しいという必要性に迫られない限り、静的領域にデータを確保しても意味がなく、無駄であるとも言えるのです。更に特にグローバル領域に関して言えば、プログラムのどこからでも見えてしまうというそのあまりにも広い自由度から、バグの温床になってしまう事も考えられるため、グローバル変数自体の使用を禁止するというプロジェクトルールを掲げるチームも中には存在します。実際のところ、機能を理解している上で本当に必要であれば、使うべきです。しかし、単に単純だからといった無意味な理由でその機能を使うのは、辞めるべきです（領域の概念以外でも全てにおいて言える事ですが）。

# 4.3 演算子

演算子(operator)には様々な種類があります。それぞれ算術演算子、論理演算子、条件演算子、比較演算子、ビット演算子に分類する事が出来ます。それぞれの演算子について解説していきます。

### 4.3.1 算術演算子

| 演算子 | 種別 | 例 | 意味 |
| -- | -- | -- | -- |
| `+` | 加算 | `x + y` | `x`に`y`を加える |
| `-` | 減算 | `x - y` | `x`から`y`を引く |
| `*` | 乗算 | `x * y` | `x`に`y`をかける |
| `/` | 除算 | `x / y` | `x`を`y`で割る |
| `%` | 剰余算 | `x % y` | `x`を`y`で割った余りを求める |
| `+=` | 自己代入加算 | `x += y` | `x`に`y`を加えた値を`x`に代入する | 
| `-=` | 自己代入減算 | `x -= y` | `x`から`y`を引いた値を`x`に代入する | 
| `*=` | 自己代入乗算 | `x *= y` | `x`に`y`をかけた値を`x`に代入する | 
| `/=` | 自己代入除算 | `x /= y` | `x`に`y`で割った値を`x`に代入する | 
| `%=` | 自己代入剰余算 | `x %= y` | `x`を`y`で割った余りの数値を`x`に代入する |
| ++ | 前置 or 後置 インクリメント | ++x or x++ | **5.3.2**の項を参照 | 
| -- | 前置 or 後置 デクリメント | --x or x-- | **5.3.2**の項を参照 |

使って見ましょう。

```cpp
#include<iostream>
int main()
{
    int x=10,y=3;
    std::cout << x + y << '\n' <<
    x - y << '\n' <<
    x * y << '\n' <<
    x / y << '\n' <<
    x % y << std::endl;
}
```
実行結果は以下となります。

```cpp
13
7
30
3
1
```
上から、加算、減算、乗算、除算、剰余算の演算結果となります。算術演算子と名付けられている通り、それぞれ数値演算が行われている事が分かると思います。次に自己代入型の算術演算子を使います。

```cpp
#include<iostream>
int main()
{
    int x=10,y=3;
    
    x+=y;
    std::cout<<x<<std::endl;
    x=10;

    x-=y;
    std::cout<<x<<std::endl;
    x=10;

    x*=y;
    std::cout<<x<<std::endl;
    x=10;

    x/=y;
    std::cout<<x<<std::endl;
    x=10;

    x%=y;
    std::cout<<x<<std::endl;
}    
```
実行結果は以下となります。
```cpp
13
7
30
3
1
```
単純な自己代入でない算術演算子を用いた場合、演算された値は指定しない限り何にも保存されませんが、このように自己代入型の算術演算子を用いた場合、その変数自体の値が上書きされます。

### 4.3.2 論理演算子

| 演算子 | 種別 | 例 | 意味 |
| -- | -- | -- | -- |
| `&&` | 論理積（AND） | `a && b` | `a`と`b`が共に真の場合「真」|
| &#124;&#124; | 論理和（OR） | a &#124;&#124; b | `a`または`b`が真の場合「真」|
| `!` | 否定（NOT） | `!a` | `a`が偽の場合「真」、`a`が真の場合「偽」|

使って見ましょう。

```cpp
#include<iostream>
int main()
{
    std::cout << std::boolalpha << ( true && true ) << // (1)
    '\n' << ( true || false ) << // (2)
    '\n' << ( ! false ) << std::endl; // (3)
}
```
実行結果は以下となります。

```cpp
true
true
true
```
こちらも表に書かれている意味合いのままですが、念のため詳しく解説します。

<ol>
<li><code>&&</code>演算子は<code>&&</code>に対応する左右の値が<code>true</code>である時に、<code>true</code>となるものです。大雑把な意味合いとしては「どちらも<code>true</code>である時」と捉える事ができます。</li>
<li><code>||</code>演算子は<code>||</code>に対応する左右のどちらかの値が<code>true</code>である時に、<code>true</code>となるものです。これは、「どちらかが<code>true</code>である時」と捉える事ができますね。</li>
<li><code>!</code>演算子は<code>!</code>に対応する値が<code>false</code>である時に、<code>true</code>となるものです。また、<code>true</code>である時に、<code>false</code>となるものです。これは、「意味合いを逆転する」と捉える事ができますね。</li>
</ol>

### 4.3.3 条件演算子

| 演算子 | 種別 | 例 | 意味 |
| -- | -- | -- | -- |
| `? :` | 条件演算子 | `a ? b : c` | `a`が真なら`b`が実行、`a`が偽なら`c`が実行。|

使ってみましょう。

```cpp
#include<iostream>
int main()
{
    int a=true?10:20; // (1)
    std::cout << a << std::endl;
    a=false?10:20; // (2)
    std::cout << a << std::endl;
}
```
実行結果は以下となります。

```cpp
10
20
```

条件演算子は、`?`の左側にくる値が`true`である場合、`?`の右側の式が実行され、そうでない場合は`:`の右側にある式が実行されます。上記のプログラム(1)では、`true`を置いていますので、`10`で初期化されます。(2)では、`false`を置いていますので、`20`が代入されます。

### 4.3.4 比較演算子

| 演算子 | 種別 | 例 | 意味 |
| -- | -- | -- | -- |
|`<` | 小なり | `a < b` | `a`は`b`より小さい |
| `<=` | 小なりイコール | `a <= b` | `a`は`b`以下 |
| `>` | 大なり | `a > b` | `a`は`b`より大きい |
| `>=` | 大なりイコール | `a >= b` | `a`は`b`以上 |
| `==` | イコール | `a == b` | `a`と`b`は等しい |
| `!=` | ノットイコール | `a != b` | `a`と`b`は異なる |

使って見ましょう。

```cpp
#include<iostream>
int main()
{
    std::cout << std::boolalpha << (10 < 20) << // (1)
    '\n' << (10 <= 10) << // (2)
    '\n' << (20 > 10) << // (3)
    '\n' << (10 >= 10) << // (4)
    '\n' << (10 == 10) << // (5)
    '\n' << (10 != 20) << std::endl; // (6)
}
```
実行結果は以下となります。

```cpp
true
true
true
true
true
true
```
それぞれ、以下のようになります。

1. 10は20よりも小さいので<code>true</code>です。
2. 10は10以下であるので<code>true</code>です。
3. 20は10よりも大きいので<code>true</code>です。
4. 10は10以上であるので<code>true</code>です。
5. 10は10と等しいので<code>true</code>です。
6. 10は20と異なるので<code>true</code>です。


### 4.3.5 ビット演算子

| 演算子 | 種別 | 例 | 意味 |
| -- | -- | -- | -- |
| `&` | ビット毎のAND | `a & b` | `a`と`b`のビット単位のAND |
| `｜` | ビット毎のOR | `a ｜ b` | `a`と`b`のビット単位のOR |
| `^` | ビット毎の排他的OR | `a ^ b` | `a`と`b`のビット単位の排他的OR |
| `~` | ビット単位の反転 | `~a` | `a`の各ビットを反転 |
| `<<` | 左シフト | `a << b` | `a`を`b`ビット分、左へシフト |
| `>>` | 右シフト | `a >> b` | `a`を`b`ビット分、右へシフト |

使って見ましょう。

```cpp
#include<iostream>
#include<bitset>
#include<climits>
#define SCCT_BIT(x) static_cast<std::bitset<CHAR_BIT&>>(x)
int main()
{
    unsigned char a=0b10101010;
    std::cout << "& :" << SCCT_BIT( a & 0b11110000 ) << // (1)
    '\n' << "| :" << SCCT_BIT( a | 0b11110000 ) << // (2)
    '\n' << "^ :" << SCCT_BIT( a ^ 0b00001111 ) << // (3)
    '\n' << "~ :" << SCCT_BIT( ~ a) << // (4)
    '\n' << "<< :" << SCCT_BIT( a << 2 ) << // (5)
    '\n' << ">> :" << SCCT_BIT( a >> 2 ) << std::endl; // (6)
}
```
実行結果は以下となります。

```cpp
& :10100000
| :11111010
^ :10100101
~ :01010101
<< :10101000
>> :00101010
```
何やら`bitset`や`climits`といったヘッダファイルをインクルードしていますね。さらにその下には、<code>#define SCCT_BIT(x) static_cast&lt;std::bitset&lt;CHAR_BIT&gt;&gt;(x)</code>なる、よくわからないものがありますが、これは後に説明する、マクロ、キャスト、テンプレートといった概念が含まれていますので、現時点では気にしなくて大丈夫です。意味合いとしては、標準出力へ出力する際に、2進数表記のまま数値を出力しろというものになります。また、変数`a`の初期化値、`0b10101010`とはなんでしょうか。これは二進数リテラルという概念を用いた、二進数表記の数値です。これについても後述しますが、二進数リテラルを簡単に説明すると、`0b`を実際の二進数値の前に付与する事で、この数値は二進数表記された数値であるとコンパイラに伝える事ができます。今回のコードで二進数表記を用いているのは、ビット演算の考察において通常の10進数表記の値よりも便宜的だからです。どう便宜的なのかは読み進めていけば理解できます。


さて、ビット演算子は、少し理解しにくいかもしれませんが、整数型の数値に対してビット単位で演算を行うための演算子となります。
それぞれ解説していきます。

**(1)**&nbsp;`&`演算子の機能はつまり、**両方のビット値が1のときのみ結果が1になるビット演算**です。このコードでは、`10101010`に対して`11110000`という数値を`&`演算子を用いて適用しています。`&`演算子は*両者のビット値が1のときのみ結果が1になる*のですから、その演算結果は`10100000`となります。両者の数値を見比べて見るとその様子が理解できるでしょう。分かりやすく図にすると以下のようになります。

| 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 |
| -- | -- | -- | -- | -- | -- | -- |
| & | & | & | & | & | & | & | & |
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| ↓ | ↓ | ↓ | ↓ | ↓ | ↓ | ↓ | ↓ |
| 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |

**(2)**&nbsp;`|`演算子の機能はつまり、**いずれかのビット値が1なら結果が 1になるビット演算**です。このコードでは、`10101010`に対して`11110000`という数値を`|`演算子を用いて適用しています。`|`演算子は、**いずれかのビット値が1なら結果が1になる**のですから、その演算結果は`11111010`となります。

**(3)**&nbsp;`^`演算子の機能はつまり、**両方のビット値が異なるときに結果を1にするビット演算**です。このコードでは、`10101010`に対して`00001111`という数値を`^`演算子を用いて適用しています。`^`演算子は、**両方のビット値が異なるときに結果を1にする**のですから、その演算結果は`10100101`となります。

**(4)**&nbsp`~`演算子の機能はつまり、**ビット値の反転を行うビット演算**です。このコードでは、`10101010`に対して`~`演算子を適用しています。`~`演算子は**ビット値の反転を行う**のですから、その演算結果は`01010101`となります。

**(5)**&nbsp;<code>&lt;&lt;</code>演算子は左シフト演算子とも呼ばれます。`10101010`に対して、<code>&lt;&lt;</code>演算子を用いて`2`を指定する事で、`10101010`を2ビット左へシフトしろという意味になります。2ビット左へシフトとは、`10101010`の頭2ビット分を捨て、後ろ2ビット分を入れるという事です。その後ろには値として0が入ります。図で表すと、このようになります。

1. 左シフト演算前

| 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 |
| -- | -- | -- | -- | -- | -- | -- |


2. 左シフト演算実行
頭2ビット分消滅。後ろにその2ビット分が入る。値は0が入る。

| &nbsp; | &nbsp; | 1 | 0 | 1 | 0 | 1 | 0 | 0 | 0 |
| -- | -- | -- | -- | -- | -- | -- |



3. 演算結果

| 1 | 0 | 1 | 0 | 1 | 0 | 0 | 0 |
| -- |



**(6)**&nbsp;<code>&gt;&gt;</code>演算子は右シフト演算子とも呼ばれます。(5)によって変数`a`の値は`10101000`となっています。この数値に対して、<code>&gt;&gt;</code>演算子を用いて`2`を指定する事で、`10101000`を2ビット右へシフトしろという意味になります。2ビット右へシフトとは、`10101000`の後ろ2ビット分を捨て、頭2ビット分を入れるという事です。図で表すと、このようになります。

1.右シフト演算前

| 1 | 0 | 1 | 0 | 1 | 0 | 0 | 0 |
| -- |

2.右シフト演算実行

後ろ2ビット分消滅。頭にその2ビット分が入る。空いた部分にはその値が符号無しなら 0が入ります。値が符号付きなら、算術シフトを行う処理系では1が入り、論理シフトを行う処理系では0が埋められます。算術シフトと論理シフトの詳細については現時点で理解する必要はありませんが、左シフトの演算処理が均一である事に対し、右シフトは処理系によって異なりますので、注意しましょう。

| 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | &nbsp; | &nbsp; |
| -- |

3.演算結果

| 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 |
| -- |

符号付きの数値である場合を見て見ましょう。

```cpp
#include<iostream>
#include<bitset>
#include<climits>
#define SCCT_BIT(x) static_cast<std::bitset>CHAR_BIT>>(x)
int main()
{
    signed char a=0b11110110;
    std::cout << SCCT_BIT( a >> 2 ) << std::endl;
}
```
実行結果は以下となります。

```cpp
11111101
```
1で埋められている事が確認できますね。

## 4.4 sizeof演算子

| 演算子 | 例 | 意味 |
| -- |
| `sizeof` | `sizeof(a)` | `a`のバイト長を演算する |

C++で使って見ましょう。

```cpp
#include<iostream>
int main()
{
    char a; int b; double c; bool d;
    std::cout<< sizeof(a) << '\n' <<
    sizeof(b) << '\n' <<
    sizeof(c) << '\n' <<
    sizeof(d) << '\n' <<
    sizeof(main()) << std::endl;
}
```
実行結果は以下となります。

```cpp
1
4
8
1
4
```
上から`char`、`int`、`double`、`bool`型のバイト長が出力されていますね。2.2 変数とデータ型の項に書かれている表と見比べると、その通りに出力されている事がわかります。

最後の`sizeof`式では、`main()`と書いていますね。この出力結果は4バイトと出力されていますがなぜでしょうか。
実は、これはmain関数の戻り値、つまり`int`のサイズが出力されているのです。では、これは何が出力されるでしょうか。

```cpp
char f(){}
int main()
{
    sizeof(f());
}
```
実行結果は以下となります。

```cpp
1
```
`f`という関数は戻り値が`char`型であるので、そのバイト長である1が出力されます。


このコードは、これから説明する関数という概念を用いていますので現時点で理解する必要はありませんが、`sizeof`演算子に関数を入れると、その戻り値型のバイト長が得られるという事が理解していただければと思います。この内容については、関数の章で再度取り上げます。

因みに、型を`sizeof`に指定する事もできます。
```cpp
#include<iostream>
int main()
{
    std::cout << sizeof(char) << std::endl;
}
```
実行結果は以下となります。
```cpp
1
```
`char`型は1バイトですから、1と出力されました。また、ここまで全て`sizeof`に対して括弧を用いてきましたが、これはなくても構わない場合があります。
```cpp
#include<iostream>
int main()
{
    char a=0,b=0;
    std::cout<< sizeof a << std::endl; // aは式
    std::cout<< sizeof a+b << std::endl; //　a+bは式
}
```
実行結果は以下となります。
```cpp
1
1
```
このようになくても構わない場合というのは、`sizeof`に対するものが**式である場合のみ**です。つまり、以下のような場合には括弧が必要となります。
```cpp
#include<iostream>
int main()
{
    std::cout << sizeof char << std::endl; 
    // charは式ではない
    // sizeof(char)と書かなければならない。
}
```

## 4.5 演算子の優先順位規則
それぞれの演算子には優先順位というものがあります。例えば、以下のコードはどのように処理されるでしょうか。

```cpp
#include<iostream>
int main()
{
    std::cout << 42 + 10 * 10 << std::endl;
}
```
実行結果は以下となります。

```cpp
142
```
出力結果から、加算よりも乗算の方が先に行われるという数式の性質が現れている事が確認できます。このように、演算子には全て処理、評価される優先順位が全て決められています。

では以下に、演算子の優先順位を網羅した表を掲示します。中にはまだ見たことのない演算子もありますが、後に説明していきますので大丈夫です。

#### 最高優先順位である演算子(結合性なし)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `::` | スコープの解決 | × |

#### 第二優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `()` | 関数呼び出し | ○ |
| `[]` | 配列添字参照 | ○ |
| `.` | 直接メンバーアクセス | × |
| `->` | 間接メンバーアクセス | ○ |
| `++` | 後置インクリメント | ○ |
| `--` | 後置デクリメント | ○ |
| `typeid` | 実行時型情報 | × |
| `const_cast` | 型キャスト(const外し) | × |
| `dynamic_cast` | 型キャスト(静的/動的キャスト) | × |
| `static_cast` | 型キャスト(静的キャスト) | × |
| `reinterpret_cast` | 型キャスト(強制キャスト) | × |
| `(型)` | 型キャスト | - | ○ |

#### 第三優先順位である演算子(右から左へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `++` | 前置インクリメント | ○ |
| `--` | 前置デクリメント | ○ |
| `+` | 単項プラス | ○ |
| `-` | 単項マイナス | ○ |
| `~` | ビット否定 | ○ |
| `!` | 論理否定 | ○ |
| `&` | アドレス取得 | ○ |
| `*` | 間接参照、参照外し | ○ |
| `(型)` | 型キャスト | ○ |
| `sizeof` | サイズの取得 | × |
| `new` | 動的な領域確保 | ○ |
| `new[]` | 動的な配列領域確保 | ○ |
| `delete` | 動的な領域開放 | ○ |
| `delete[]` | 動的な配列領域開放 | ○ |

#### 第四優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `.*` | メンバーへのポインター | × |
| `->*` | メンバーへのポインター | ○ |

#### 第五優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `*` | 乗算 | ○ |
| `/` | 除算 | ○ |
| `%` | 剰余 | ○ |

#### 第六優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `+` | 加算 | ○ |
| `-` | 減算 | ○ |

#### 第七優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `<<` | 左シフト | ○ |
| `>>` | 右シフト | ○ |

#### 第八優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `<` | 小なり | ○ |
| `<=` | 小なりイコール | ○ |
| `>` | 大なり | ○ |
| `>=` | 大なりイコール | ○ | 

#### 第九優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `==` | イコール(等価) | ○ |
| `!=` | ノットイコール(不等価) | ○ |



#### 第十優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `&` | ビット積(AND) | ○ |



#### 第十一優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `^` | ビット排他的論理和(XOR) | ○ |



#### 第十二優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `｜` | ビット和(OR) | ○ |



#### 第十三優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `&&` | 論理積 | ○ |



#### 第十四優先順位である演算子(左から右へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `｜｜` | 論理和 | ○ |

#### 第十五優先順位である演算子(右から左へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `? :` | 条件演算子 | × |

#### 第十六優先順位である演算子(右から左へ結合)

| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `=` | 代入 | ○ |
| `*=` | 乗算代入 | ○ |
| `/=` | 除算代入 | ○ |
| `%=` | 剰余代入 | ○ 
| `+=` | 加算代入 | ○ |
| `-=` | 減算代入 | ○ |
| `<<=` | 左シフト代入 | ○ 
| `>>=` | 右シフト代入 | ○ |
| `&=` | ビット積代入 | ○ |
| `^=` | ビット排他的論理和代入 | ○ |
| `｜=` | ビット和代入 | ○ |


#### 第十七優先順位である演算子(結合性なし)
| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `throw` | 例外送出 | × |



#### 第十七優先順位である演算子(左から右へ結合)
| 演算子 | 機能 | オーバーロード |
| -- | -- | -- |
| `,` | 順次演算子 | ○ |
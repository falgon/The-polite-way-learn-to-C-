# 16.8 float のしくみ

この項では`float`型(本項で`float`型とは、後述する IEEE Standard for Floating-Point Arithmetic (ANSI/IEEE Std 754-2008) に準拠した`float`型についてを言います)のしくみと、それから考えられる性質などについて解説していきます。

## 16.8.1 コンピュータにおける「数」とはなにか
コンピュータにおける数と、数学の整数や実数は、よくよく考えると異なるものです。
コンピュータでは有限の記憶領域しかありません。よって、無数にある数を表すということは根本的に不可能です。
つまりコンピュータ上の「数」とは「本物の数になるべく似せた別の何か」と捉えることができます。
例えば、32 ビットの変数であれば $$ 2^{32} $$ でおおよそ 40 億、16 ビットであれば同じようにして 65000、8 ビットであれば 256 種類表せることとなります。<br>
しばしば話題にも取り上げられる、2038 年問題とは、このようにコンピュータ上の数が有限数であることに起因します。この問題は、協定世界時における 1970 年 1 月 1 日 0 時 0 分 0 秒からの経過秒数(これを UNIX 時間といいます)を使用して時刻を表現するコンピュータ等のシステムで、その経過秒数が型の上限値を超えてしまうことで、時刻を正常に取り扱えなくなるといった問題です。UNIX 時間を利用しているシステムはこの世の中に多く存在します。この経過秒数を表現する型は、現在の標準では`time_t`型であり、C++ にも同様`<ctime>`に`std::time_t`型が定義されています。この型の実装詳細(範囲や精度)は、各実装に依存することとなっているため、厳密には定められていませんが、多くの伝統的な実装では`int`型を`time_t`としており、その`int`型は 32 ビットの型でした([2.1 変数とデータ型](../Chap2/21-変数とデータ型.md)で示している通り、C++ において`int`型は必ず 32 ビットであると定められているわけではありません)。`int`、すなわち`signed int`型の最大値は $$ 2^{31} - 1 = 2147483647 $$ です。この型で取り扱える経過秒数とは、せいぜい 2,147,483,647 秒($$ \fallingdotseq $$ 68 年)までに限られているのです。よって、1970年 1 月 1 日 0 時 0 分 0 秒から 2,147,483,647 秒を経過した 2038 年 1 月 19 日 3 時 14 分 7 秒を過ぎると、この値がオーバーフローしてしまい、負と扱われてしまうため、この時刻の値を前提としたプログラムが誤作動してしまう可能性があります。

| ![](../assets/168/Year_2038_problem.gif) |
| -- |
| 上から2進、10進、オーバーフローの影響を受けた時刻、正しい時刻(by [Monaneko](https://commons.wikimedia.org/wiki/User:Monaneko) - Own work, [パブリック・ドメイン](https://en.wikipedia.org/wiki/Public_domain)) |

解決策としては、`time_t`を 64 ビットの整数型とするなどが考えられています。64 ビットの整数型にした場合、上限は $$ 2^{63} - 1 = 9223372036854775807 $$ であり、年数に変換するとおよそ西暦 3000 億年にもなるため、事実上問題が発生することはありません。<br>
さて、2038 年問題は整数型における上限値の問題でした。しかし、型が異なっても、例えば`std::int32_t`型と`float`型でも、メモリを直接見てみれば単に 32 個の 0 と 1 が並んだものにすぎません。そのメモリ領域の読み方、使い方が異なるだけで、おおよそ 40 億種類の数字の組み合わせでしか表現ができないことは、全く同じです。<br>
この事実から、コンピュータ上の「数」とは「本物の数になるべく似せた、つまり近似的な別の何か」、また「限られた範囲の中で、型の性質ごとに色々表現方法をやりくりしている」ということをまずは抑えておきましょう。

## 16.8.2 float の中身
符号なし 32 ビット整数を解釈する際には、32 個の 2 進ビットをそのまま読みます。また符号つきである場合は、[16.6 補数](./166-complement.md)で説明した通り補数を用いてその値を表現します。<br>
では、`float`は一体どのようにして値を表現しているのでしょうか。
C++ における`float`型とは、**単精度浮動小数点数型**と言われる浮動小数点型であり、前述した通りビット列によって実数を表現します。
その表現方法は、国際標準規格 **IEEE Standard for Floating-Point Arithmetic (ANSI/IEEE Std 754-2008)**(以下これを IEEE 754 と称します)として 5 種類定められており、以下に示す形式は、同国際標準規格のうちの 1 つである、**binary32** という形式です。一般的な実装では、C++ における`float`型はこの形式に則って実装されます。

$$ \overbrace{
\overbrace{\underbrace{1}_{符号部({\bf s}ign)}}^{1bit}\
\overbrace{\underbrace{10000010}_{指数部({\bf e}xponent)}}^{8bit}\
\overbrace{\underbrace{01100100000000000000000}_{仮数部({\bf f}raction)}}^{23bit}}^{32 bit} $$

<br>
IEEE 754 では上図のように、32 ビットを 3 つに分割し、一番右側を 0 ビット目とし、一番左側を 31 ビット目とします。なお、このビット列は、$$ -10.25 $$ を表します。各用語は次の通りです。

$$ -10.25 = \overbrace{-}^{符号}\overbrace{10.25}^{仮数} \times 10^{\overbrace{{1}}^{指数}} $$

これをふまえて、順番に IEEE 754 形式の小数値を作りながら説明します。

### 符号部

まずは符号部についてです。これはシンプルで、正ならば $$ 0 $$ が、負ならば $$ 1 $$ がこの部分に入ります。よって現時点では次のようになります。<br>

$$ \overbrace{
\overbrace{\underbrace{1}_{符号部({\bf s}ign)}}^{1bit}\
\overbrace{\underbrace{\cdots}_{指数部({\bf e}xponent)}}^{8bit}\ 
\overbrace{\underbrace{\cdots}_{仮数部({\bf f}raction)}}^{23bit}}^{32 bit} $$


### 仮数部

次に、仮数部です。仮数部は実際の数字を表す部分になります。上図の通り、23 ビットでそれを表現します。ところで、2 進数において整数は、桁が上がるにつれて 2 の乗数を表しました。<br>

$$ \cdots \overbrace{0}^{2^{6}}\overbrace{0}^{2^{5}}\overbrace{0}^{2^{4}}\overbrace{0}^{2^{3}}\overbrace{0}^{2^{2}}\overbrace{1}^{2^{1}}\overbrace{1}^{2^{0}} $$

<br>
小数部分はどうなるかというと、桁が下がるにつれて $$ 0.5 $$ の乗数、つまり $$ 2 $$ のマイナス乗を表現します。
$$ \cdots \overbrace{0}^{2^{6}}\overbrace{0}^{2^{5}}\overbrace{0}^{2^{4}}\overbrace{0}^{2^{3}}\overbrace{0}^{2^{2}}\overbrace{1}^{2^{1}}\overbrace{1}^{2^{0}}.\overbrace{0}^{2^{-1}}\overbrace{0}^{2^{-2}}\overbrace{1}^{2^{-3}}\overbrace{0}^{2^{-4}}\overbrace{0}^{2^{-5}}\overbrace{0}^{2^{-6}}\cdots $$
<br>

仮数部の表現は、この小数部分の表現と同じです。<br>
よくよく考えてみると、この表現は小数部分を $$ 2 $$ のマイナス乗ずつの演算で行うため、値をぴったり表せないことがあることが分かります。そのような場合、その値の近似値で表現することとなります。<br>
$$ -10.25 $$ の場合を考えて見ましょう。このとき、まずは小数点以下の $$ 0.25 $$ に着目します。これを次のように表現します。

$$ -0.25=\cdots \overbrace{0}^{2^{0}}+\overbrace{0.0}^{2^{-1}} + \overbrace{0.25}^{2^{-2}} + \overbrace{0.000}^{2^{-3}} \cdots_{(2)}$$
$$ -0.25=\cdots \overbrace{0}^{2^{0}}.\overbrace{0}^{2^{-1}}\overbrace{1}^{2^{-2}}\overbrace{0}^{2^{-3}}\cdots_{(2)} $$

<br>
より直感的にするために、10 進数値と並べました。"$$ _{(2)} $$" は、$$ x $$ 進数値であることを意味します。$$ -10.25 $$ を表すには、仮数部に、この二進数値と $$ 10 $$ の二進数値、つまり $$ 10 = 1010_{(2)} $$ を合わせた値が入るのです。この「合わせる」という行為は、次の規則に則って行われます。ここまで説明した内容も含めて、以下順に示します。<br>
$$ 10.25 $$ の仮数部を求めるには
1. $$ 10.25 $$ を $$ 10 $$ と $$ 0.25 $$ に分離する
2. それぞれ 2 進に変換し、 $$ 10 = 1010_{(2)} $$、$$ 0.25 = 0.0100_{(2)} $$
3. 合わせて、$$ 1010.0100_{(2)} $$
4. 整数部分に $$ 1 $$ がくるように、小数点を移動する。この場合、$$ 1010.0100_{(2)} $$ から 小数点の位置を左に 3 つずらすと整数部分に 1 がくるので、$$ 1.0100100_{(2)} $$
5. 必ず整数部分に $$ 1 $$ がくるため、その分は無駄である。よって最初の整数部分を省く。$$ 0100100_{(2)} $$
6. 空いている箇所は $$ 0 $$ を埋める

4 で小数点の移動が行われていますが、このような操作を行なってもちゃんと数値を表現できるのか？と疑い深く思うかもしれません。
その小数点の移動がどれだけ行われたかは、次で説明する指数部にて取り扱われるため、ちゃんと表現することができるのです。<br>
ここまでで、次のようになりました。

$$ \overbrace{
\overbrace{\underbrace{1}_{符号部({\bf s}ign)}}^{1bit}\
\overbrace{\underbrace{\cdots}_{指数部({\bf e}xponent)}}^{8bit}\
\overbrace{\underbrace{01100100000000000000000}_{仮数部({\bf f}raction)}}^{23bit}}^{32 bit} $$
<br>
仮数部の表現は、仮数部の直前に小数点があるかのような前提で行われている事がわかります。
また 5 によって、仮数部で表現されるビット列の一つ上の桁に暗黙の 1 ビットがあるとみなせるため(これをいわゆるケチ表現と言ったりします)、実際の仮数部のビット数は 23 ビットですが、実質的には 24 ビット相当の精度で表現する事ができるという事です。<br>
ところでなぜ浮動小数点数が浮動小数点数と言うのかがこれで分かったはずです。仮数部で小数点の位置が変わる事から、浮動小数点数と言われているのですね。

### 指数部
最後に指数部です。ここには、仮数部で動かした桁数を表します。よって指数部は $$ 3 $$ となります。
このとき、$$ 3 =_{2} 011 $$ ですから $$ 011 $$ が指数部となりそうです。しかし、指数部の表現は 2 の補数表現を用いない、つまり符号なしとして扱います(大小比較の単純化のためです)。<br>
では、指数部でマイナスを表現したいときはどうすれば良いのでしょうか。それは、**仮数部で動かした桁数 + $$ 127 $$ をして、符号なしの範囲のみで表現できるようずらす事で表現します。**
このようにある値を一定の基準値からの間隔で表した値をオフセットまたはオフセット値、そのような形態の表現をオフセット表現と言います。また、このときの $$ 127 $$ をバイアス値といったりします。<br>
$$ 011_{2} $$ に対してバイアス値 $$ 127 = 01111111_{(2)} $$ を加えると、$$ 130 = 10000010_{(2)} $$ となります。この値を指数部に入れ、次のようになりました。<br>

$$ \overbrace{
\overbrace{\underbrace{1}_{符号部({\bf s}ign)}}^{1bit}\
\overbrace{\underbrace{10000010}_{指数部({\bf e}xponent)}}^{8bit}\
\overbrace{\underbrace{01100100000000000000000}_{仮数部({\bf f}raction)}}^{23bit}}^{32 bit} $$

<br>
というわけで、$$ 10.25 $$ を IEEE 754 準拠の浮動小数点数に変換する事ができました。
なお、仮数部で整数部分に $$ 1 $$ がくるように合わせると述べましたが、これに関しては一点例外があり、値が $$ 0 $$ である場合の時です。そのような時は、$$ 0.0 $$ を表していることとなります。
また、指数部が全て 1 である場合(255である場合)は無限大を表現します。<br>

### まとめ
練習として別の値でも IEEE 754 準拠の値を求めて見ましょう。例として $$ 25.625 $$ を変換して見ます。符号部は正ですから、まずは次のようになるはずです。<br>

$$ \overbrace{
\overbrace{\underbrace{0}_{符号部({\bf s}ign)}}^{1bit}\
\overbrace{\underbrace{\cdots}_{指数部({\bf e}xponent)}}^{8bit}\ 
\overbrace{\underbrace{\cdots}_{仮数部({\bf f}raction)}}^{23bit}}^{32 bit} $$

<br>
次に、$$ 25.625 $$ を $$ 25 $$ と $$ 0.625 $$ に分離します。それぞれ $$ 25 = 11001_{(2)} , 0.625 = 0.101_{(2)} $$ です。
合わせると $$ 11001.101_{(2)} $$ ですが、整数部分が先頭になるように小数点を移動させます。4 つ移動させれば良いので $$ 1.1001101_{(2)} $$ となります。
このとき、整数部分の $$ 1 $$ を除いて、仮数部は次のようになります。<br>

$$ \overbrace{
\overbrace{\underbrace{0}_{符号部({\bf s}ign)}}^{1bit}\
\overbrace{\underbrace{\cdots}_{指数部({\bf e}xponent)}}^{8bit}\
\overbrace{\underbrace{10011010000000000000000}_{仮数部({\bf f}raction)}}^{23bit}}^{32 bit} $$
<br>
指数部には先ほど移動させた $$ 4 $$ を表現します。バイアス値である $$ 127 $$ を加えて $$ 131 = 100000011_{(2)} $$ です。よって<br>
$$ \overbrace{
\overbrace{\underbrace{0}_{符号部({\bf s}ign)}}^{1bit}\
\overbrace{\underbrace{10000011}_{指数部({\bf e}xponent)}}^{8bit}\
\overbrace{\underbrace{10011010000000000000000}_{仮数部({\bf f}raction)}}^{23bit}}^{32 bit} $$
<br>
となります。<br>
さてここまで仮数部をもとめるのに、「小数点を移動する」と述べてきました。
これは、仮数の説明の冒頭で述べた通り、2 進表記は桁が上がるにつれて $$ 2 $$ の乗数を表現することとなりますから、実質的に $$ 2^{x} $$($$ x $$ は移動した数)と同じです。
つまり、二進数値の小数点以下の値を含む値をを指数で表現しているということです。指数で表現するとどのように数値に影響がでるのかは後述していますが、まずは利点として、**少ないビット数で広い範囲を表現できる方法である**ということを、ここまでで実感できたはずです。また、このことから指数部を指数部と言う理由がわかったはずです。

## 16.8.3 数値範囲
指数部が全て $$ 1 $$ であるときに、無限を表現すると前述しました。また、全てのビットが 0 だと当然 $$ 0.0 $$ ですので、それらを除いた実際の数値として扱える範囲を、実際に確認してみましょう。
まずは正の数における最小値です。<br>

$$ \overbrace{
\overbrace{\underbrace{0}_{符号部({\bf s}ign)}}^{1bit}\
\overbrace{\underbrace{00000001}_{指数部({\bf e}xponent)}}^{8bit}\
\overbrace{\underbrace{00000000000000000000000}_{仮数部({\bf f}raction)}}^{23bit}}^{32 bit} $$

この指数部に着目します。


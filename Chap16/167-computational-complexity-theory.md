# 16.7 計算量理論

この項では、アルゴリズムの性能を表すのに多様される O 記法、またアルゴリズムの複雑性クラスの分類について説明します。

## 16.7.1 アルゴリズムと対応する O 記法

O 記法はある特定のアルゴリズムの計算量を示すことのできる記法です。計算量とは、あるアルゴリズムにどれだけの計算を行うかを示すものです。
例えば、$$ 1 $$ から $$ n $$($$ n $$ は整数とする)までの整数の総和($$ \sum_{ k = 1 }^{ n } k = 1 + 2 + 3 + ... n $$)を求める時、どのように計算を行うと良いでしょうか？
愚直な実装は次のようになるでしょう。
```cpp
unsigned int sum(unsigned int n)
{
    int k = 0;
    for (unsigned int i = 1; i <= n; ++i) k += i;
    return k;
}
```
この実装だと、加算を $$ n - 1 $$ 回行いますから、計算量を$$ O(N) $$というように書きます。これは、ビッグオー記法(O 記法)と言います。O は order で、ここでは次数を意味するものです。
$$ O(N - 1) $$ ではないのかと思われるかもしれませんが、ビッグオー記法では一番規模の大きな計算だけを残し、さらに係数を $$ 1 $$ とするようにして記述する慣習があります。これは、分かりやすさの他に、相対誤差が殆ど無いことに起因します。
ところで、先ほどの $$ 1 $$ ~ $$ N $$ の総和は、高校数学の次の公式で求めることができますね。<br>
$$ (n + 1) n / 2 $$ 
少し話は逸れてしまいますが、この公式の意味が分からない場合のために念のため説明しておくと、まず $$ S = 1 + 2 + 3 + ... + n $$ というのは当然ながら $$ S = 1 + 2 + 3 + ... + (n - 1) + n $$ です。
総和の式を逆順にして、$$ S = n + (n - 1) + (n - 2) + ... + 2 + 1 $$ とします。次に、$$ S $$ を二倍します。すると $$ 2S = (n + (n - 1) + (n - 2) + ... + 2 + 1) + (1 + 2 + ... + (n - 2) + (n - 1) + n) $$ ですね。置き換えると、$$ 2S = (1 + n) + (2 + n - 1) + ... + (n - 1 + 2) + (n + 1) $$ です。この式はさらに置き換えることが出来、$$ 2S = (n + 1) + (n + 1) + ... + (n + 1) + (n + 1) $$ であり $$ 2S = \underbrace{(n + 1) + (n + 1) + ... + (n + 1) + (n + 1)}_{n} $$ なので、$$ 2S = n(n + 1) $$ となります。つまり、$$ S $$ は $$ n (n + 1) / 2 $$ となりますね。  
こちらの実装は次のようになるでしょう。
```cpp
int sum(int n)
{
    return n * (n + 1) / 2;
}
```
この実装ではご覧の通り、加算、積算、除算で計算し終えます。ですから、$$ O(3) $$ ... ではなく前述した通り $$ O(1) $$ と書きます。
このようにしてビックオー記法を用いると。各アルゴリズムの比較や考察において、どちらが優れているのか、どれぐらいの計算量を必要とするのかが簡潔に分かります。<br>
もう一つ例を取り上げてみましょう。例えば $$ n $$ 以下の素数を全て見つけ出す時、どのように計算を行うと良いでしょうか？
愚直な実装は次のようになるでしょう($$ n $$ は下記コード`n`に対応しています)。
```cpp
#include <cmath>

template <class OutputIterator>
OutputIterator primes(unsigned int n, OutputIterator oiter)
{
    if (n > 2) *oiter++ = 2;
    for (unsigned int i = 3; i <= n; i += 2) { // (1)
        bool k = true;
        for (unsigned int j = 3, sqrti = std::sqrt(i); j <= sqrti; j += 2) { // (2)
            if (!(i % j)) { // (3)
                k = false;
                break;
            }
        }
        if (k) *oiter++ = i;
    }
    return oiter;
}
```
この実装は $$ 1 $$ から`n`まで順々に素数判定を行うアルゴリズムを少し最適化したものです。尚次のように利用する事を想定しています。
```cpp
#include <vector>

std::vector<unsigned int> res;
primes(n, std::back_inserter(res));
```
$$ 2 $$ 以外の素数は奇数ですから、`(1)`の通り奇数のみを調査対象としています。また、任意の値 $$ a $$ が合成数である場合は、必ず $$ \sqrt{a} $$ より小さい素因数を持つはずです。念のため説明しておきましょう。$$ N $$ が合成数とします。よって $$ N = ab $$(但し $$ 1 \lt a \leq b \land a, b \in \mathbb{Z} $$) となります。つまり、$$ N = ab \geq a^{2} $$ ですから $$ \sqrt{N} \geq a $$ となるのです。これを証明 (a) としておきましょう。さて、という事は、$$ a $$ が素数であるかは $$ \sqrt{a} $$ 以下の素数で mod 演算を行えば良い事となります。
さらに、`(1)`で奇数のみを対象としていますから、$$ 3 $$ から開始して、以降奇数のみで mod 演算を行えば良い事となります。これらは`(2)`に対応しています。`(3)`で mod 演算を行い、割り切れた時点で、`k`に`false`をセットしてループを抜けます。
さて、このアルゴリズムはどのような計算量となるでしょうか。
$$ a $$ が素数かを判定するのに最大 $$ \sqrt{a} $$ 回くらい(前述したように、ビッグオー記法の慣習からある程度の端数は切り落とされる)で、それを`n`回くらい繰り返しますから、このアルゴリズムは $$ O(n\sqrt{n}) $$ と表されます。<br>
次に少し賢い方法でこの問題に取り組んでみましょう。以下のコードは、エラトステネスの篩と言われるアルゴリズムを実装したものです。
```cpp
#include <cmath>
#include <vector>

template <class OutputIterator>
OutputIterator primes(unsigned int n, OutputIterator oiter)
{
    std::vector<bool> prime(n, 1);
    prime[0].flip();

    for (unsigned int i = 0, end = std::sqrt(n), k = 0; i < end; ++i) {
        if (prime[i]) {
            k = i + 1;
            for (unsigned int j = k * 2 - 1; j < n; j += k) prime[j] = 0;
        }
    }

    for (unsigned int i = 0; i < n; ++i) {
        if (prime[i]) *oiter++ = i + 1;
    }
    return oiter;
}
```
このアルゴリズムは、先ほどの証明 (a) を利用して、$$ \sqrt{n} $$ 以下の素数の倍数(自身を除く)を全て篩い落とすことで、素数を得るアルゴリズムです。例えば、$$ n = 30 $$、$$ A $$ を残っている素数集合とした時、篩い落としの様子は次の通りです。

1. $$ A = \{2, 3 ... , 30\} $$
2. 2 の倍数を篩落とし、$$ A=\{2,3,5,7,9,11,13,15,17,19,21,23,25,27,29\} $$
3. 3 の倍数を篩落とし、$$ A=\{2,3,5,7,11,13,17,19,23,25,29\} $$
4. 5 の倍数を篩落とし、$$ A=\{2,3,5,7,11,13,17,19,23,29\} $$
5. 7 は $$ \sqrt{30} $$ よりも大きいため終了

この処理によって、$$ \sqrt{n} $$ 以下の素数の個数分だけこの篩落としが行われます。

# 16.6 補数

この項ではコンピュータの基礎である補数の考え方とその利用例について説明します。

## 16.6.1 補数とは何か

ある定数値 $$ x $$ に対して $$ y $$ を足します。この時

1. $$ x + y $$ の結果、$$ x $$ の桁をあげる事となる $$ y $$
2. $$ x + y $$ の結果、$$ x $$ の現在の桁で最大の数値となる $$ y $$

をどちらも共に、**補数**と言い、1 を特に**真補数**、2 を特に**擬補数**と言います。補数には、この通り二つの種類があります。
そしてまた、補数は、基底の数(何進数か)によって変動します。
例えば 10 進数においては、10 という単位で桁が上がるので、1. のことを 10 の補数と言い、10 進数において 2. のことを 9 の補数と言います。
続けて 2 進数においては、2 という単位で桁が上がるので、1. のことを 2 の補数と言い、2進数において 2. のことを 1 の補数と言います。
つまり、ある値の $$ a $$ の補数と言われた場合、そのある値は $$ a $$ または $$ a + 1 $$ を基数とする値であり、$$ a $$ または $$ a + 1 $$ 進数のある値に対して桁上がりとなる値(真補数)、その桁の最大値となる値(擬補数)を補数と言います。

## 16.6.2 補数を求める

### 10 進数
10 進数の補数の求め方は直感的であるため、比較的容易です。
例えば、$$ 5 $$ という 10 進数値があるとします。
これに対する 9 の補数は $$ 5 + x = 9 $$ より $$ 4 $$ です。またこれに対する 10 の補数は $$ 5 + x = 10 $$ より $$ 5 $$ です。
次に、$$ 15 $$ という 10 進数値があるとします。
これに対する 9 の補数は $$ 15 + x = 99 $$ より $$ 84 $$ です。またこれに対する 10 の補数は $$ 15 + x = 100 $$ より $$ 85 $$ です。

### 2 進数
2 進数における補数表現の考え方はコンピューターでとてもよく利用される手法です。
例えば  $$ 011_{(2)} $$ という 2 進数値があるとします($$_{(2)} $$ は 2 進数値であることを表します)。
これに対する 1 の補数は $$ 100 $$ です。またこれに対する 2 の補数は $$ 101_{(2)} $$ です。なぜこの様になるのかは順を追えば理解できるはずです。

当然ながら二進数の世界では、1 つの桁が表せる種類が 2 通りしかありません。$$ 0_{(2)} $$ もしくは $$ 1_{(2)} $$ のみです。この次の値を表すには桁を上げるしかありません。
$$ 011_{(2)} $$ を二進数における 3 桁であると捉えると、この 3 桁で表せる最大の数値は $$ 111_{(2)} $$ですから、つまり、1 の補数は以下の様にして考える事ができます。
<br>
$$ 011_{(2)} + x = 111_{(2)} $$ <br>
この時の $$ x $$ が 1 の補数です。$$ 011_{(2)} $$ に何を足せば $$ 111_{(2)} $$ になるのでしょうか。$$ 100_{(2)} $$ですね。よって、1 の補数は $$ 100_{(2)} $$です。

次に 2 の補数について考えます。といっても、ここまで理解できていれば全く難しいことはありません。
2 の補数というのは、二進数において桁を上げる数値なので、単純に 1 の補数 + 1 の値になるはずです。
1 の補数は $$ 100_{(2)} $$でしたから、それに 1 を加えた $$ 101_{(2)} $$を $$ 011_{(2)} $$ に加える事で桁上がりが起きます。よって、2 の補数は $$ 101_{(2)} $$です。

これがわかると、慣例として言われる、「ある値のビット反転 + 1 がある値の 2 の補数である」という法則にも納得が行くはずです。
まずビット反転とは、単純に全てのビットが反転するという事です。つまり $$ 1_{(2)} $$だったら $$ 0_{(2)} $$になるし、$$ 0_{(2)} $$ だったら$$ 1_{(2)} $$ になるという事です。
例えば、$$ 1010_{(2)} $$ という値をビット反転したら $$ 0101_{(2)} $$、$$ 1100_{(2)} $$という値をビット反転したら$$ 0011_{(2)} $$です。

「ある値のビット反転 + 1 がある値の 2 の 補数である」という話に戻します。
先ほどの例の数値$$ 011_{(2)} $$を再度用います。この値をビット反転した値は、$$ 100_{(2)} $$です。これは、先ほど求めた 1 の補数です。
これに 1 を加えると先ほど求めた 2 の補数ですね($$ 101_{(2)} $$)。これが、「ある値のビット反転 + 1 がある値 2 の補数である」の仕組みです。

## 16.6.3 何に使えるのか
結論から言えば、これはコンピューターによる減算でよく利用されています。
実は、コンピューターによる減算は回路を簡素化するために、足し算で行われています。
例えば$$ x - x = y $$で、$$ y $$を加算のみで演算しようとすると以下の様になります。
\\[ x + (x の 2 の補数) から桁上がりの部分を捨てた値 = y \\]
実際に値を入れると分かりやすいでしょう。$$ x $$ を $$ 011\_{(2)} $$とすると、
\\[ 011\_{(2)} + (011\_{(2)} の 2 の補数) から桁上がりの部分を捨てた値 = y \\]
となります。次に、$$ 011\_{(2)} $$の 2 の補数を求めると以下の様になります。
\\[ 011\_{(2)} + 101\_{(2)} から桁上がりの部分を捨てた値 = y \\]
これを演算します。$$ + $$ 表記があるので、加算を行います。
\\[ 1000\_{(2)} から桁上がりの部分を捨てた値 = y \\]
後は、「桁上がりの部分を捨てた値」について処理すれば完了です。
$$ 011\_{(2)} + 101\_{(2)} $$の加算処理によって、ここまで 3 桁であったものが 4 桁の 2 進数値になりました。
「桁上がりの部分」とは、この時$$ 1000\_{(2)} $$の先頭の$$ 1\_{(2)} $$ を示します。
\\[ 000\_{(2)} = y \\]
このようにして、演算結果である $$ 0 $$ を $$ - $$ を使わずに加算だけで求める事ができました。別の値でもやってみましょう。

例えば、$$ 5 - 3 $$ を上記の手法で解いてみます。$$ 5 $$ は二進数表記で$$ 101_{(2)} $$、$$ 3 $$ は二進数表記で$$ 011_{(2)} $$です。<br>
\\[ 101_{(2)} + (011_{(2)} の 2 の補数) から桁上がりの部分を捨てた値 = y \\]
$$ (011_{(2)} の 2 の補数) $$ を展開すると以下の様になります。
\\[ 101_{(2)} + 101_{(2)} から桁上がりの部分を捨てた値 = y \\]
$$ 101_{(2)} + 101_{(2)} $$ の加算を行います。<br>
\\[ 1010_{(2)} から桁上がりの部分を捨てた値 = y \\]
桁上がりを捨てます。
\\[ 0010_{(2)} \\]
$$ 0010_{(2)} $$ は 10 進数で $$ 2 $$ です。正しく計算が行えました。<br>
このようなコンピューターの基本的な演算に利用される補数という概念ですが、
この性質を利用したビット演算などが有名です。例えば、次の一行は、右端に立っているビットのみを残してそのほかを全て $$ 0_{(2)} $$ するコードです。
```cpp
x & (-x)
```
コード中の`-`によって、`x`の内部では補数表現によって値が表現されます。例えば、`x` が 3 ビットのデータで、中には $$ 011_{(2)} $$ が入っているとしてこの演算を見てみると一目瞭然です。
```cpp
0b011 & 0b101
```
これで`0b001`が残ることがわかります。別の値でもやってみましょう。`x`を 6 ビットとして中身を $$ 101010 $$ としてみます。
```cpp
0b101010 & 0b010110
```
これも`0b000010`というように最後のビットを取ることができました。これまでの説明からもわかるように、元の値のビット反転 + $$ 1 $$ が元の値のマイナスを示すという性質を利用していますね。

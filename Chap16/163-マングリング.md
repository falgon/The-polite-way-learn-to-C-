# 16.3 マングリング

C++プログラムをコンパイルする段階でマングリングという処理がされます。

「16.2 エントリポイント」で取り上げたC言語のコードをエントリポイントを指定してコンパイルしましょう。
```cpp
#include<stdio.h>
int hoge()
{
	puts("hoge only");
}
```
```cpp
gcc -e hoge() a.c
```
コンパイルに成功します。さて、では上記のC言語コードを、下記のように少し改変してコンパイルを行って見ましょう。
```cpp
#include<cstdio>
int hoge()
{
	std::puts("hoge only");
}

int hoge(int){}
```
```cpp
g++ -e hoge() a.c
```
私の環境では以下のようなエラーが出力されました。
```cpp
2 warnings generated.
Undefined symbols for architecture x86_64:
  "hoge", referenced from:
     implicit entry/start for main executable
     (maybe you meant: __Z4hogei, __Z4hogev )
ld: symbol(s) not found for architecture x86_64
```
何やら、`__Z4hogei`と`__Zhogev`というような`hoge`というものを意味していますか？といったような内容が出力されました。ここでは__Zhogevを指定してみましょう。
```cpp
g++ -e __Z4hogev a.cpp
```
これで、正しくコンパイルされました。実行結果も意図した通り、うまくいくようです。
```cpp
hoge only
```
というようにC言語では関数名をそのまま指定するだけでエントリポイントを指定できていましたがC++言語では失敗してしまいました。何故でしょうか。

結論から言えば、Cの場合とは異なり、C++では、同じ名前を持つ関数が複数存在することが有りうるからです。関数のオーバーロードや名前空間の異なる同名の関数などは良く使う例ですね。C++コンパイラは、同名の関数をそれぞれ識別するために、シグネチャや名前空間などをラベルに付加して埋め込むことで、適切な関数の呼び出しができるようになっているのです。このような動作をマングリングといいます。
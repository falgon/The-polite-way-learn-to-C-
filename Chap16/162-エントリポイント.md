# 16.2 エントリポイント

例えば、WindowsのGUIプログラムを記述しようとした時に、以下が最小のプログラムであるというのを見た事はないでしょうか。
```cpp
#include <windows.h>
int WINAPI WinMain(
HINSTANCE hThisInst,
HINSTANCE hPrevInst,
LPSTR lpszArgs,
int nWinMode
)
{
// ....
}

// main関数がない
```
`WinMain`という関数が`main`関数の代わりをしているかのように振舞います。

また、SDLというグラフィックハードウェアへのアクセスを提供するライブラリでは、`main`関数を記述できるかのように思えます。
```cpp
#include<sdl/sdl.h>
int main(int* argc,char* argv[])
{
// ....
}
```
sdl.hというヘッダーファイルを辿っていくと、中には以下のような記述があります。
```cpp
//SDL_main.h
#define main SDL_main
/** The prototype for the application’s main() function */
extern C_LINKAGE int SDL_main(int argc, char *argv[]);
```
これはつまり、`main`と記述した場合、`SDL_main`へと置き換わるという事です。よって、SDLライブラリをインクルードした状態で`main`関数を記述すると
```cpp
#include<sdl/sdl.h>
int main(int* argc,char* argv[])
{
// ....
}
```
以下のように置き換わるのです。
```cpp
#include<sdl/sdl.h>
int SDL_main(int argc, char *argv[])
{
// ....
}
```
となると、コードからは`main`関数が全くどこにもない事になってしまいました。「2.2 最小のプログラム」で説明したようにプログラムは`main`関数から開始されるはずです。これは、何故コンパイルに成功し、`main`関数の代替のように振る舞えるのでしょうか。
結論から言えば、**エントリポイント**をコンパイル時に設定する事で任意の関数名からプログラムを開始する事ができるからなのです。エントリポイントとは、開始するプログラムの位置を言います。

例えば前述した`WinMain`について取り上げると、この`WinMain`のコードをコンパイルするにはリンカオプションで/SUBSYSTEMを `WINDOWS`に指定しなければなりません。すると、リンカは `WinMain`という名前の関数を探して、それをプログラムのエントリポイントに設定します。「エントリポイントに設定する」事でOS がプログラムを実行するために実行ファイルをメモリに読み込んだ後、どのアドレスからプログラムを実行するか指定する、ということです。

実行形式ファイルのヘッダ部分には、エントリポイントのアドレスを書き込む場所があります。その部分にリンカが指定されたエントリポイントの情報を書き込むのです。

ちなみにリンカオプション /ENTRY で、エントリポイントなる関数の名前を変更することが出来ます。 例えば、WinMain という名前が嫌なら違う名前に変えても構いません。
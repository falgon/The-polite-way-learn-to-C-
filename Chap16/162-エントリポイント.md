# 16.2 エントリポイント

例えば、WindowsのGUIプログラムを記述しようとした時に、以下が最小のプログラムであるというのを見た事はないでしょうか。
```cpp
#include <windows.h>
int WINAPI WinMain(
HINSTANCE hThisInst,
HINSTANCE hPrevInst,
LPSTR lpszArgs,
int nWinMode
)
{
// ....
}

// main関数がない
```
`WinMain`という関数が`main`関数の代わりをしているかのように振舞います。

また、SDLというグラフィックハードウェアへのアクセスを提供するライブラリでは、`main`関数を記述できるかのように思えます。
```cpp
#include<sdl/sdl.h>
int main(int* argc,char* argv[])
{
// ....
}
```
sdl.hというヘッダーファイルを辿っていくと、中には以下のような記述があります。
```cpp
//SDL_main.h
#define main SDL_main
/** The prototype for the application’s main() function */
extern C_LINKAGE int SDL_main(int argc, char *argv[]);
```
これはつまり、`main`と記述した場合、`SDL_main`へと置き換わるという事です。よって、SDLライブラリをインクルードした状態で`main`関数を記述すると
```cpp
#include<sdl/sdl.h>
int main(int* argc,char* argv[])
{
// ....
}
```
以下のように置き換わるのです。
```cpp
#include<sdl/sdl.h>
int SDL_main(int argc, char *argv[])
{
// ....
}
```
となると、コードからは`main`関数が全くどこにもない事になってしまいました。「2.2 最小のプログラム」で説明したようにプログラムは`main`関数から開始されるはずです。これは、何故コンパイルに成功し、`main`関数の代替のように振る舞えるのでしょうか。
結論から言えば、**エントリポイント**をコンパイル時に設定する事で任意の関数名からプログラムを開始する事ができるからなのです。

例えば前述した`WinMain`について取り上げると、この`WinMain`のコードをコンパイルするにはリンカオプションで/SUBSYSTEMを WINDOWSに指定しなければなりません。それに指定した段階で、デフォルトのエントリポイントが**WinMain**となるのです。

リンカオプションでサブシステムを指定する、ということは簡単に言うと 「どんな環境用のコードを生成するか指定する」 ということです。 Windows 向けのコードなら WINDOWS という値を、 ウィンドウを持たないキャラクタベースのプログラムなら CONSOLE という値を、 携帯端末用のモバイル Windows 用なら WINDOWSCE という値を、それぞれ指定します。

サブシステムとして WINDOWS が指定されていると、リンカは WinMain という名前の関数を探して、それをプログラムのエントリポイントに設定します。 「エントリポイントに設定する」ということは、OS がプログラムを実行するために EXE ファイルをメモリにロード (読み込む) した後、どのアドレスからプログラムを実行するか指定する、 ということです。実は EXE ファイルのヘッダ部分にエントリポイントのアドレスを書き込む場所があり、 リンカはその情報を埋めるために WinMain という関数のアドレスを探しているのです。

ちなみにリンカオプション /ENTRY で、エントリポイントなる関数の名前を変更することが出来ます。 例えば、WinMain という名前が嫌なら違う名前に変えても構いません。
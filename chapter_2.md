# Chapter 2:C++の基本

殆どのプログラミング入門書は、Hello,World!といった文字列を出力するプログラムを、始めに作成します。しかし、筆者としては突然Hello,World!を提示されても、学習者からすると意味がわからないとも思うのです。以下をいきなり掲示されて、コードの細かい部分まで何をしているのか予測がつきますでしょうか。

```cpp
#include<iostream>
int main()
{
    std::cout << "Hello,World!" << std::endl;
}
```

本書ではそのような方向からのアプローチを避け、一つ一つ概念を理解してからコードの解説に移行します。<br>本章では以下のような流れで解説をしていきます。

1. 作業フォルダ(ディレクトリ)の作成

2. 変数とデータ型

3. 最小のプログラムと実際のコード

4. 配列 その1

## 2.1 作業フォルダ(ディレクトリ)の作成

これからいよいよC++プログラミングを始めますが、その前に一旦作業フォルダ(ディレクトリ)を作成すると良いでしょう。ターミナルで

```sh
mkdir LearningCpp && cd LearningCpp
```

とする事で、LearningCppという名前のフォルダ(ディレクトリ)を作成する事ができます。そしてその後にLearningCppフォルダに移動しています。

## 2.2 変数とデータ型

プログラミングにおいて大事な概念が変数と言われるものです。変数とは箱のようなものと言われることもある概念です。

### 2.2.1 基本的概念

例えば、以下のような式があるとします。

```cpp
1 + 1
```

これは、1と1を加算した結果を得れますね。しかしそれ以外の場合を想定する事はできません。もし1に2を加算した式を書きたければ、このように書きかえる必要があります。

```cpp
1 + 2
```

では、`1 + n`といった、どんな数値がくるのか分からない場合はどうすればいいのでしょうか。そういった場合には以下のように書きます。

```cpp
1 + n
```

そして、例えば、nが2であったら？以下のように書きます。

```cpp
n = 2
1 + n
```

これで、nがどんな数字であろうが1を加算する事ができるようになりました。これは、nは2であると前提を置いているので、`1 + 2`という意味合いになりました。<br>1を足すだけでは、このようにnとして配置することに特に良さを感じないかもしれません。では、もう少しだけ式が複雑になった場合、例えば直径20の円の面積を求めたいとしたら、どうでしょうか。

```cpp
20/2 * 20/2 * 3.14
```

これは、誰しもよく知っているであろう、円の面積の求め方に基づいた一式です。`*`が掛け算で、`/`が割り算です。では直径dの円の面積は、どのように求められるでしょうか。さらに、円周率は3.14で計算していますが、その定義によって変動させたい場合、どういった式になるでしょうか。3.14で計算する場合もあれば、3で計算する場合もあるでしょうし、3.141592653...で計算する事も考えられます。

```cpp
pi = 3
d/2 * d/2 * pi
```

はい、簡単ですね。この場合は、円周率を3としています。<br>ここまでを理解できたのであれば、変数について理解する事の大きな一歩を既にふみ終えています。つまりこの`d`や、`pi`、先ほど述べた`n`などの事を変数と言うのです。<br>この基本的な概念に、制約や決まりが上付けされているものがC++においての変数の概念です。<br>それでは、C++の変数の概念を、今まで述べてきたものに上付けしていきましょう。

### 2.2.2 代入

式`n=2`があるとします。これは<i>nは2と同等である</i>という意味に思えるかもしれませんが、C++では異なります。正しくは、<i>nに2を代入する</i>という意味になります。代入とはつまり、以下のような事ができるようになるという事です。

```cpp
n = 1
1 + n // (1)
n = 10
1 + n // (2)
```

(1)の式はどうなるでしょうか。nに1を代入しているので、`1 + 1`となりますね。では、(2)の式はどうなるでしょうか。nに1を代入して`1 + 1`となった後、再度nに今度は10を代入しています。ここで、先ほど代入された1は上書きされnは10となります。つまり2番の式は、`1 + 10`となります。<br>

### 2.2.3 データ型

例えば、Aさんは箱を持っていました。Aさんの箱の中身を他人が見る事はできません。そして、その箱に何を入れるかは明記されていないものとします。そしてある日、BさんはAさんの箱を見つけました。BさんはAさんから何が入っているのか話されない限り、何が入っているのか知り得る事はできません。<br>Aさんが、もしその箱に例えば、「おもちゃ箱」と書いたとすれば、Aさんとの会話なしに、おもちゃが中に入っていると期待できます。このように、「おもちゃ」の箱とする事によっておもちゃしか入れる事はないという条件を課しています。 <br>というように、条件を課せれば課せるほど、課せられたものに対する信頼度は上がります。ではここで、先ほどの式 `n + 1`に、条件を加える事としましょう。例えば、nは符号付きの整数の数値だけを入れて欲しいとします。符号付きとは、負数も扱うという事です。そういった場合、C++では以下のように書きます。

```cpp
int n = 1;
1 + n;
```

`int`というワードが出てきました。これは、integerの略で、代入(この場合は厳密には初期化。代入と初期化の違いは後述)には整数値を期待するという意味になります。こういった指定を型と言います。<br>また<code>;</code>と末尾に書かれています。これは、データ型の話題とは無関係のものですが、C++プログラムの一文の区切りとして<code>;</code>が書かれます。日本語で言えば、句読点であったり、英語でいえば、ピリオドみたいなものと言えます。

### 2.2.4 扱える数値の範囲

型には、それぞれ扱える数値の範囲があります。<code>int</code>と変数を宣言した場合、扱える数値は、-2,147,483,648 ～ 2,147,483,647の間のみとなります。さらに大きな範囲が必要であれば、これについては後述しますが、<code>long</code>というキーワードを用います。

```cpp
long long n = 9223372036854775807;
n = -9223372036854775808;
```

<code>long long</code>という型では明記した通り、`-9,223,372,036,854,775,808`から`9,223,372,036,854,775,807`までの範囲の整数値を扱う事ができます。これ以上の数値は、中々実務でも扱う事はないので、十分な範囲と言えるでしょうが、もし範囲以上、以下の値を代入してしたらどうなってしまうのでしょうか。それは、その型の中では表現できない値となるので、正常でない数値となってしまう事が殆どです。(処理系に依存するため明記していません)このような事は、オーバーフロー、アンダーフローと言われています。少し話が飛んでしまいましたが、では<code>int</code>とされた<code>n</code>に対して、整数値以外の値を代入した場合、どうなるのでしょうか。

```cpp
int n=3.14;
```

この場合、nは3となります。整数値が代入されると期待している中で、小数点以下を扱う値を代入すると、非対応部分は切り捨てされるのです。

### 2.2.5 バイト、ビット

バイト、ビットという単語が少し出てきますので事前に説明します。<br>バイトとはbyteと書き、単位の事を言います。そして1byteとは8ビットのことです<i style="font-size:11px;">[注釈1]</i>。

<br>ビットはbitと書き、２進数の0,1の事を言います。つまり、bitはコンピューターの最小単位であり、byteというのはそれが八つで1単位としているものです。

<p style="font-size:11px;"><i>1.</i>&nbsp;実際のところを言うと、実はC++では「1ビットとは8バイトである」という明確な定義はされていません。唯一定義されているのは、「char型のサイズが1バイトである」という事だけです。そして、そのビット数の定義は、CHAR&#95;BITマクロ(マクロについては後述しますので現時点で理解する必要はありません。現時点ではCHAR&#95;BITマクロとは、1バイトが何バイトであるか定義されているものぐらいの認識で大丈夫です。)にされおり、少なくともそのビット数は8以上に定義される事が保証されてはいますが、実際のところ、8ビット以上であれば何ら言語使用上では問題の無い事になりますので、つまるところ、1バイトのビット数の定義は実装依存という事になります。</p>

### 2.2.6 データ型の一覧

前述した通り、C++では変数にはデータ型を指定します。ここまでの話だと整数値しか扱っていませんが、もちろん、様々な数値に対応できるよう、様々なデータ型がC++には用意されています。

* 整数型

* 浮遊少数型

* 文字型

* 論理型

それぞれについて解説していきますが、32bitか64bit環境かで扱う事のできる数値範囲が変動したり、処理系によっては扱える数値の範囲が異なるため、ここではより一般的に捉えられる数値を例に挙げて説明する事とします。「この型はこの数値である」と、どの環境でも数値範囲が変動しないよう定義された型も存在していますが、それについては追々解説する事とします。

#### 整数型

整数型とは前述したような、整数値を扱う事のできる型です。<br>それぞれshort、int、longという型が整数型に含まれます。

| 型 | バイト長 | 数値の範囲 | 
| -- | -- | -- | 
| (signed) short (int) | 2 | -32768～32767 | 
| unsigned short (int) | 2 | 0～65535 | 
| (signed) long (int) | 4 | -2147483648～2147483647 | 
| unsigned long (int) | 4 | 0～4294967295 | 
| (signed) int | 2 or 4 | (signed) short (int)もしくは(signed) long(int)と同じ | 
| unsigned int | 2 or 4 | (signed) short (int)もしくは(signed) long(int)と同じ |

`(signed)int`と`unsigned int`についてはバイト長の定義が曖昧となっていますね。これには、コンピューターの進化の歴史があり、これまた環境によって変動するものです。

#### 浮遊少数型

浮遊少数型とは、大まかに言えば、少数点を扱う事のできる型です。

| 型 | バイト長 | 数値の範囲 |
| -- | -- | -- | 
| float | 4 | 1.175494e-38〜3.402823e+38 | 
| double | 8 | 2.225074e-308〜1.797693e+308 |

#### 文字型

文字を扱える型です。繰り返し述べますが文字を扱える型です。文字列ではありません。両者の違いとは、'a'という一文字か、"abc"という何文字かを含むものかといったところです。文字にはシングルクォーテーション<code>'</code>、文字列にはダブルクォーテーション<code>"</code>を用います。

| 型 | バイト長 | 数値の範囲 | 
| -- | -- | -- | 
|(signed) char | 1 | -128～127 | 
| unsigned char | 1 | 0～255 |

#### 論理型

論理型とは、trueという値と、falseという値を格納する事のできる型です。

| 型 | バイト長 | 数値の範囲 | 
| -- | -- | -- | 
| bool | 1 | `true`,`false` |

trueは通常整数にすると1、falseは0となっています。つまり、1と0のみを格納できるという事になります。 <br><br>以上が、C++における変数という概念になります。型ごとに「格納できる数値の種類が異なる」そして、「その型の箱の名前を自由に設定できる」というのが変数であり、変数はたったそれだけのものです。変数名に関して言えば、これまで、やたら`n`やら`a`やら`b`やら`pi`といったような変数名を用いてきましたが、`hoge`だろうが`nemuidesu`だろうが、`watashinonamaehataroudesu`だろうが、規格上の問題はないわけですが、変数名には一般的に、その変数へ格納される値が何を表しているのか分かりやすくするため、文脈上捉えやすい名前を付ける事が好ましいとされています。また、ある一部の名前は予め変数名などの識別子として名付けてはならないとされているものも存在します。それはどのようなものなのでしょうか。順に見ていきます。

### 2.2.7 識別子へ名付けてはならない名前
C++には識別子へ名付けるとタブーとされる言葉があります。以下に、識別子として使用するとタブーとされる言葉を列挙します。多くはコンパイルエラーを吐いてくれますが規格では禁止とされているもののコンパイルエラーとはしないといったものもあるため、気をつけなければなりません。

* 数字から始まる識別子
```cpp
int 1234_abc; // 規格違反 & エラー
```
規格に反するため一般的なコンパイラはエラーを吐きます。

* キーワード(予約語)として登録されている文字列
```cpp
int int; // int型のintという変数。規格違反 & エラー
```
規格に反するため一般的なコンパイラはエラーを吐きます。
以下のような場合であれば規格違反とはなりません。
```cpp
int int_; // 名前に_があるため別の文字列として捉えられる。違反ではない。(視覚的に分かりにくいので推奨しない)
```
今回は例として`_`を`int`の後ろに付与する事で予約語を回避しましたが、`_`以外の文字でももちろん構いません。つまり**名付けた識別子の中に予約語が含まれているが予約語と全く同じ文字or文字列ではなければ違反ではない**という事です。

* 演算子の代替表現
<br>演算子については後ほど説明しますが、ここでは以下のワードは予め予約された言葉であるため、識別子として扱う事はできないと捉えてください。
```cpp
// 以下は全て規格違反 & エラー
int and; // operator &&の代替表現として予約済み
int and_eq; // operator &=の代替表現として予約済み
int bitand; // operator &の代替表現として予約済み
int bitor; // operator |の代替表現として予約済み
int compl; // operator ~の代替表現として予約済み
int not; // operator !の代替表現として予約済み
int not_eq; // operator !=の代替表現として予約済み
int or; // operator ||の代替表現として予約済み
int or_eq; // operator |=の代替表現として予約済み
int xor; // operator ^の代替表現として予約済み
int xor_eq; // operator ^=の代替表現として予約済み
```
これらは全て規格に反するため一般的なコンパイラはエラーを吐きます。先ほど述べた`int_`のように何か違う文字や文字列が付与されている場合は違反ではありません。

* アンダースコアで始まりその後大文字が続く文字列
```cpp
int _Cplusplus; // 規格違反だが一般的にコンパイルエラーを吐かない。
```
`_Cplusplus`のように、`_`の後に大文字である`C`が続く識別子は規格違反です。しかし、コンパイラはエラーを吐いてくれません。エラーを吐かないからと言ってそのまま使用した場合動作保証はされませんので使うべきではありません。

* アンダースコアが連続する文字列
```cpp
int __a; // 規格違反だが一般的にコンパイルエラーを吐かない。
int b__; // 後置でも規格違反だが一般的にコンパイルエラーを吐かない。
```
`_`が2回以上連続して現れる識別子は規格違反です。こちらも同じく規格違反のコードの動作保証はありませんのでコンパイラが通しても使うべきではありません。

* アンダースコアから始まるグローバル変数
<br>グローバル変数の概念は後ほど説明しますが、一旦ここで明示しておきます。
```cpp
int _a; // グローバル変数名にアンダースコアから始まる名前を付けてはならないため規格違反だが一般的にコンパイルエラーを吐かない。
int main()
{}
```
グローバル変数にはアンダースコアが連続しなくても先頭に付与された場合、規格違反となります。ローカル変数の先頭に識別子としてアンダースコアを付与する事は違反ではありません。


<br>それでは最後に、ここまで説明してきた変数という概念を用いて変数を操作をしてみましょう。いくつか、サンプルを載せておく事とします。
```cpp
int a = 100;
int b = 200;
int result = a + b; // resultは300
```

```cpp
float pi = 3.14;
int r = 5;
double area = r * r * pi; // areaは78.5
```

```cpp
int a = 3.14; // aは3
int b = 2147483648; // int型の扱える数値範囲を超えているためオーバーフロー。意図した通りの数値は格納されない
```

```cpp
char a = 'a'; // aは'a'
char b = 65; 
/* bも'a'。a b c d e...という各文字はアスキーコードと言われる数値に全て当てはめられており、
65はaに該当する数値です。*/
```

```cpp
bool b = true; // bはtrue。1と等しい。
bool bb = false; // bbはfalse。0と等しい。
```

...と、ここまでデータ型について見ていきましたが、ところでこういったような記述はC++で出来るのでしょうか？

```cpp
x = 10; // 宣言していない変数xに対して代入
```

これは、できません。何故ならば使われる変数は**宣言**をされなければならないからです。

### 2.2.8 宣言

C++では、使われる変数は、全て事前に**何の型の何という変数名か**を宣言しなければ使う事はできません。つまり前述した通り、突然以下のようには書けないという事です。

```cpp
x = 10; // 宣言していない変数xに対して代入
```

10は一般的には整数型ですから、もし変数`x`を使いたいの出れば、事前にこのように書く必要があります。

```cpp
int x;
x = 10;
```

こうして`x`を使う前に型と変数名を宣言してあげる事によって、コンパイラがこの変数はどういったものなのかという事を理解する事ができます。また、プログラマー自身も、この変数にはどういったデータが入るべきなのかを視覚的に捉える事ができます。

## 2.3 最小のプログラムと実際のコード

変数の概念を理解したところで、これから、いよいよ初めてのプログラムを作ります。しかし初めから色々な機能のあるプログラムを作成する事は不可能なので、まずは最小のプログラムを作っていきます。<br>

### 2.3.1 main関数とreturn文

そもそも、C++のプログラムを作るのにどのような知識が必要になるでしょうか。それにはまず、そのプログラム言語の構造を知る事が第一です。<br>例えばあなたは木製の椅子を作ろうとしました。しかし木製の椅子を作るには、木製の椅子の構造を知っていなければ、作りあげる事はできません。<br>ではC++の構造とはどのような構造なのでしょうか。木製の椅子を作るためには様々な椅子に合いそうな木、つまり部品が必要になります。プログラムも、同じように部品の集合で成り立っているのです。その部品をC++では関数と言います。<br>そして以下が、C++の最小のコードであり、全てはここから始まります。

```cpp
int main(){}
```

これは、「メイン関数」と言います。C++のプログラムには、メイン関数が1つ必ずなくてはなりません。そして、メイン関数の<code>{}</code>内に処理を書く事ができます。しかし、今は何も書いていないので、これは何もしません。<br>意味合いとしては、「int型のデータを返すmainという名前の関数」という意味合いになります。<br>int型のデータを返すとはなんでしょう？まずメイン関数は、プログラムを実行した際、一番初めに実行される内容となります。このプログラムが起動した後、このコードには、何も記述されていないので、何もせずに、メイン関数でプログラムを終了する事になります。そのプログラムを終了する際に、プログラムを実行した元のプログラムへ、数値を返すという慣習があるのです。 <br>例えば、Windowsで、「a」というアプリケーションを起動したとします。「a」は正しく処理がなされました。しかし、起動元であるWindowsは、そのアプリケーションが正しく処理されたかどうか知ることができません。そこで、「a」というアプリケーションは、例えば0という数値をWindowsへ返したとします。そしてWindowsは0という数値が返ってくると正常に終了したと認識するとします。ここで初めて、Windowsは「a」というアプリケーションは正常に実行されたという事が認識できるのです。このような事のために、メイン関数にはintという数値を返す関数であるという定義を行います。つまり、上記のコードは厳密に言えば、こう書くべきかもしれません。

```cpp
int main(){return 0;}
```

このように<code>return value;</code>と書く事で、その<code>value</code>を起動元のプログラムへ返し、その関数の処理が終了します。つまり上記のプログラムは0を返してプログラムを終了しろという意味になります。<br>初めにreturn文を省略した訳は、実行結果を判定する必要の無いプログラムだからです。そういった場合は、return文を省略しても構わない事となっています。<br>

### 2.3.2 インデント

先ほど、私は以下が最小のコードだと述べました。

```cpp
int main(){}
```

しかし、これはこのように記述する事ができます。

```cpp
int main()
{
}
```

このように書くこともできます。

```cpp
int main()
{
                    }
```

このようにも。

```cpp
int
main(
){
}
```

このように、キーワード単位が守られた記述であれば、どのように改行したりスペースを入れたり、タブを入れたりしても構わない事となっています。このようにスペースやタブ等の事をインデントと言います。<br>ただ一つ注意してほしいのが、全角のスペースです。コードの中には全角のスペースでインデントを入れる事はできません。もし全角スペースでインデントを入れると、コンパイラ(GCC 6.1.0)はこのようなエラーを出力します。<pre>t.cpp:3:1: エラー: プログラム内に逸脱した ‘\343’ があります ??? ^t.cpp:3:2: エラー: プログラム内に逸脱した ‘\200’ があります ??? ^t.cpp:3:3: エラー: プログラム内に逸脱した ‘\200’ があります ??</pre>全角スペースは、視覚的に確認できるものではないので、タイプミスなどで挿入してしまう場合があります。注意しましょう。

### 2.3.3 コメント

ここでついでに、コメント機能についても触れておきましょう。コメントとは、プログラムに注釈のような一言メモを添えておける機能です。実は、ここまでで示したサンプルコードの中にも、いくつかコメントが書かれていました。

```cpp
int x=10; // xには10が入ってます
```

<code>//</code>から先は、プログラム中に日本語が含まれています。<code>//</code>を使う事で<code>//</code>以降その段落はコメントとしてコンパイラに捉えられるので、何を書いても良い事になっています。

```cpp
int x=10; // xには10が入っているはずなんですよね〜〜ああ、お腹すいたな。
```

と書いてもプログラム上は問題ありません。(無関係な内容を書くべきではありません)<br>また、<code>//</code>以外に、<code>/&#42; &#42;/</code>というようなコメント機能もあります。

```cpp
int x=10; /* xには10が入っていると思われるのであります。 */
```

<code>/&#42; &#42;/</code>で囲んでいる範囲はコメントとなるので、何を書いてもプログラム上は問題ありません。(無関係な内容を書くべきではありません)

### 2.3.4 数値演算のプログラム

ここまでで、変数とmain関数の概念を説明しました。以上の概念を用いて、ついに実際のプログラムを作る事ができます。

```cpp
int main()
{
    int a=10,b=10;
    int result=a+b;
}
```

<code>result</code>に<code>a</code>と<code>b</code>の加算結果を得るというプログラムを書く事ができるようになりました。尚、変数宣言は上記のように、<code>,</code>を使う事で連続的に変数を宣言する事ができます。動きとしては、下記コードと同じです。

```cpp
int main()
{
    int a=10;
    int b=10;
    int result=a+b;
}
```

ただ、<code>,</code>を用いて変数宣言をした以上、<code>,</code>で宣言された変数は全てその型となるという事を注意してください。つまり、

```cpp
int main()
{
    int a=10,b=3.14;
}
```

とした場合、bには3が代入されるという事です。3.14を代入したければ、

```cpp
int main()
{
    int a=10;
    double b=3.14;
}
```

のように別の型を用いて定義しなければなりません。

## 2.4 配列 その1

ここで、配列という少し新しい概念を説明します。ただ、配列の概念はこれから新たに学ぶ他概念を含んだものでもありますので、ここでは一旦軽く触れる程度の解説をします。そのため、配列の細かい概念、定義はまた後に取り上げる事としていますので、本項をその1としています。<br>では、見ていきましょう。配列は、以下のような場合に有効的な概念です。

```cpp
int main()
{
    int a,b,c,d,e,f,g,h,i,j,k,l,m;
}
```

整数型の変数<code>a</code>~<code>m</code>の13個の変数が宣言されています。<br>13個であるなら、確かにまだ<code>a</code>~<code>m</code>を手で打てますね。では1000個の変数を宣言したい場合はどう書きますか？

```cpp
int a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a1,a2,a3...
```

と全て手で入力していては、日が暮れてしまいますね。<br>そこで、配列という概念を用いる事で、以下のように書く事ができます。

```cpp
int main()
{
    int a[1000];
}
```

<code>型 変数名[要素数];</code>と記述する事で一気に要素数分の変数を宣言する事ができます。<br>しかし、こう思うかもしれません。<br>「<code>int a,b,c,d,e,f...</code>と書いたら<code>b</code>とか<code>f</code>とか書く事でその変数への操作が出来るけど、<code>int a[1000];</code>と書いたら1000個分のうちのどれに操作するのかとか書けないんじゃ...？」<br>いいえ、その心配はありません。例えば、20番目の変数に対して操作がしたいのであれば、以下のように記述できます。

```cpp
int main()
{
    int a[1000];
    a[19];
}
```

<code>変数名[アクセスしたい要素の値]</code>と記述する事でその要素へ操作を行う事が可能です。ここでまた、<br>「え、20番目の変数に対して操作がしたいのに、19って書いてあるじゃないか！」<br>と思うかもしれません。実はその理由は、配列の要素は0から始まるというところにあります。例えば三つの要素数を持つ配列を定義した場合、以下のようになります。

```cpp
int main()
{
    int a[3]; // a[0],a[1],a[2]を操作できる
}
```

つまり、`int a[3];`と書かれたものに対して、`a[3];`と操作を行う事はできないという事です。`a[4];`でも`a[200];`でも同じです。`型 変数名[要素数]`と宣言された場合、指定できる要素数は、`変数名[要素数-1]`となるという事が言えます。これはとても大切で、肝に銘じるべき内容です。宣言された配列の要素数以上への操作は絶対にしてはいけません。もしそのような操作を行った場合、プログラムの挙動がどうなるかは全く保証されていません。大抵の場合、segmentation faultというエラー文と共にプログラムが強制終了するでしょうが、環境によってOSが破壊される可能性もゼロではありません。宣言された配列の要素数以上への操作は絶対に記述しないようにしましょう。

最後に、配列に対する初期化はどのように書けばいいのでしょうか。代入であれば以下のように書く事ができる事が考えられますね。

```cpp
int a[3];
a[0]=10;
a[1]=20;
a[2]=30;
```

初期化は、以下のように記述します。

```cpp
int a[3]={10,20,30};
```

この場合、それぞれ、`a[0]`は10、`a[1]`は20、`a[2]`は30で初期化されます。また、この一文は以下のようにも記述できます。

```cpp
int a[]={10,20,30};
```

要素数が明示されていませんが、文法として正しい一文です。このように、初期化の際に値を設定するのであれば、要素数を省略する事ができます。この場合、aの要素数は自動的に3となり、それぞれ<code>a[0]</code>は10、<code>a[1]</code>は20、<code>a[2]</code>は30で初期化されます。

では、以下はどのような出力結果となるでしょうか。

```cpp
#include<iostream>
int main()
{
    int a[3]={};
    std::cout<<a[0]<<'\n'<<a[1]<<'\n'<<a[2]<<std::endl;
}
```
実行結果は以下のようになります。
```cpp
0
0
0
```

なんと全ての要素の値が0で初期化されています。これは、規定された言語上の仕様です。空のリストを初期化時に指定すると要素の値は全て0で初期化されます。では、以下の場合、どのような出力結果となるでしょうか。

```cpp
#include<iostream>
int main()
{
    int a[3]={42};
    std::cout<<a[0]<<'\n'<<a[1]<<'\n'<<a[2]<<std::endl;
}
```

実行結果は以下のようになります。

```cpp
42
0  
0 
```

3つ要素がある中で、初期化値として指定したのは一つの値、`42`だけです。この場合、先頭の要素が指定された値に初期化され、残りの要素は全て0で初期化されます。これも、規定された言語上の仕様です。

これは余談ですが、以下のようなコードを書く事はC++では規格違反です。

```cpp
int a[3]={[1]=42};
```

意味合いとしては、`a[1]`のみを42で初期化し、それ以外の要素を0で初期化するという意味合いに取れますが、厳密には規格違反となっています。このコードを警告も吐かずにコンパイル成功してしまうコンパイラも中には存在するのですが、この文法は、C言語の99というバージョンから実装された機能であり、C++17の規格段階では取り入れられていないため、規格違反と言えるのです。
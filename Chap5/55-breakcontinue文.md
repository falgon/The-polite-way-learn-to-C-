# 5.5 break,continue文

### 5.5.1 break文

ここに事前に初期化された変数`x`と無限ループのコードがあります。

```cpp
int x = 10;
while(true){} // 無限ループ
```
例えばこの`x`に対して何らかの処理結果が後々代入され、その値が例えば`0`であったら無限ループを脱出するというコードを書きたいとしましょう。そういった場合、以下のように書きます。

```cpp
int x = 10;
while(true){
    if(x == 0){
        break;
    }
    x = 0; // xに対して何かの処理結果0が代入された!
}
```
まず、`while(true)`によって無限ループを起こそうとしています。その後、変数`x`の値が`0`であるかどうかを`if`文を使って判定しています。この場合、まだ`x`は`0`ではないので`if`文の中身は実行されません。しかしその後、`x`に`0`が入っています。ここで1回目のループが終わります。次に2回目のループに入ると、`if`文の判定で`x == 0`は`true`となりますから、`if`文の中身が実行されます。`if`文の中身は`break`と書かれていますね。この`break`によって強制的にループから抜け出す事ができるのです。もう少し意味のあるコードを書いて見ましょう。

```cpp
#include<iostream>
int main()
{
    int array[]={10,20,30,40};
    int x=0;
    while(true){
        if(sizeof(array) / sizeof(array[0]) -1 < x){
            break;
        }
    std::cout << array[x] << std::endl;
    ++x;
    }
}
```
実行結果は以下となります。

```cpp
10
20
30
40
```
`sizeof(array) / sizeof(array[0])`によって配列の要素数を演算しその後`-1`をしています。ここで`-1`が必要なのは、`if`文は継続する場合の条件式ではなく、ループが終わる条件式だからです。ここで`-1`をしなければ、変数`x`が`4`である状態でもループが継続されてしまいますので、`array`という配列の範囲外にアクセスしてしまう事になってしまいます。しかし、何だかこのコード、どこかで似たような事をしていたような気がしませんか？実はその通りで、このコードは`for`文でも書く事ができるのです。

```cpp
#include<iostream>
int main()
{
    int array[]={10,20,30,40};
    for(int x = 0; x < sizeof(array) / sizeof(array[0]); ++x){
        std::cout << array[x] << std::endl;
    }
}
```
実行結果は上記のコードと同じです。このような単純な処理の場合は、一般的には`for`文で書いた方が意味合いとしては分かりやすいコードとなるでしょう。また、`while`で書くにしても以下のように書く事ができます。

```cpp
#include<iostream>
int main()
{
    int array[]={10,20,30,40};
    int x = 0;
    while(x < sizeof(array) / sizeof(array[0])){
        std::cout << array[x] << std::endl;
        ++x;
    }
}
```
`while(継続条件式)`ですので、`for`文と同じ継続条件式をそのまま入れて、`while`の中でカウンターである`x`をインクリメントしてあげれば同じ機能を実現できます。それぞれのコードの関係性が分かるでしょうか？じっくりそれぞれを見比べて見てください。

### 5.5.2 continue文
例えば、ループがこのように入れ子になっているとします。
```cpp
#include<iostream>
int main()
{
    for(unsigned int i = 0; i < 5; ++i){
        std::cout << "iの値は" << i << "です" << std::endl;
        int a=0;
        while(a <= 5){
            std::cout << "aの値は" << a++ << "です ";
        }
        std::cout<<std::endl;
    }
}
```
実行結果は以下となります。

```cpp
iの値は0です
aの値は0です aの値は1です aの値は2です aの値は3です aの値は4です aの値は5です
iの値は1です
aの値は0です aの値は1です aの値は2です aの値は3です aの値は4です aの値は5です
iの値は2です
aの値は0です aの値は1です aの値は2です aの値は3です aの値は4です aの値は5です
iの値は3です
aの値は0です aの値は1です aの値は2です aの値は3です aの値は4です aの値は5です
iの値は4です
aの値は0です aの値は1です aの値は2です aの値は3です aの値は4です aの値は5です
```
このコードで、`i`が2以下の場合のみ`while`文を実行したいとします。そういった場合、`continue`文が役立ちます。

```cpp
#include<iostream>
int main()
{
    for(unsigned int i = 0; i < 5; ++i){
        std::cout << "iの値は" << i << "です" << std::endl;
        int a=0;
        if(i > 2){
            continue;
        }
        while(a <= 5){
            std::cout << "aの値は" << a++ << "です";
        }
        std::cout<<std::endl;
    }
}
```
実行結果は以下となります。

```cpp

iの値は0です
aの値は0ですaの値は1ですaの値は2ですaの値は3ですaの値は4ですaの値は5です
iの値は1です
aの値は0ですaの値は1ですaの値は2ですaの値は3ですaの値は4ですaの値は5です
iの値は2です
aの値は0ですaの値は1ですaの値は2ですaの値は3ですaの値は4ですaの値は5です
iの値は3です
iの値は4です
```
`while`文内に`if`文によって`i`が2よりも大きい時の条件を作りました。その中には`continue`と書かれていますね。つまり、`continue`とはループ内でそこから下にある記述をスキップしてループを継続するという意味になります。なので、3以上となった時、`a`の値に関する出力がされないという結果になるのです。
# 5.3 for,range-for 文

### 5.3.1 for文
`for`文とは、繰り返し処理を行うための文法の一つです。例えば、1から10までの数値を出力したい場合、どのように書くでしょうか？

```cpp
#include<iostream>
int main()
{
    std::cout << 1 << 2 << 3 << 4 << 5 << 6 << 7 << 8 << 9 << 10 << std::endl;
}
```
10までならなんとか手打ちできますね。では、1から1000までの数値を出力しましょう...と言われて、1から1000までを手打ちで打っていては日が暮れてしまいます。for文を使う事で簡単に実現する事ができます。

```cpp
#include<iostream>
int main()
{
    for(unsigned int i = 1; i <= 1000; ++i){
        std::cout << i;
    }
    std::cout << std::endl;
}
```
文法は、以下のようになっています。
```cpp
for(お好みの一式; 継続条件式; お好みの一式){}
```
継続条件式が`false`である時、繰り返し処理が終了されます。上記のコードでは繰り返し終了条件に`i <= 1000;`と書かれていますので、変数`i`が1000以下である限り`true`となるため繰り返し、1001以上となった瞬間に`false`となりますので繰り返し処理から抜け出します。`継続条件式`の次には`++i`と書かれていますね。これは演算子の項で取り上げられていますが、前置インクリメント演算子と言います。変数`i`の前に`++`があるので前置です。ここで少しforから離れてインクリメント、デクリメントについて触れておきます。

### 5.3.2 インクリメント、デクリメント
インクリメントとデクリメントは、以下のように使う事ができます。

```cpp
int a = 10;
++a;
--a;
a++;
a--;
```
このように、対象の前に置く形が前置、対象の後に置く形が後置です。それぞれにはどのような違いがあるのでしょうか。まず以下のコードの実行結果は何が出力されるでしょうか。

```cpp
#include<iostream>
int main()
{
    int a = 10,b = ++a;
    std::cout << b << std::endl;
}
```
実行結果は以下となります。

```cpp
11
```
`++`は、値を1つ加えます。`++`によってインクリメントされている事が分かります。では以下のコードの実行結果は何が出力されるでしょうか。

```cpp
#include<iostream>
int main()
{
    int a = 10,b = a++;
    std::cout << b << std::endl;
}
```
実行結果は以下となります。
```cpp
10
```
なんと、インクリメントしているのにも拘らず、値は10のままです。先ほどとの違いは前置か後置だけですがこれが重要な違いをもたらしています。それでは今のコードに少し追加してみます。

```cpp
#include<iostream>
int main()
{
    int a = 10, b = a++, c = a;
    std::cout<< b << std::endl << c << std::endl;
}
```
新たに`c`という変数に対して`a`で初期化するよう加えました。実行結果は以下となります。

```cpp
10
11
```
上からそれぞれ`b`と`c`の出力結果です。`b`はやはり10のままですが、`c`は11になっています。つまり、後置にする事でインクリメント演算子による演算よりも先に、それ以外の処理(この場合は初期化)を先に行わせる事ができるのです。つまり、上記のコードは以下のコードと同じ意味となります。

```cpp
#include<iostream>
int main()
{
    int a = 10,b = a,c = a += 1;
    std::cout<< b << std::endl << c << std::endl;
}
```
デクリメントも同様です。

```cpp
#include<iostream>
int main()
{
    int a = 10,b = --a;
    std::cout << b << std::endl;
}
```
前置にするとデクリメントが先に処理されるため結果は以下となります。

```cpp
9
```
後置にするとデクリメントよりも先に初期化の処理が行われるため

```cpp
#include<iostream>
int main()
{
    int a = 10,b = a--,c = a;
    std::cout << b << std::endl << c << std::endl;
}
```
結果は以下となります。

```cpp
10
9
```

### 5.3.3 for文における前置と後置
それでは、再びfor文へと話題を戻します。for文は、以下のような文法であると述べました。

```cpp

for(変数宣言/定義式; 継続条件式; お好みの一式){ 何らかの処理 }
```
そして、インクリメントとデクリメントには前置と後置がある事を学びました。

```cpp
for(unsigned int i = 0; i < 10; ++i) // 前置
{ /* 何らかの処理 */ }

for(unsigned int i = 0; i < 10; i++) // 後置
{ /* 何らかの処理 */ }
```
この両者の違いは何でしょうか。動作自体に何か違いはあるのでしょうか。結論から言えば、結果的には同じように動きます。しかし実際の内部的な処理は少し異なる部分があります。これに対しては賛否両論がありますが、この単純な処理の場合では、前置インクリメントを用いる事を推奨します。何故なのかは、これから学ぶ、演算子オーバーロードという項で取り上げます。

### 5.3.4 for文とスコープ
このように書く事もできます。

```cpp
int main()
{
    int i = 0;
    for(; i < 5; ++i){
        // 何かの処理 ...
    }
}
```
変数宣言/定義式の部分に何も書かれていませんね。このように、一文を示す`;`さえ記述されているのであれば、必ずしも何かを書く必要はありません。しかし上記の場合、前述した通りスコープの概念から考えるにあたって、変数`i`を`for`文の中だけで用いるのであれば、`for`文の変数宣言/定義式部分で変数宣言/定義をするべきです。このような形で宣言/定義された変数は通常スコープの終わりに破棄されます。`for`文の中でしか使わない変数が、`for`文が終わった後でも破棄されずに生き残っている状態というのは無駄ですし、単純にこういったコードも書けるからです。

```cpp
#include<iostream>
int main()
{
    int i = 0;
    for(int i = 0; i < 5; ++i); // 5回インクリメントするだけで何もしない。
        std::cout << i << std::endl;
}
```
`main`関数内に`i`という変数が2つあるように思えますが、どちらも異なるスコープ上に宣言/定義された変数であるため、双方で同名でありながら異なるものとして扱う事ができます。

### 5.3.5 for文の中にfor文
for文の中にfor文を入れることも勿論可能です。

```cpp
#include<iostream>
int main()
{
    for(unsigned int i=0; i<5; ++i){
        for(unsigned int j=0; j<5; ++j){
            std::cout<<'*';
        }
    std::cout<<std::endl;
    }
}
```
実行結果は以下となります。

```cpp
*****
*****
*****
*****
*****
```
「5回アスタリスクを出力してその毎に改行する」を5回繰り返せば、実行結果のような5 x 5の正方形を出力できますね。for文の中のfor文の中にfor文を入れる事もできますし、更にその中にfor文を入れる事も...と無限に入れ子にしていく事もできます。例えば以下はfor文の中のfor文の中にfor文を入れています。



```cpp
// 上記の正方形を5個出力
#include<iostream>
int main()
{
    for(unsigned int i=0; i<5; ++i){
        for(unsigned int j=0; j<5; ++j){
            for(unsigned int k=0; k<5; ++k){
                std::cout<<'*';
            }
        std::cout<<"\t";
        }
    std::cout<<std::endl;
    }
}
```
実行結果は以下のようになります。

```cpp
***** ***** ***** ***** *****
***** ***** ***** ***** *****
***** ***** ***** ***** *****
***** ***** ***** ***** *****
***** ***** ***** ***** *****
```
「「5回アスタリスクを表示してその毎にTABスペースを空ける」の毎に改行をする」を5回繰り返せば、5 x 5の正方形が5個出力できますね。

### 5.3.6 range-for文
例えば、for文を用いるにおいてよくあるのが、配列へのアクセスです。

```cpp
#include<iostream>
int main()
{
    int array[]={42,53,12,28,16,20,25,19,21,46};
    for(unsigned int i = 0; i < sizeof(array) / sizeof(array[0]); ++i)
        std::cout << array[i] << std::endl;
}
```
実行結果は以下となります。

```cpp
42
53
12
28
16
20
25
19
21
46
```
`array`はランダムな値を持つ要素数10の配列です。`for`文でまず変数`i`を0に初期化し、継続条件式では`i < sizeof(array) / sizeof(array[0])`としています。これは、`i`が`array`の要素数よりも小さい場合継続という意味になりますね。そして、実行するたびに`i`をインクリメントするよう指定しています。この状態で、`array[i]`とする事で、繰り返されるたびに`array[0]`、`array[1]`、`array[2]`、`array[3]`...とアクセスし`i`が10になると継続条件式において`false`となるので繰り返し処理が終わります。このプログラムはそこそこ安全と言えます。何故ならば、sizeofによって対象の配列の要素数を演算し導き出していますから例え実際の配列の要素数が変動しても、それに応じて繰り返し処理が変動してくれるからです。しかし、以下のように記述してしまったら、どうなるでしょうか。

```cpp
// Do not run this code!
#include<iostream>
int main()
{
    int array[]={42,53,12,28,16,20,25,19,21,46};
    for(unsigned int i=0; i < 100; ++i)
        std::cout << array[i] << std::endl;
}
```
このようなコードは決して書いてはなりません。何故ならば、これは配列の要素数が10であるのにも関わらず、`i < 100;`という継続条件式によって、99までアクセスしてしまうからです。_2.4 配列その1_でも述べましたが宣言された配列の要素数以上への操作は絶対にしてはならないのです。しかし、人間はミスをする生物です。誤って10しか要素のない配列に対して99番目までの要素を操作するようなコードを書いてしまうかもしれません...その防止策として、range-for文の出番です。

```cpp
#include<iostream>
int main()
{
    int array[]={42,53,12,28,16,20,25,19,21,46};
    for(int i:array)
        std::cout << i << std::endl;
}
```
実行結果は以下となります。

```cpp
42
53
12
28
16
20
25
19
21
46
```
全く同じですね！しかし、何やらよく分からない`for`の形が出てきました。文法は、以下の通りです。

```cpp
for(配列の要素型 : 集合/配列){ 何かしらの処理 }
```
このように記述する事で、プログラマは配列に対する誤った条件継続式を書く事が一切なくなります。上記コードの流れを追ってみましょう。まず、`array`という配列が定義されています。これは前のコードと同じですね。そしてrange-for文によって`int i`と`array`が指定されています。これは、`array`をまずアクセスを行う配列として指定しています。そして`int i`が、`array`の一つ一つの要素から受け取る変数として宣言しています。range-forについてはまだ少し奥深いところがありますので、これについてもまた後ほど取り上げて説明します。
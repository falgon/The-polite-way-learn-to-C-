# 2.1 変数とデータ型
変数はプログラミングにおいて最も大事な概念と言えるでしょう。変数は入れ物だとか箱であると言われることもありますがどういう事なのでしょうか。順を追って見ていきましょう。

### 2.1.1 基本的概念
例えば、以下のような式があるとします。

```cpp
1 + 1
```
これは、1と1を加算した結果を得れますね。しかしそれ以外の場合を想定する事はできません。もし1に2を加算した式を書きたければ、このように書きかえる必要があります。

```cpp
1 + 2
```
では、`1 + n`といった、どんな数値がくるのか分からない場合はどうすればいいのでしょうか。そういった場合には以下のように書きます。

```cpp
1 + n
```

そして、例えば、nが2であったら？以下のように書きます。

```cpp
n = 2
1 + n
```
これで、nがどんな数字であろうが1を加算する事ができるようになりました。これは、nは2であると前提を置いているので、`1 + 2`という意味合いになりました。<br>1を足すだけでは、このようにnとして配置することに特に良さを感じないかもしれません。では、もう少しだけ式が複雑になった場合、例えば直径20の円の面積を求めたいとしたら、どうでしょうか。

```cpp
20/2 * 20/2 * 3.14
```
これは、誰しもよく知っているであろう、円の面積の求め方に基づいた一式です。`*`が掛け算で、`/`が割り算です。では直径dの円の面積は、どのように求められるでしょうか。さらに、円周率は3.14で計算していますが、その定義によって変動させたい場合、どういった式になるでしょうか。3.14で計算する場合もあれば、3で計算する場合もあるでしょうし、3.141592653...で計算する事も考えられます。

```cpp
pi = 3
d/2 * d/2 * pi
```
はい、簡単ですね。この場合は、円周率を3としています。<br>ここまでを理解できたのであれば、変数について理解する事の大きな一歩を既にふみ終えています。つまりこの`d`や、`pi`、先ほど述べた`n`などの事を変数と言うのです。<br>この基本的な概念に、制約や決まりが上付けされているものがC++においての変数の概念です。<br>それでは、C++の変数の概念を、今まで述べてきたものに上付けしていきましょう。

### 2.1.2 代入
式`n=2`があるとします。これは<i>nは2と同等である</i>という意味に思えるかもしれませんが、C++では異なります。正しくは、<i>nに2を代入する</i>という意味になります。代入とはつまり、以下のような事ができるようになるという事です。

```cpp
n = 1
1 + n // (1)
n = 10
1 + n // (2)
```
(1)の式はどうなるでしょうか。nに1を代入しているので、`1 + 1`となりますね。では、(2)の式はどうなるでしょうか。nに1を代入して`1 + 1`となった後、再度nに今度は10を代入しています。ここで、先ほど代入された1は上書きされnは10となります。つまり2番の式は、`1 + 10`となります。<br>



### 2.1.3 データ型
例えば、Aさんは箱を持っていました。Aさんの箱の中身を他人が見る事はできません。そして、その箱に何を入れるかは明記されていないものとします。そしてある日、BさんはAさんの箱を見つけました。BさんはAさんから何が入っているのか話されない限り、何が入っているのか知り得る事はできません。<br>Aさんが、もしその箱に例えば、「おもちゃ箱」と書いたとすれば、Aさんとの会話なしに、おもちゃが中に入っていると期待できます。このように、「おもちゃ」の箱とする事によっておもちゃしか入れる事はないという条件を課しています。 <br>というように、条件を課せれば課せるほど、課せられたものに対する信頼度は上がります。ではここで、先ほどの式 `n + 1`に、条件を加える事としましょう。例えば、nは符号付きの整数の数値だけを入れて欲しいとします。符号付きとは、負数も扱うという事です。そういった場合、C++では以下のように書きます。

```cpp
int n = 1;
1 + n;
```
`int`というワードが出てきました。これは、integerの略で、代入(この場合は厳密には初期化。代入と初期化の違いは後述)には整数値を期待するという意味になります。こういった指定を型と言います。<br>また<code>;</code>と末尾に書かれています。これは、データ型の話題とは無関係のものですが、C++プログラムの一文の区切りとして<code>;</code>が書かれます。日本語で言えば、句読点であったり、英語でいえば、ピリオドみたいなものと言えます。

### 2.1.4 扱える数値の範囲
型には、それぞれ扱える数値の範囲があります。<code>int</code>と変数を宣言した場合、扱える数値は、-2,147,483,648 ～ 2,147,483,647の間のみとなります。さらに大きな範囲が必要であれば、これについては後述しますが、<code>long</code>というキーワードを用います。

```cpp
long long n = 9223372036854775807;
n = -9223372036854775808;
```
`long long`という型では明記した通り、`-9,223,372,036,854,775,808`から`9,223,372,036,854,775,807`までの範囲の整数値を扱う事ができます。これ以上の数値は、中々実務でも扱う事はないので、十分な範囲と言えるでしょうが、もし範囲以上、以下の値を代入してしたらどうなってしまうのでしょうか。それは、その型の中では表現できない値となるので、正常でない数値となってしまう事が殆どです。(処理系に依存するため明記していません)このような事は、オーバーフロー、アンダーフローと言われています。少し話が飛んでしまいましたが、では`int`とされた`n`に対して、整数値以外の値を代入した場合、どうなるのでしょうか。

```cpp
int n=3.14;
```
この場合、nは3となります。整数値が代入されると期待している中で、小数点以下を扱う値を代入すると、非対応部分は切り捨てされるのです。



### 2.1.5 バイト、ビット
バイト、ビットという単語が少し出てきますので事前に説明します。<br>バイトとはbyteと書き、単位の事を言います。そして1byteとは8ビットのことです<i style="font-size:11px;">[注釈1]</i>。
ビットはbitと書き、２進数の0,1の事を言います。つまり、bitはコンピューターの最小単位であり、byteというのはそれが八つで1単位としているものです。
<p style="font-size:11px;"><i>1.</i>&nbsp;実際のところを言うと、実はC++では「1ビットとは8バイトである」という明確な定義はされていません。唯一定義されているのは、「char型のサイズが1バイトである」という事だけです。そして、そのビット数の定義は、CHAR&#95;BITマクロ(マクロについては後述しますので現時点で理解する必要はありません。現時点ではCHAR&#95;BITマクロとは、1バイトが何バイトであるか定義されているものぐらいの認識で大丈夫です。)にされおり、少なくともそのビット数は8以上に定義される事が保証されてはいますが、実際のところ、8ビット以上であれば何ら言語使用上では問題の無い事になりますので、つまるところ、1バイトのビット数の定義は実装依存という事になります。</p>

### 2.1.6 データ型の一覧
前述した通り、C++では変数にはデータ型を指定します。ここまでの話だと整数値しか扱っていませんが、もちろん、様々な数値に対応できるよう、様々なデータ型がC++の言語機能として用意されています。これらは、**プリミティブ型**と言います。

* 整数型
* 浮遊少数型
* 文字型
* 論理型

それぞれについて解説していきますが、32bitか64bit環境かで扱う事のできる数値範囲が変動したり、処理系によっては扱える数値の範囲が異なるため、ここではより一般的に捉えられる数値を例に挙げて説明する事とします。「この型はこの数値である」と、どの環境でも数値範囲が変動しないよう定義された型も存在していますが、それについては追々解説する事とします。

#### 整数型
整数型とは前述したような、整数値を扱う事のできる型です。<br>それぞれshort、int、longという型が整数型に含まれます。

| 型 | バイト長 | 数値の範囲 |
| -- | -- | -- |
| (signed) short (int) | 2 | -32768～32767 |
| unsigned short (int) | 2 | 0～65535 |
| (signed) long (int) | 4 | -2147483648～2147483647 |
| unsigned long (int) | 4 | 0～4294967295 |
| (signed) int | 2 or 4 | (signed) short (int)もしくは(signed) long(int)と同じ |
| unsigned int | 2 or 4 | (signed) short (int)もしくは(signed) long(int)と同じ |

`(signed)int`と`unsigned int`についてはバイト長の定義が曖昧となっていますね。これには、コンピューターの進化の歴史があり、これまた環境によって変動するものです。



#### 浮遊少数型
浮遊少数型とは、大まかに言えば、少数点を扱う事のできる型です。

| 型 | バイト長 | 数値の範囲 |
| -- | -- | -- |
| float | 4 | 1.175494e-38〜3.402823e+38 |
| double | 8 | 2.225074e-308〜1.797693e+308 |



#### 文字型
文字を扱える型です。繰り返し述べますが文字を扱える型です。文字列ではありません。両者の違いとは、'a'という一文字か、"abc"という何文字かを含むものかといったところです。文字にはシングルクォーテーション<code>'</code>、文字列にはダブルクォーテーション<code>"</code>を用います。

| 型 | バイト長 | 数値の範囲 |
| -- | -- | -- |
|(signed) char | 1 | -128～127 |
| unsigned char | 1 | 0～255 |



#### 論理型
論理型とは、trueという値と、falseという値を格納する事のできる型です。

| 型 | バイト長 | 数値の範囲 |
| -- | -- | -- |
| bool | 1 | `true`,`false` |



trueは通常整数にすると1、falseは0となっています。つまり、1と0のみを格納できるという事になります。 <br><br>以上が、C++における変数という概念になります。型ごとに「格納できる数値の種類が異なる」そして、「その型の箱の名前を自由に設定できる」というのが変数であり、変数はたったそれだけのものです。変数名に関して言えば、これまで、やたら`n`やら`a`やら`b`やら`pi`といったような変数名を用いてきましたが、`hoge`だろうが`nemuidesu`だろうが、`watashinonamaehataroudesu`だろうが、規格上の問題はないわけですが、変数名には一般的に、その変数へ格納される値が何を表しているのか分かりやすくするため、文脈上捉えやすい名前を付ける事が好ましいとされています。また、ある一部の名前は予め変数名などの識別子として名付けてはならないとされているものも存在します。それはどのようなものなのでしょうか。順に見ていきます。



### 2.1.7 識別子へ名付けてはならないワード

C++には識別子へ名付けるとタブーとされるワードがあります。以下に、それらを列挙します。多くはコンパイルエラーを吐いてくれますが、中には規格では禁止とされているもののコンパイルエラーとはならないといった実装のコンパイラも有り、コンパイラのエラーだけを頼りにしてしまうと規格違反となってしまう可能性もありますので自らで理解する事は大切です。

* 数字から始まる識別子
```cpp
int 1234_abc; // 規格違反 & 大抵はエラー
```
規格に反するため一般的なコンパイラはエラーを吐きます。

* キーワード(予約語)として登録されている文字列
```cpp
int int; // int型のintという変数。規格違反 & 大抵はエラー
```
規格に反するため一般的なコンパイラはエラーを吐きます。
しかし以下のような場合であれば規格違反とはなりません。
```cpp
int int_; // 名前に_があるため別の文字列として捉えられる。違反ではない。(視覚的に分かりにくいので推奨しない)
```
今回は例として`_`を`int`の後ろに付与する事で予約語を回避しましたが、`_`以外の文字でももちろん構いません。つまり**名付けた識別子の中に予約語が含まれているが予約語と全く同じ文字or文字列ではなければ違反ではない**という事です。以下にキーワードの一覧を示します。

| Keywords | 
| -- | 
| alignas | 
| alignof | 
| asm |
| auto |
| bool |
| break |
| case |
| catch |
| char | 
| char16_t |
| char32_t |
| class |
| const |
| constexpr |
| const_cast |
| continue |
| decltype |
| default |
| delete |
| do |
| double |
| dynamic_cast |
| else |
| enum |
| explicit |
| export |
| extern |
| false |
| float |
| for |
| friend |
| goto |
| if |
| int |
| inline |
| long |
| mutable |
| namespace |
| new |
| noexcept |
| nullptr |
| operator |
| private | 
| protected |
| public |
| register |
| reinterpret_cast |
| return |
| short |
| signed |
| sizeof |
| static |
| static_assert |
| static_cast |
| struct |
| switch |
| template |
| this |
| thread_local |
| throw |
| true |
| try |
| typedef |
| typeid |
| typename |
| union |
| unsigned |
| using |
| virtual |
| void |
| volatile |
| wchar_t |
| while |


* 演算子
(演算子については「4.3 演算子」にて取り扱っています。)


* 演算子の代替表現

演算子については「4.3 演算子」にて取り扱っていますが、演算子の書き方としての代替表現が、言語仕様に用意されています。それらを以下に示します。
```cpp
// 以下は全て規格違反 & エラー
int and; // operator &&の代替表現として予約済み
int and_eq; // operator &=の代替表現として予約済み
int bitand; // operator &の代替表現として予約済み
int bitor; // operator |の代替表現として予約済み
int compl; // operator ~の代替表現として予約済み
int not; // operator !の代替表現として予約済み
int not_eq; // operator !=の代替表現として予約済み
int or; // operator ||の代替表現として予約済み
int or_eq; // operator |=の代替表現として予約済み
int xor; // operator ^の代替表現として予約済み
int xor_eq; // operator ^=の代替表現として予約済み
```
上記のようなコードは全て規格に反するため一般的なコンパイラはエラーを吐きます。先ほど述べた`int_`のように何か違う文字や文字列が付与されている場合は違反ではありません。

* アンダースコアで始まりその後大文字が続く文字列
```cpp
int _Cplusplus; // 規格違反だが一般的にコンパイルエラーを吐かない。
```
`_Cplusplus`のように、`_`の後に大文字である`C`が続く識別子は規格違反です。しかし、エラーを吐いてくれないコンパイラーも存在します。エラーを吐かないからと言って、そのまま使用した場合動作は規格違反となり、言語上の保証はされませんので使うべきではありません。

* アンダースコアが連続する文字列
```cpp
int __a; // 規格違反だが一般的にコンパイルエラーを吐かない。
int b__; // 後置でも規格違反だが一般的にコンパイルエラーを吐かない。
```
`_`が2回以上連続して現れる識別子は規格違反ですがエラーを吐いてくれないコンパイラーも存在します。


* アンダースコアから始まるグローバル変数
グローバル変数の概念は後ほど説明しますが、一旦ここで明示しておきます。
```cpp
int _a; // グローバル変数名にアンダースコアから始まる名前を付けてはならないため規格違反だが一般的にコンパイルエラーを吐かない。
int main()
{}
```
グローバル変数にはアンダースコアが連続しなくても先頭に付与された場合、規格違反となりますがエラーを吐かないコンパイラーも存在します。ただ、この場合適応されるのはグローバル変数のみになりますので、ローカル変数の先頭に識別子としてアンダースコアを付与する事は違反ではありません。

* 同じ名前の変数を再度定義
```cpp
int main()
{
    int a;
    int a; // 規格違反 & エラー
}
```

このように同一スコープ上で同じ名前の識別子をつけることは違反です。これを**One Definition Rule**と言い、よくODRと略されます。
...というわけで、それでは最後に、ここまで説明してきた変数の概念とルールに準じて、変数を操作をしてみましょう。いくつか、サンプルを載せておく事とします。

```cpp
int a = 100;
int b = 200;
int result = a + b; // resultは300
```

```cpp
float pi = 3.14;
int r = 5;
double area = r * r * pi; // areaは78.5
```

```cpp
int a = 3.14; // aは3
int b = 2147483648; // int型の扱える数値範囲を超えているためオーバーフロー。意図した通りの数値は格納されない
```

```cpp
char a = 'a'; // aは'a'
char b = 65;
/* bも'a'。a b c d e...という各文字はアスキーコードと言われる数値に全て当てはめられており、
65はaに該当する数値です。*/
```

```cpp
bool b = true; // bはtrue。1と等しい。
bool bb = false; // bbはfalse。0と等しい。
```
...と、ここまでデータ型について見ていきましたが、ところでこういったような記述はC++で出来るのでしょうか？

```cpp
x = 10; // 型宣言していない変数xに対して代入
```
これは、できません。何故ならば使われる全ての変数などのデータらは、使う前に必ず**宣言**をされなければならないからです。

### 2.1.8 宣言
C++では、全ての使われる変数などのデータらは、必ず事前に**何の型の何という識別子か**を宣言しなければ使う事はできません。つまり前述した通り、突然以下のようには書けないという事です。

```cpp
x = 10; // 型宣言していない変数xに対して代入
```
`10`は一般的には整数型ですから、もし変数`x`を使いたいのであれば、事前にこのように書く必要があります。

```cpp
int x;
x = 10;
```
符号なしの整数と考えたいのであれば、こうなります。
```cpp
unsigned int x;
x = 10;
```
このように型と変数名を宣言する事によって、コンパイラがそのデータがどういったものなのかを理解する事ができます。また、プログラマー自身も、**この変数にはどういったデータが入るべきなのか**などを視覚的に捉える事ができます。



### 2.1.9 キャスト
キャストという機能があります。これは、簡単に述べると型を変換する機能です。キャストには様々な方法があります。以下がその一覧です。

* static_cast
* dynamic_cast
* const_cast
* reinterpret_cast
* ()によるキャスト

ただ、現時点ではまだ述べていない他の概念を含むキャストが多いため、本項では`static_cast`と`reinter_pret`キャストのみ説明する事とします。

### static_cast
static_castはコンパイル時に型を変換するキャストです。以下のように指定します。
```cpp
double a = static_cast<int>(3.14); // 3.14はsigned intへ変換され、aは3で初期化される
```
`static_cast<変換したい型>(値)`とする事でその値を変換したい型へ変換する事ができます。この場合、`3.14`を`double`型に代入した場合、`3.14`が格納されるはずですが、`static_cast`によって`int`型へキャストされていますので、小数点以下が切り捨てられて`3`が代入されます。
このように、互換性のある型同士のキャストは`static_cast`する事ができますが、例えば以下のように、互換性のない型同士は`static_cast`ではキャストできません。
```cpp
struct X{};

int main()
{
	X x;
	int a=static_cast<int>(x); // エラー！キャストできない
}
```
`struct X{};`というような謎の記述がありますが、これについてもまだ説明していない概念を含みますので完全に理解する必要はありません。このコードの示す意味合いとしては、`X`という型と`int`という型は全く違うデータ構造であるため、変換する事ができないという事です。

### reinterpret_cast
`reinterpret_cast`は`static_cast`と異なり、強引に型を変換するキャストです。

### ()によるキャスト
`()`によるキャストは、`reinterpret_cast`以上の強制力を持ち、コードの意味合いや可読性を低下させる傾向にありますので、可能な限り用いるべきではなく、上記に記述された、xx_castの方を使うべきです。

### 2.1.10 typedef、using
usingによる型の別名の定義は、本項で述べた機能以外にもさらなる機能があるのですが、現時点ではまだ説明していない他概念を含みますので、後述する事とします。これについては、「第11章 テンプレート」で取り上げています。
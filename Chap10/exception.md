# 10.1 例外
この項では、今まで謎めいていた例外という概念について学びます。お待たせしました。この項目で今まで先延ばしにしていた`noexcept`の意味がようやく分かるようになります。

さて、例外は平たく言えば想定外の自体が発生した場合の処理です。
C言語ではある関数内でエラーが発生した場合、プログラマが独自的に決めた値などを戻り値にしてその内部でエラーが起きた事を知らせようというようなプログラムがありましたが、プログラマが独自的に決めたルールというのは言語規約ではないので、いつでも破る事ができます。それは困りますよね。
C++でも、戻り値で判定を行う文化はしばしば残っていますが、より重大な内部エラーを孕んでしまった場合は、例外を送出する事が多いです。
この項では、そのように送出された例外の受け取り方と、逆に例外の送出を行う方法、またそれに関連する内容を説明します。

## 10.x.1 noexceptは関数型に含まれる
関数に例外を投げない事を保証する`noexcept`キーワードですが、例えばこのような関数のアドレスを格納しようとした場合、以下のように記述する事が望ましいです。
```cpp
void f()noexcept{};

int main()
{
    void (*f_ptr)()noexcept=f;
}
```
何が望ましい部分なのかというと、関数ポインタの宣言部分です。
関数ポインタの型は`void (*f_ptr)()noexcept`となっています。そうです、`noexcept`は型の一部なのです。
実は、以下のように関数ポインタ側では`noexcept`指定をしなくても規格違反ではありません。
```cpp
void f()noexcept{};

int main()
{
    void (*f_ptr)()=f; // 例外を投げない関数fの関数ポインタをnoexceptにしなくても良い
}
```
しかし、ポイントしている関数が`noexcept`であるのならば、最適化や明示性などを考えると関数ポインタ側にも`noexcept`を付与する事が望ましいです。

尚、`noexcept`でない関数をポイントする型を、`noexcept`指定する事はできません。
```cpp
void f(){};

int main()
{
    void (*f_ptr)()noexcept=f; // エラー！例外を投げるかもしれない関数fのアドレスをnoexceptな関数のポインターで格納できない
}
```

この関数の型に`noexcept`が含まれるという機能は、割と最近に組み込まれた機能なので、対応していないコンパイラに遭遇する可能性もまだまだあるでしょう。
そこで、以下の標準で定義されるマクロを用いる事で正しくこの機能が搭載されているか知る事ができます。
```cpp
#ifdef __cpp_noexcept_function_type
// noexceptが関数の型の一部でなければならないコード
#else
// そうでないコード...
#endif
```
尚、`__cpp_noexcept_function_type`の値は`201510`です。

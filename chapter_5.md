# 第 5 章 スコープと制御文

本章では制御文について説明します。今までの概念に加えて制御文を理解する事で、いよいよプログラムらしいプログラムを記述する事ができるようになります。また、「C++での制御文の記述法」自体も大切な知識ですが、その概念である「制御を行うための考え方」もとても大切です。この章で学ぶ概念は、C++言語以外のプログラミング言語でも大抵通用するような概念となりますので、一度通して読んで見て、理解できなければ、しっかりと理解できるまで読み直す事をお勧めします。しかしかと言って、その概念も理解してしまえばとても単純なものなので、そこまで気を張る必要はありません。<br />この章では以下のような流れで説明していきます。<br />

1. スコープ

* if文

* for,range-for文

* while文

* break,continue文

* switch文

## 5.1 スコープ

C++にはスコープ(範囲)という概念があります。スコープは、通常`{`と`}`で表します。例を見て見ましょう。

```cpp
#include<iostream>
int main()
{
    char a = 'a';
    {
        char b = 'b';
    }
    std::cout << a << std::endl << b << std::endl;
}
```

このコードは、コンパイルエラーとなります。コンパイラ(GCC 6.1.0)のエラー文を見て見ましょう。

```cpp
test.cpp: 関数 ‘int main()’ 内:
test.cpp:8:33: エラー: ‘b’ was not declared in this scope
std::cout << a << std::endl << b << std::endl;
                               ^
```

「`b`はこのスコープ内で宣言されていません」というエラーが出ています。まさにエラー文の通り、変数`b`は`main`関数中の`{}`の中に定義されていますので、同じスコープ内からでしかアクセスする事はできません。アクセスしたければ、例えばこのように記述します。

```cpp
#include<iostream>
int main()
{
    char a='a';
    {
        char b='b';
        std::cout << b << std::endl;
    }
    std::cout << a << std::endl;
}
```

実行結果は以下となります。

```cpp
b
a
```

同スコープ内でのアクセスなので`b`への処理が正しく成されている事が分かります。では、内側のスコープから外側のスコープのデータにアクセスする事はできるのでしょうか？

```cpp
#include<iostream>
int main()
{
    char a = 'a';
    {
        std::cout << a << std::endl;
    }
}
```

実行結果は以下となります。

```cpp
a
```

答えはYESです。内側のスコープから外側のスコープへアクセスする事は合法です。因みにスコープは、何重にもする事ができます。例えばこのように。
```cpp
int main()
{
    int a;
    {
        int a;
        {
            int a;
            {
                int a;
            }
        }
    }
}
```

ここで関数`main`の中に変数`a`がいくつも宣言されている事に気付いたかもしれませんが、このコードはコンパイルを正しく通ります。何故なら、全ての変数`a`はそれぞれのスコープで宣言された変数`a`でありそれぞれが全て独立しています。以下のようなコードで試して見ましょう。

```cpp
#include<iostream>
int main()
{
    int a = 10;
    {
        int a = 20;
        {
            int a = 30;
            {
                int a = 40;
                std::cout << a << std::endl;
            }
            std::cout << a << std::endl;
        }
        std::cout << a << std::endl;
    }
    std::cout << a << std::endl;
}
```

実行結果は以下となります。

```cpp
40
30
20
10
```

再束縛という形でなく、全ての変数`a`がそのスコープ内で独立している事が分かると思います。もしそうでなければ、出力結果は全て40となるはずだからです。最後に、スコープによって確保されたデータがどのタイミングで破棄されるのかを説明します。例えば、以下のようなコードがあります。

```cpp
int main()
{
    int i;
}
```

このコードでは以下のような事が起きていると言えます。

```cpp
int main()
{
    int i; // 4バイト分領域を確保しろ
} // スコープから外れるので変数iを破棄しろ
```

このように宣言/定義された変数はスコープが終わると同時に、データが破棄されます。破棄される事により、スコープ外からそのデータに対してアクセスする事はできません。

## 5.2 if文

例えば、以下のようなコードがあったとします。

```cpp
#include<iostream>
int main()
{
    int a = 10,b = 20;
    std::cout << "aとbは等しいです" << std::endl;
    std::cout << "aとbは等しくないです" << std::endl;
}
```

これを実行するとこのように出力されます。

```cpp
aとbは等しいです
aとbは等しくないです
```

<code>a</code>と<code>b</code>も処理させる事なく<code>"aとbは等しいです"</code>と<code>"aとbは等しくないです"</code>という文字列を出力しろとだけ書いているのですから、この出力結果は当然と言えますね。しかし<code>a</code>と<code>b</code>が同じ値であれば<code>"aとbは等しいです"</code>と出力し、そうでなければ<code>"aとbは等しくないです"</code>と出力したいものです。結論から言えば、以下のように書きます。

```cpp
#include<iostream>
int main()
{
    int a=10,b=20;
    if(a==b){
        std::cout << "aとbは等しいです" << std::endl;
    }else{
        std::cout << "aとbは等しくないです" << std::endl;
    }
}
```

実行結果は以下となります。

```cpp
aとbは等しくないです
```

<code>if</code>と<code>else</code>が出てきました。1つ1つ解説していきます。<br />まず、

```cpp
if( 何かしらの演算式 ){ 処理A }
```

と書く事で、<code>何かしらの演算式</code>が<code>0</code>か<code>false</code>でない場合、<code>処理A</code>が実行されます。上記のコードの場合、<code>a == b</code>という演算は、<code>false</code>であるので、aとbは等しいですという文字列は出力されません。<br /><code>else{ 処理B }</code>とはなんでしょう。これは、それ以外といった意味で<code>何かしらの演算式</code>が<code>0</code>か<code>false</code>であった場合、<code>処理B</code>を実行するという意味です。上記のコードの場合、<code>a == b</code>という演算は、<code>false</code>であるので、aとbは等しくないですという文字列が出力されます。全体の文法を表すと以下のようになります。

```cpp
if( 何かしらの演算式I ){ 処理A }
else if( Iがfalseであった場合の条件式II ){ 処理B }
else { I、IIともにfalseであった場合の処理 }
```

<br />...これだけだと中々馴染まないので、いくつか例題を上げる事としましょう。

```cpp
#include<iostream>
int main()
{
    int a = 20;
    if(a == 10){
        std::cout << "aは10です" << std::endl;
    }else if(a == 20){
        std::cout << "aは20です" << std::endl;
    }else{
        std::cout << "aは10でも20でもないです" << std::endl;
    }
}
```

実行結果は以下となります。

```cpp
aは20です
```

if文部分を一つ一つ説明していきますね。まず<code>if(a == 10){</code>という行では<code>a</code>が10であるかどうか演算させています。この場合結果は<code>false</code>ですので、<code>aは10です</code>は出力されません。次に<code>else if(a == 20){</code>という部分では、<code>a</code>が20であるかどうか演算させています。この場合結果は<code>true</code>ですので、<code>aは20です</code>が出力されます。<code>}else{</code>は、その前にある<code>if(a == 10){</code>と<code>}else if(a == 20){</code>のどちらの演算結果も<code>false</code>である場合のみ実行されますので、<code>aは10でも20でもないです</code>と出力されませんし、処理すら到達しません。<br />では、以下のif文の処理の違いはなんでしょうか。

```cpp
#include<iostream>
int main()
{
    int a = 10;
    if(a == 10){
        std::cout << "aは10です" << std::endl;
    }else if(a == 10){
        std::cout << "aは10です(2回目)" << std::endl;
    } 
    
    if(a == 10){
        std::cout << "aは10です(3回目)" << std::endl;
    }if(a == 10){
        std::cout << "aは10です(4回目)" << std::endl;
    }
}
```

実行結果は以下となります。

```cpp
aは10です
aは10です(3回目)
aは10です(4回目)
```

2回目が実行されていません。その訳は<code>else if</code>が使われている事にあります。<code>else if</code>の前にある、<code>if(a == 10)</code>が<code>false</code>であった場合のみ、<code>else if</code>文が処理されるので、今回の場合は<code>true</code>ですから、処理はされないのです。3回目と4回目は、ただ<code>if</code>文が連続的に記述されているだけですから、どちらも処理が行われます。<br /><br />では、次の例題にいきましょう。

```cpp
#include<iostream>
int main()
{
    int a[5];
    if( sizeof(a) / sizeof(a[0]) == 5 ){
        std::cout << "aの要素数は5です。" << std::endl;
    }else{
        std::cout << "aの要素数は5ではありません。\n" << sizeof(a) / sizeof(a[0]) << "です。" << std::endl;
    }
}
```

実行結果は以下となります。

```cpp
aの要素数は5です。
```

少し複雑になってきました。一つずつ説明していきます。まず、if式内の<code>sizeof(a)</code>部分で、配列を<code>sizeof</code>演算子に渡しています。このようにして渡した場合、`sizeof`演算子は配列全体のバイト数を演算します。つまり上記コードの`sizeof(a)`では20という数値を得る事ができています。それに対して配列`a`の一つ分の要素(上記コードでは`a[0]`を用いてますね)で除算しています。全体のサイズを1つ分のサイズで割る事で何が得られるでしょうか。そうです、要素数を得る事ができるのです。つまり、

```cpp
sizeof(a) / sizeof(a[0]) == 5
```

とは、配列`a`の要素数が5である場合`true`となり、そうでなければ`false`となります。この場合、冒頭で`int a[5];`と宣言されていますので、上記の式は`true`となり、「aの要素数は5です」が出力されます。

それでは、最後の例題です。

```cpp
#include<iostream>
int main()
{
    unsigned short int i[10];
    float f[10];
    
    if(sizeof(i) / sizeof(i[0]) == sizeof(f) / sizeof(f[0]))
        std::cout << "二つの要素数は等しいです。" << std::endl;
    else
        std::cout<< "二つの要素数は等しくないです。" << std::endl;
}
```

実行結果は以下となります。

```cpp
二つの要素数は等しいです。
```

`int`型の配列`i`と`float`型の配列`f`の要素数をそれぞれ割り出し照合しています。しかし`if`式で先ほどまで記述されていた`{}`が見受けられませんね。実は、一文までであれば、`{}`を省略して記述して良い事となっているのです。一文まで、というのがとても重要です。

```cpp
#include<iostream>
int main()
{
    unsigned short int i[5];
    if(sizeof(i) / sizeof(i[0]) == 10)
        std::cout << "変数iの要素数は";
        std::cout << "10です。" << std::endl;
}
```

実行結果は以下となります。

```cpp
10です。
```

配列`i`の要素数は5ですが、なぜか「10です。」とだけ出力されていますね。何故ならば、このコードは下記コードと同じ意味だからです。

```cpp
#include<iostream>
int main()
{
    unsigned short int i[5];
    if(sizeof(i) / sizeof(i[0]) == 10){
        std::cout << "変数iの要素数は";
    }
    std::cout << "10です。" << std::endl;
}
```

このように、`{}`を省いた記述はその式の次の一文までを対象として含みます。慣れるまでは、`{}`を記述した方が無難かもしれません。

## 5.3 for,range-for 文

### 5.3.1 for文

`for`文とは、繰り返し処理を行うための文法の一つです。例えば、1から10までの数値を出力したい場合、どのように書くでしょうか？

```cpp
#include<iostream>
int main()
{
    std::cout << 1 << 2 << 3 << 4 << 5 << 6 << 7 << 8 << 9 << 10 << std::endl;
}
```

10までならなんとか手打ちできますね。では、1から1000までの数値を出力しましょう...と言われて、1から1000までを手打ちで打っていては日が暮れてしまいます。for文を使う事で簡単に実現する事ができます。

```cpp
#include<iostream>
int main()
{
    for(unsigned int i = 1; i <= 1000; ++i){
        std::cout << i;
    }
    std::cout << std::endl;
}
```

文法は、以下のようになっています。

```cpp
for(変数宣言・定義式; 継続条件式; お好みの一式){}
```

継続条件式が`false`である時、繰り返し処理が終了されます。上記のコードでは繰り返し終了条件に`i <= 1000;`と書かれていますので、変数`i`が1000以下である限り`true`となるため繰り返し、1001以上となった瞬間に`false`となりますので繰り返し処理から抜け出します。`継続条件式`の次には`++i`と書かれていますね。これは演算子の項で取り上げられていますが、前置インクリメント演算子と言います。変数`i`の前に`++`があるので前置です。ここで少しforから離れてインクリメント、デクリメントについて触れておきます。

### 5.3.2 インクリメント、デクリメント

インクリメントとデクリメントは、以下のように使う事ができます。

```cpp
int a = 10;
++a;
--a;
a++;
a--;
```

このように、対象の前に置く形が前置、対象の後に置く形が後置です。それぞれにはどのような違いがあるのでしょうか。まず以下のコードの実行結果は何が出力されるでしょうか。

```cpp
#include<iostream>
int main()
{
    int a = 10,b = ++a;
    std::cout << b << std::endl;
}
```

実行結果は以下となります。

```cpp
11
```

`++`は、値を1つ加えます。`++`によってインクリメントされている事が分かります。では以下のコードの実行結果は何が出力されるでしょうか。

```cpp
#include<iostream>
int main()
{
    int a = 10,b = a++;
    std::cout << b << std::endl;
}
```
実行結果は以下となります。
```cpp
10
```

なんと、インクリメントしているのにも拘らず、値は10のままです。先ほどとの違いは前置か後置だけですがこれが重要な違いをもたらしています。それでは今のコードに少し追加してみます。

```cpp
#include<iostream>
int main()
{
    int a = 10, b = a++, c = a;
    std::cout<< b << std::endl << c << std::endl;
}
```

新たに`c`という変数に対して`a`で初期化するよう加えました。実行結果は以下となります。

```cpp
10
11
```

上からそれぞれ`b`と`c`の出力結果です。`b`はやはり10のままですが、`c`は11になっています。つまり、後置にする事でインクリメント演算子による演算よりも先に、それ以外の処理(この場合は初期化)を先に行わせる事ができるのです。つまり、上記のコードは以下のコードと同じ意味となります。

```cpp
#include<iostream>
int main()
{
    int a = 10,b = a,c = a += 1;
    std::cout<< b << std::endl << c << std::endl;
}
```

デクリメントも同様です。

```cpp
#include<iostream>
int main()
{
    int a = 10,b = --a;
    std::cout << b << std::endl;
}
```

前置にするとデクリメントが先に処理されるため結果は以下となります。

```cpp
9
```

後置にするとデクリメントよりも先に初期化の処理が行われるため

```cpp
#include<iostream>
int main()
{
    int a = 10,b = a--,c = a;
    std::cout << b << std::endl << c << std::endl;
}
```

結果は以下となります。

```cpp
10
9
```

### 5.3.3 for文における前置と後置

それでは、再びfor文へと話題を戻します。for文は、以下のような文法であると述べました。

```cpp
for(変数宣言/定義式; 継続条件式; お好みの一式){ 何らかの処理 }
```

そして、インクリメントとデクリメントには前置と後置がある事を学びました。

```cpp
for(unsigned int i = 0; i < 10; ++i) // 前置
{ /* 何らかの処理 */ }
for(unsigned int i = 0; i < 10; i++) // 後置
{ /* 何らかの処理 */ }
```

この両者の違いは何でしょうか。動作自体に何か違いはあるのでしょうか。結論から言えば、結果的には同じように動きます。しかし実際の内部的な処理は少し異なる部分があります。これに対しては賛否両論がありますが、この単純な処理の場合では、前置インクリメントを用いる事を推奨します。何故なのかは、これから学ぶ、演算子オーバーロードという項で取り上げます。

### 5.3.4 for文とスコープ

このように書く事もできます。

```cpp
int main()
{
    int i = 0;
    for(; i < 5; ++i){
        // 何かの処理 ...
    }
}
```

変数宣言/定義式の部分に何も書かれていませんね。このように、一文を示す`;`さえ記述されているのであれば、必ずしも何かを書く必要はありません。しかし上記の場合、前述した通りスコープの概念から考えるにあたって、変数`i`を`for`文の中だけで用いるのであれば、`for`文の変数宣言/定義式部分で変数宣言/定義をするべきです。このような形で宣言/定義された変数は通常スコープの終わりに破棄されます。`for`文の中でしか使わない変数が、`for`文が終わった後でも破棄されずに生き残っている状態というのは無駄ですし、単純にこういったコードも書けるからです。

```cpp
#include<iostream>
int main()
{
    int i = 0;
    for(int i = 0; i < 5; ++i); // 5回インクリメントするだけで何もしない。
    std::cout << i << std::endl;
}
```

`main`関数内に`i`という変数が2つあるように思えますが、どちらも異なるスコープ上に宣言/定義された変数であるため、双方で同名でありながら異なるものとして扱う事ができます。

### 5.3.5 for文の中にfor文

for文の中にfor文を入れることも勿論可能です。

```cpp
#include<iostream>
int main()
{
    for(unsigned int i=0; i<5; ++i){
        for(unsigned int j=0; j<5; ++j){
            std::cout<<'*';
        }
        std::cout<<std::endl;
    }
}
```

実行結果は以下となります。

```cpp
*****
*****
*****
*****
*****
```

「5回アスタリスクを出力してその毎に改行する」を5回繰り返せば、実行結果のような5 x 5の正方形を出力できますね。for文の中のfor文の中にfor文を入れる事もできますし、更にその中にfor文を入れる事も...と無限に入れ子にしていく事もできます。例えば以下はfor文の中のfor文の中にfor文を入れています。

```cpp
// 上記の正方形を5個出力
#include<iostream>
int main()
{
    for(unsigned int i=0; i<5; ++i){
        for(unsigned int j=0; j<5; ++j){
            for(unsigned int k=0; k<5; ++k){
                std::cout<<'*';
            }
            std::cout<<"\t";
        }
        std::cout<<std::endl;
    }
}
```

実行結果は以下のようになります。

```cpp
***** ***** ***** ***** *****
***** ***** ***** ***** *****
***** ***** ***** ***** *****
***** ***** ***** ***** *****
***** ***** ***** ***** *****
```

「「5回アスタリスクを表示してその毎にTABスペースを空ける」の毎に改行をする」を5回繰り返せば、5 x 5の正方形が5個出力できますね。

### 5.3.6 range-for文

例えば、for文を用いるにおいてよくあるのが、配列へのアクセスです。

```cpp
#include<iostream>
int main()
{
    int array[]={42,53,12,28,16,20,25,19,21,46};
    for(unsigned int i = 0; i < sizeof(array) / sizeof(array[0]); ++i)
        std::cout << array[i] << std::endl;
}
```

実行結果は以下となります。

```cpp
42
53
12
28
16
20
25
19
21
46
```

`array`はランダムな値を持つ要素数10の配列です。`for`文でまず変数`i`を0に初期化し、継続条件式では`i < sizeof(array) / sizeof(array[0])`としています。これは、`i`が`array`の要素数よりも小さい場合継続という意味になりますね。そして、実行するたびに`i`をインクリメントするよう指定しています。この状態で、`array[i]`とする事で、繰り返されるたびに`array[0]`、`array[1]`、`array[2]`、`array[3]`...とアクセスし`i`が10になると継続条件式において`false`となるので繰り返し処理が終わります。このプログラムはそこそこ安全と言えます。何故ならば、sizeofによって対象の配列の要素数を演算し導き出していますから例え実際の配列の要素数が変動しても、それに応じて繰り返し処理が変動してくれるからです。しかし、以下のように記述してしまったら、どうなるでしょうか。

```cpp
// Do not run this code!
#include<iostream>
int main()
{
    int array[]={42,53,12,28,16,20,25,19,21,46};
    for(unsigned int i=0; i < 100; ++i)
        std::cout << array[i] << std::endl;
}
```

このようなコードは決して書いてはなりません。何故ならば、これは配列の要素数が10であるのにも関わらず、`i < 100;`という継続条件式によって、99までアクセスしてしまうからです。_2.4 配列その1_でも述べましたが宣言された配列の要素数以上への操作は絶対にしてはならないのです。しかし、人間はミスをする生物です。誤って10しか要素のない配列に対して99番目までの要素を操作するようなコードを書いてしまうかもしれません...その防止策として、range-for文の出番です。

```cpp
#include<iostream>
int main()
{
    int array[]={42,53,12,28,16,20,25,19,21,46};
    for(int i:array)
        std::cout << i << std::endl;
}
```

実行結果は以下となります。

```cpp
42
53
12
28
16
20
25
19
21
46
```

全く同じですね！しかし、何やらよく分からない`for`の形が出てきました。文法は、以下の通りです。

```cpp
for(配列の要素型 : 集合/配列){ 何かしらの処理 }
```

このように記述する事で、プログラマは配列に対する誤った条件継続式を書く事が一切なくなります。上記コードの流れを追ってみましょう。まず、`array`という配列が定義されています。これは前のコードと同じですね。そしてrange-for文によって`int i`と`array`が指定されています。これは、`array`をまずアクセスを行う配列として指定しています。そして`int i`が、`array`の一つ一つの要素から受け取る変数として宣言しています。range-forについてはまだ少し奥深いところがありますので、これについてもまた後ほど取り上げて説明します。

## 5.4 while文

### 5.4.1 文法

ループ処理としてwhile文というものもあります。まずは文法を見てみましょう。

```cpp
while(継続条件式){ 何かしらの処理... }
```

極単純ですね。この条件継続式が`false`になった場合にループ処理から抜け出します。例えば、このように使います。

```cpp
int main()
{
    int i = 0;
    bool b = true;
    
    while(b){
        if(++i > 9)b=false;
    }
}
```

まず変数`i`を0に初期化、`b`を`true`に初期化します。その後、`while`文の条件継続式には変数`b`を指定しておきます。変数`b`は初期化時が`true`であるため、`while`文によるループが開始されます。その後`while`文の中にある`if`文で`++i > 9`としています。これは、まず変数`i`をインクリメントし、`i`が9よりも大きい値となった時次の文を実行するとしています。そこで、`b`に対して`false`を代入しています。つまり`i`が9よりも大きい値となったら`b`が`false`になり、`while`文での条件継続式が`false`となるので繰り返しが終了するという魂胆です。

### 5.4.2 do-while文

`do-while`文というものもあります。これは`while`文とほぼ同じですが1つだけ違いがあります。`while`文が**繰り返し処理が行われる前に継続条件式が評価される**のに対し、`do-while`文では**繰り返し処理が行われた後に条件式が評価され**ます。その為`while`文では場合によっては一度も繰り返し処理が行われない可能性がありますが`do-while`文では最低1回は繰り返し処理を実行する事となります。

```cpp
#include<iostream>
int main()
{
    int a=0;
    while(a==1){
        std::cout<<"aが1である限りループします"<<std::endl;
    }
    
    do{
        std::cout<<"aが1でなくても一回は処理します。"<<std::endl;
    }while(a==1);
}
```

実行結果は以下となります。

```cpp
aが1でなくても一回は処理します。
```

`a`は0と初期化しているのにも関わらず`do-while`では一度処理がされている事が分かります。

### 5.4.3 無限ループ

ループが永遠に終わらない事を無限ループと言います。例えば以下のコードは永遠にループが終わりません。

```cpp
while(true){} // 無限ループ
```

継続条件式が常に`true`であるので、ループが終わる事はないのです。前述した`for`文でも、無限ループを再現する事ができます。

```cpp
for(;;){} // 無限ループ
```

`for`文内の継続条件式に何も書かれていない場合、それは必ず無限ループを起こします。これは、以下と同等です。

```cpp
for(; true;){} // 無限ループ
```

しかし、実際には無限ループを起こした上で、様々な条件下を元に継続条件を定めたい場合があります。そういった場合、どのように記述できるのでしょうか。それには、`break`、`continue`といったキーワードを用います。

## 5.5 break,continue文

### 5.5.1 break文

ここに事前に初期化された変数`x`と無限ループのコードがあります。

```cpp
int x = 10;
while(true){} // 無限ループ
```

例えばこの`x`に対して何らかの処理結果が後々代入され、その値が例えば`0`であったら無限ループを脱出するというコードを書きたいとしましょう。そういった場合、以下のように書きます。

```cpp
int x = 10;
while(true){
    if(x == 0){
        break;
    }
    x = 0; // xに対して何かの処理結果0が代入された!
}
```

まず、`while(true)`によって無限ループを起こそうとしています。その後、変数`x`の値が`0`であるかどうかを`if`文を使って判定しています。この場合、まだ`x`は`0`ではないので`if`文の中身は実行されません。しかしその後、`x`に`0`が入っています。ここで1回目のループが終わります。次に2回目のループに入ると、`if`文の判定で`x == 0`は`true`となりますから、`if`文の中身が実行されます。`if`文の中身は`break`と書かれていますね。この`break`によって強制的にループから抜け出す事ができるのです。もう少し意味のあるコードを書いて見ましょう。

```cpp
#include<iostream>
int main()
{
    int array[]={10,20,30,40};
    int x=0;
    
    while(true){
        if(sizeof(array) / sizeof(array[0]) -1 < x){
            break;
        }
        std::cout << array[x] << std::endl;
        ++x;
    }
}
```

実行結果は以下となります。

```cpp
10
20
30
40
```

`sizeof(array) / sizeof(array[0])`によって配列の要素数を演算しその後`-1`をしています。ここで`-1`が必要なのは、`if`文は継続する場合の条件式ではなく、ループが終わる条件式だからです。ここで`-1`をしなければ、変数`x`が`4`である状態でもループが継続されてしまいますので、`array`という配列の範囲外にアクセスしてしまう事になってしまいます。しかし、何だかこのコード、どこかで似たような事をしていたような気がしませんか？実はその通りで、このコードは`for`文でも書く事ができるのです。

```cpp
#include<iostream>
int main()
{
    int array[]={10,20,30,40};
    for(int x = 0; x < sizeof(array) / sizeof(array[0]); ++x){
        std::cout << array[x] << std::endl;
    }
}
```

実行結果は上記のコードと同じです。このような単純な処理の場合は、一般的には`for`文で書いた方が意味合いとしては分かりやすいコードとなるでしょう。また、`while`で書くにしても以下のように書く事ができます。

```cpp
#include<iostream>
int main()
{
    int array[]={10,20,30,40};
    int x = 0;
    while(x < sizeof(array) / sizeof(array[0])){
        std::cout << array[x] << std::endl;
        ++x;
    }
}
```

`while(継続条件式)`ですので、`for`文と同じ継続条件式をそのまま入れて、`while`の中でカウンターである`x`をインクリメントしてあげれば同じ機能を実現できます。それぞれのコードの関係性が分かるでしょうか？じっくりそれぞれを見比べて見てください。

### 5.5.2 continue文

例えば、ループがこのように入れ子になっているとします。

```cpp
#include<iostream>
int main()
{
    for(unsigned int i = 0; i < 5; ++i){
        std::cout << "iの値は" << i << "です" << std::endl;
        int a=0;
        while(a <= 5){
            std::cout << "aの値は" << a++ << "です ";
        }
        std::cout<<std::endl;
    }
} 
```

実行結果は以下となります。

```cpp
iの値は0です
aの値は0です aの値は1です aの値は2です aの値は3です aの値は4です aの値は5です
iの値は1です
aの値は0です aの値は1です aの値は2です aの値は3です aの値は4です aの値は5です
iの値は2です
aの値は0です aの値は1です aの値は2です aの値は3です aの値は4です aの値は5です
iの値は3です
aの値は0です aの値は1です aの値は2です aの値は3です aの値は4です aの値は5です
iの値は4です
aの値は0です aの値は1です aの値は2です aの値は3です aの値は4です aの値は5です
```

このコードで、`i`が2以下の場合のみ`while`文を実行したいとします。そういった場合、`continue`文が役立ちます。

```cpp
#include<iostream>
int main()
{
    for(unsigned int i = 0; i < 5; ++i){
        std::cout << "iの値は" << i << "です" << std::endl;
        int a=0;
        
        if(i > 2){
            continue;
        }
        while(a <= 5){
            std::cout << "aの値は" << a++ << "です";
        }
        std::cout<<std::endl;
    }
}
```

実行結果は以下となります。

```cpp
iの値は0です
aの値は0ですaの値は1ですaの値は2ですaの値は3ですaの値は4ですaの値は5です
iの値は1です
aの値は0ですaの値は1ですaの値は2ですaの値は3ですaの値は4ですaの値は5です
iの値は2です
aの値は0ですaの値は1ですaの値は2ですaの値は3ですaの値は4ですaの値は5です
iの値は3です
iの値は4です
```

`while`文内に`if`文によって`i`が2よりも大きい時の条件を作りました。その中には`continue`と書かれていますね。つまり、`continue`とはループ内でそこから下にある記述をスキップしてループを継続するという意味になります。なので、3以上となった時、`a`の値に関する出力がされないという結果になるのです。

## 5.6 switch文



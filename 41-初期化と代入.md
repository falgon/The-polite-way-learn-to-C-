# 4.1 初期化と代入

これまで変数宣言、定義において、初期化と代入については深く触れていませんでしたが、これを理解しているかどうかで、より無駄のないソースコードを記述できるかが変わってきます。しかし、それほど難解なものではありませんので肩の力を抜いて読み進めてください。

### 4.1.1 両者の違い
それではまず、結論から。初期化と代入の違いとは、以下のようなところにあります。

```cpp
int x=10; // 初期化 (1)
x=10; // 代入(2)
```
(1)と(2)、両者の違いがわかりますでしょうか。(1)では`int x=10;`というように、変数`x`が`int`であると宣言した時点で、`10`を指定しています。(2)では、変数`x`の宣言の後に入れる値を指定しています。つまり、**変数宣言された瞬間にその変数の初期値を指定する事を初期化**、**変数宣言の後に値を変数へ入れる事を代入**と言うのです。より理解を深めるため、例題として別の型で置き換えて見ましょう。

```cpp
double pi = 3.14; // (1)
double pi1 = 42.5; // (2)
pi1 = 3.14; // (3)
```
(1)は初期化です。何故ならば変数`pi`が`double`型であると宣言している時点で`3.14`という値を指定しているからです。(2)は代入です。何故ならば変数`pi1`が`double`型であると宣言している時点での値の指定ではなく、その後に3.14を入れているからです。

ではこのようなコードはどうでしょう。

```cpp
int x=10; // (1)
x=20; // (2)
```
これは単に、(1)で`x`は`10`と初期化した後に、(2)で`x`に`20`を代入した、という意味になります。

### 4.1.2 不定値
初期化と代入の違いを説明しましたが、初期化も代入も行われなかった場合、どうなるのでしょうか。

```cpp
#include<iostream>
int main()
{
    int x=10,y;
    std::cout << x << '\n' << y << std::endl;
}
```
`x`には`10`で初期化しろと指定されていますが、`y`には何も指定されていません。その後、`x`と`y`の中身を出力しろとしています。`x`は`10`と出力されるでしょう。しかし、`y`は何が出力されるでしょうか？

実は、これは不定です。宣言する時に何も初期化値を指定しなかった、またその後何も値を代入しなかったという変数の中身は何が入っているか定められていません。何が入っているのか分からない不定値を呼び出しても大抵は全く意味のない事ですから、大抵はそのような記述をするべきではありません。

このような事を防ぐため、宣言時にはまだ値が分からないが後に値が代入されると予想できる変数については、例えば整数型であれば`0`を初期化値として指定しておくというような習慣があります。

```cpp
#include<iostream>
int main()
{
    int x=10,y=0; // yには0を初期化値として一応与えておく
    std::cout << x << '\n' << y << std::endl;
}
```
こうしておけば、`y`の中身を使う時に、例えばその後`y`に対して何も代入操作などが行われなかった場合、これは初期化時のままの数値だな、と気付く事ができるわけです。

### 4.1.3 効率性を観点として考察する初期化と代入
初期化と代入の違いは分かりましたでしょうか。しかし、もしかすると、こう思うかもしれません。

```cpp
int x=10;
```
と書くのと

```cpp
int x;
x=10;
```
と書くのとでは、結果は同じなんだから、別にどっちでも良いんじゃない？！と...。

確かに、上記の二つのコードともに、<code>x</code>の値は10です。しかし、処理としては、後者のコードの方が非効率的な記述であると言えるのです。

実は、`x`に対して必ず`10`を入れる事が分かっているのであれば、宣言時に`10`という値を指定(初期化)するとコンパイラが「`x`は10が入る」と捉えてくれます。しかし、`x`の初期値を設定せずその後に代入という記述をすると、コンパイラは変数の宣言時では、この変数には`10`が入るという事を捉える事ができません。よって、初めから`10`が`x`に入るという事が分かっているのであれば、「`x`は`10`が入る」と宣言時に捉える事のできる方法である、初期化の方が効率的だと言えるわけです。

最近のコンパイラはとても賢くなり、両者どちらのコードを書いても解釈によって最適化され、生成されるアセンブリは変わらないという事もあるのですが、やはり習慣としては、無意味な未初期化は避けるべきでしょう。
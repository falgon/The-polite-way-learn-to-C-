# 14.1 イントロダクション
この項では、C++17 での実際のマルチスレッドプログラミングの解説の前に、**スレッド**とは何なのか、またそれらと関連する他の概念やそれとの違いは何なのか、それが何故必要なのか、更にシングルスレッドプログラミングでは考慮する必要のなかった**競合(data races)**やメモリモデルとは何なのかを解説します。

## 14.1.1 用語と概念

**マルチスレッド**という用語、一度は聞いた事があるかもしれませんが、そもそもどのような意味なのでしょうか。**プロセス**や**タスク**、**ジョブ**という用語は、Google などで検索するとマルチスレッドに関連して一括りにされて出てくる事もありますが、これらとの違いは一体なんでしょうか。まずはこれらの用語の意味と何故それが必要なのか、その役割を明白にしておきましょう。

### 並列処理
これらの単語を理解するために、まずは**並列処理**とは何なのか、何故必要なのかを述べておきます。例えば HDD上のファイルにアクセスするとしましょう。しかし、第12章でも述べた通り、CPUからこのような外部機器へのアクセスは一般的に低速です。このファイルアクセス中に、他の処理を済ませて置けるのであればユーザーにとっての処理時間は短くなりますね。このように、処理を1つ1つ順次実行していくのではなく、同時に実行する事を並列処理と言います。

### プロセス、タスク、ジョブ

次に、プロセス、タスク、ジョブについて説明します。まず誤解を恐れずに述べてしまえば、**プロセス、タスク、ジョブは、殆どの場合において同じ意味合いである事が多いです**。これらは何かというと、**プログラムの実行単位の事を言います**。ユーザーが OS に対して、例えばエディターとウェブブラウザの起動を指示したとします。もしそれらが1つの実行ファイルから成るのであればそれはまた話は別になってしまいますがそうではなく、それぞれ全く別の実行ファイルから実行されているのであれば、メモリー上に配備されたそれぞれの実行部分がプログラムの実行単位であると言えます。
<br>さて、これらの微妙な意味合いの違いを考えて見ましょう。まずは、**プロセス**と**タスク**について考えていきます。**プロセス**は、前述した通りプログラムの実行単位を示す用語ですが、それと同時に**OS 側の視点から見た用語である**とされる事が多いようです。例えば Win32 API という、Microsoft 社 による Windows OS の各機能にアクセスするためのインタフェースセットには、**タスク**という用語が一切使われていません。例えば、プログラムの起動のための [`CreateProcess`](https://msdn.microsoft.com/ja-jp/library/windows/desktop/ms682425(v=vs.85).aspx) という関数が同 API には備わっています。それと比較して、**タスク**は、プロセスという用語の対となるように、**ユーザー側の視点から見た用語である**とされるようです。同 OS の画面下に表示されるプログラムが並ぶバーは、タスクバーと呼ばれていますし、他指定した日時にプログラムを起動するタスクスケジューラという同 OS の付属ツールも**タスク**という用語が使われています。このように Windows においてタスクという用語は単なる**作業**という意味で使われているように受け取れます。以上有名な企業による用語の使用例を述べましたが、この通り、**明確な定義がない**ため、その意味合いは文脈から判断する必要があるでしょう。しかしそれはつまりその程度の違いしか両者にはないという事です。<br>
次にジョブとは何でしょうか。ジョブという用語も実は前述した二つの用語との明確な差異が定義されているわけではありません。ただ傾向として、これも**ユーザー側の視点から見た用語である**と言われる他、複数のプロセスをグループとして扱う場合に、同 API では Job Object を作り、これにプロセスを登録してグループ化する事で、ジョブの状態やジョブに属する全てのプロセスの終了などを可能にします。<br>中々この三つの用語の違いがはっきりしないのであまり気持ちよくないかもしれませんが、元々定義が明確となっていないため、三つの違いに関しては雰囲気だけ理解できれば良いでしょう。また、この三つが**プログラムの実行単位**を示す用語である事が理解できれば良いでしょう。本章では、以降、プロセス、タスク、ジョブをまとめてプロセスと呼称します。


最後に、プロセスの特徴について押さえておきましょう。プロセスは、前述した関数などを用いてプロセスを起動する事ができます。このように、プロセスから起動されたプロセスは**子プロセス**と言い、起動した側のプロセスを**親プロセス**と言います。プロセスには、このような親子関係がありますが、それぞれのプロセスごとに別のメモリ領域を利用します。また、命令の実行処理タイミングも異なります。<br>
Windows などのマルチタスク(プロセス) OS は、複数のアプリケーションを同時に実行できますが、それは OS によるサポートがあっての事です。一つのCPU(シングルコア)しかないコンピュータでは、ある一瞬では一つの処理しか実行できません。
これを OS による**マルチプロセス処理**で解決します。**異なるアプリケーション(実行単位、つまりプロセス)が複数の動作を同時に行なっているように見せるために、各処理プロセスを数十ミリ秒といった短い時間で素早く切り替えて、タスク間で一つの CPU を使いまわします**。これを**マルチプロセス(マルチタスク)**また**マルチプロセス処理(マルチタスク処理)**と言います。また、このように処理の流れを一時停止して別の処理に切り替えて実行を行なったり、再開する事を**プリエンプション**と言い、またその過程を**コンテキストスイッチ**と言います。コンテキストスイッチ処理は、オーバーヘッドがあり、処理時間の観点からしても払わなければならないコストとなる事を覚えておきましょう(このようなプロセス切り替えで発生するオーバーヘッドについては後述しています)。

![](/assets/Chap14/preemption_singlethread.jpeg)

尚複数のCPU(マルチコア)を持つコンピューターでは、複数のプロセスを文字通り同時に実行します。以下の図の場合、事実上上記のシングルコアシステムと比較して、半分の量のコンテキストスイッチ切り替えとなります。

![](/assets/Chap14/preemption_multithread.jpeg)

このようなプリエンプションを行う OS を**プリエンプティブなOS**と言います。またそうでない OS を**ノンプリエンプティブなOS**と言います。**ノンプリエンプティブなOS**では、実行プロセスの切り替え管理を実行プロセス自身に任せますから、そのプロセスが自発的に CPU を解放しなければなりません。よって、解放されるまでの間、1つのプロセス実行中は、他のプロセスの実行が制限される事となります。プリエンプティブなOS では前述した通り、スケジューラが各プロセスをある短い時間ずつ実行します。この短い時間を**タイムスライス**と言います。プロセスがスケジューラの設定したタイムスライスの時間内に CPU を明け渡さなかった場合、OS によるタイマ割り込み(割り込みについては後述しています。)が発生し、OSが別のプロセスを実行させるようにスケジューリングを行い、コンテキストスイッチが発生します。


また、複数のプロセス間でデータをやりとりする事もできます。これを、**プロセス間通信**と言います。

<br>尚、マルチプロセスとは反対にに一つのプロセスしか実行できない方式を**シングルプロセス(シングルタスク)**また**シングルプロセス処理(シングルプロセス処理)**と言います。


### プロセス切り替えのオーバーヘッドと割り込み
プロセス切り替えにはオーバーヘッドがあるという事を述べました。そして**割り込み**という用語が出てきました。これらについて少し掘り下げておきましょう(しかしあまりにも詳しく触れるとカーネルについての参考書となってしまうため、ここでは少ししか掘り下げません。)。<br>

<br>プロセス切り替えには、その切り替え自体オーバーヘッドがある他に **Translation Lookaside Buffer(TLB)** のミス率の上昇などのコストがあります。TLB は仮想アドレスから物理アドレスへの変換の高速化を測る仕組みです。今日の仮想記憶をサポートするマイクロプロセッサの殆どが、仮想空間と物理空間のマッピングに TLB を利用しています。TLB は連想配列に似たデータ構造である連想メモリで実装されており、CPU がメモリ空間にアクセスする際、検索キーとして仮想アドレスを利用して TLB 上にそのアドレスに対応したエントリがあれば、検索結果として対応する物理アドレスが返るようになっています。これを**TLBヒット**と言います。要求したアドレスがない事を**TLBミス**と言い、TLB のミス率上昇はこれが偶発する確率を上昇させてしまう事を言います。TLBミスである場合、ページテーブル(仮想アドレスと物理アドレスのマッピングを格納したテーブル)を線形探索しなければならなくなってしまいます。この探索を、**ページウォーク**と言います。ページウォークは複数個所のメモリ内容から物理アドレスを計算しなければなりませんので、時間がかかってしまうのです。尚、一度 TLBミスからページウォークによって判明した物理アドレスは、その仮想アドレスと物理アドレスのマッピングが TLB に追加される事となっていますから、アドレスの変化がなければ二度目では必ず TLBヒットします。しかし、コンテキストスイッチを行うとその際に仮想空間の切り替えに伴って TLB エントリの一部が不正となってしまうため、中々無視できるコストではありませんから、この点をよく考える必要があります。<br><br>

次に割り込みについてです。**割り込みとは、コンピュータがその周辺機器から受け取る要求の一種**です。主に、実行中の処理を中断して、強制的に指定された処理を実行させる事を言います。要求には、ハードウェアによるものとソフトウェアによるものがあります。ハードウェア割り込みは、コンピュータの周辺機器などのハードウェアから発生させる割り込みで、ある装置を経由して CPU に信号を送られ OS が実行中の処理を中断して機器の制御に必要な処理を実行します。この装置を**割り込みコントローラ**と言います。次に、ソフトウェア割り込みは、実行中のプログラムが発生させる割り込みの事を言います。これは、例外的な事象が発生した事を OS に伝えて、処理を中断し適切な対応を OS に迫ります。Segmentation fault などがこれに当たります。

### スレッド

**スレッド**は、前述した**プロセス**、**タスク**、**ジョブ**とは、意味としては明確に異なります。**スレッドとは CPU利用の単位**を意味しています。シングルスレッド、マルチスレッドといった用語を聞いたことがあるかもしれませんが、それぞれ**ある処理を単一のスレッドのみを用いて動作させる事をシングルスレッド**、対して**複数のスレッドが同時に動作することをマルチスレッド**と言います。1つのプロセス(単一の実行単位)は1つ以上のスレッドを必ず持っています。つまりスレッドは、プロセスまたはスレッドそのものから生成されるという事です。<br>マルチプロセス処理とは、根本にある考え方は同じですが、単位が異なります。

![](/assets/Chap14/thread.jpeg)

マルチスレッドは、前述した通り1つのプロセスが1つ以上持つ事ができますから、1つのプロセスが持つ特定の操作のそれぞれを個々のスレッドに分割するといった事ができます。複数のプロセス間でデータをやりとりできるように、プロセス上に成る複数のスレッド間でもデータをやりとりする事ができます。ここまでは、その機能としてはプロセスと変わりません。唯一の違いはOS全体で管理されるプロセス単位であるか、OS全体で管理されるプロセスのさらに内部で管理されるスレッド単位であるかといった点です。何故プロセス単位ではなく、プロセスの内部で複数のスレッドを実行するのでしょうか。
大きな理由の一つとしては、**前述したプロセスの切り替え(プリエンプション/コンテキストスイッチ)動作コストを避けるため**です。TLB ミスについて懸念する必要もありません。かつてスレッドは**ライトウェイトプロセス**とも呼ばれていました。これはひと昔前の UNIX に由来しています。かつての UNIX にはプロセスしかなく、並列処理を行うためには一つのプロセスから別のプロセスを作っていました。しかしここまで述べてきた通りコストがかかるため、プロセスよいも高速な手段で並列処理を行うための方法としてスレッドが導入されたという歴史があります。このようにプロセスのように独立したメモリ空間が不必要であったり、共有のメモリを利用しながら複数の処理を行なった方が楽であったりする場合、マルチスレッドはとても良い選択肢の1つです。プロセスの機能から必要な部分のみを利用したものがスレッドであるといったようなイメージがつけば良いでしょう。<br>
さて、ここまででプロセスとスレッドについて見てきましたが、ここでそれぞれのメリットとデメリットをまとめておきましょう。

#### マルチスレッドのメリットとデメリット
メリット
* メモリ使用率が低く、プロセス切り替えのオーバーヘッドがない
* プロセスよりも少ない時間で生成できる

デメリット
* 1つのスレッドがクラッシュするとそのプロセス全体に影響を及ぼす
* マルチスレッドプログラミング特有の排他制御や順序関係(後で説明しています)について適切に対処しなければならないため、そのためのスキルが必要

### マルチプロセスのメリットとデメリット
メリット
* 実行単位がそれぞれで分離しているため、1つのプロセスがクラッシュしても全体に影響はない、または起きにくい
* シングルスレッドでのプログラミングが可能

デメリット
* プロセス切り替えのコストがかかる
* プロセスの作成にコストがかかる


## 14.1.2 データ競合(data racing)
さて、ここまででプロセスやスレッドについて説明してきました。本章ではC++17 でのマルチスレッドについて取り上げていますが、言語に関わらず、マルチスレッドプログラミングではシングルスレッドプログラミングで特別懸念しなくても良かった点を懸念しなくてはなりません。その1つとしてまずは**競合(data races)**とはどのようなものなのかを見ていきます。まず述べてしまうと、 C++ においてデータ競合とは、以下の条件を満たす場合に発生します。

* 並列で動いている複数のスレッドの内の**1つ以上**が
* 同じメモリ位置にある**排他制御のされていないデータへのアクセス**において
* **変更を加える操作を行う**時

さらに、もし C++ でデータ競合のあるコードを書いた場合、そのコードは**未定義の動作を引き起こします**。つまり、1つでもデータ競合を含むマルチスレッドプログラムの動作結果について C++ 言語仕様としてはは全く保証しません。全く保証しないので、意図した通りに動く事もあるでしょう。しかし意図した通りに動かない事もあるでしょう。マルチスレッドプログラミングにおいて、データ競合が起きないプログラムを書く事は、そのプログラムの信頼性に直結する、とても重要な事なのです。<br>
ここまででは、まだ C++17 でのマルチスレッドプログラミングにおける実際のライブラリやその具体的な使用方法について述べていません。それは、コードに起こす前にマルチスレッドプログラミングにおける注意点を理解しなければ未定義の動作によってこの世の終わりが訪れてしまうかもしれないからというのもありますが、まずはマルチスレッドと切り離して C++ でのシングルスレッドコードについて見て見ましょう。
```cpp
int main()
{
    unsigned char x = 'a';

    unsigned char a = x;
    unsigned char b = x;
}
```
これはシングルスレッドコードです。そうです、今まで書いてきたコードは、シングルスレッドのコードなのでした。1つの実行単位はプロセスであり、スレッドはプロセスまたはスレッドから生成されます。コードでは、`x`から`a`と`b`それぞれが値を読み取っています。この場合、以下のイメージ図のように**そもそも1つの領域に対して同時にアクセスされる事すらまずないですから、競合は起こりえません**。つまり、シングルスレッドコードでは競合は起きません(現時点では深くは触れていませんが、以下の図は最適化におけるデータへのアクセス順序の変動について考慮していません。あくまでイメージです。これについては後に重要なファクターとなります。)。

![](/assets/Chap14/singlethread.jpeg)

次にマルチスレッドの動作について考えて見ましょう。前述した通りまだ C++17 におけるマルチスレッドプログラミングの具体的な方法について述べていませんから、まずは擬似コードと図から考察していきます。

```cpp
int main()
{
    unsigned char x = 'a';

    auto スレッド処理内容1 = [&x]{ [[maybe_unused]] unsigned char a = x; };
    auto スレッド処理内容2 = [&x]{ [[maybe_unused]] unsigned char b = x; };

    スレッド スレッド1 = スレッドの処理内容1;
    スレッド スレッド2 = スレッドの処理内容2;

    スレッド1.処理待ち();
    スレッド2.処理待ち();
}
```
各スレッドがそれぞれ同じメモリ領域に位置するデータを読み取っています。この時、`x`に対するアクセスは完全に同じ瞬間かもしれませんし、若干そうでないかもしれません(下図では同じ瞬間にそれぞれのスレッドが`x`にアクセスしている例です)。

![](/assets/Chap14/multithread.jpeg)

さてマルチスレッド処理となりましたのでデータ競合問題について考えなければなりません。データ競合は前述した通り並列で動いている複数のスレッドの内1つでも同じメモリ位置にある排他制御がされていないデータを変更する操作を行うと発生してしまいます。上記の処理の場合、複数のスレッドが同じメモリ位置にアクセスはしていますが、それらの両処理は**変更操作ではないのでデータ競合は起こりません**。次の例を見て見ましょう。
```cpp
int main()
{
    unsigned char x = 'a';
    
    auto スレッド処理内容1 = [&x]{ x = 'b'; };
    auto スレッド処理内容2 = [&y]{ x = 'c'; };

    スレッド スレッド1 = スレッドの処理内容1;
    スレッド スレッド2 = スレッドの処理内容2;

    スレッド1.処理待ち();
    スレッド2.処理待ち();
}
```
![](/assets/Chap14/multithread_datarace1.jpeg)

この例は、並列で動いている複数のスレッドが同じメモリ位置にあるデータを変更していますから、データ競合、つまり未定義動作を引き起こす擬似コードとなってしまいました。続いて次の例も見て見ましょう。
```cpp
int main()
{
    unsigned char x = 'a';
    
    auto スレッド処理内容1 = [&x]{ x = 'b'; };
    auto スレッド処理内容2 = [&y]{ [[maybe_unused]] unsigned char a = x; };

    スレッド スレッド1 = スレッドの処理内容1;
    スレッド スレッド2 = スレッドの処理内容2;

    スレッド1.処理待ち();
    スレッド2.処理待ち();
}
```
![](/assets/Chap14/multithread_datarace2.jpeg)

スレッド1は書き込み、つまり変更操作ですが、スレッド2は読み込み操作です。しかしこの場合でも、データ競合となってしまいます。それもそのはず、例えば片方のスレッドの書き込みが完了していない間に読み込んでしまうかもしれませんし、たまたま書き込み済みのデータを取得できるかもしれませんし、たまたま書き込みがまだのデータを取得できるかもしれません。またスレッド2がデータを読み込み初めて完了するまでの間に、スレッド1がデータを変更してしまうかもしれません。このようなものを保証する手立ては考えられません。よって同じく未定義動作となります。<br>

データ競合とは何なのか、そして実際に起こりうるシーンはどのようなものなのか見てきましたが、ここまで見て考えてみると、マルチスレッドというものはあまりにも不便に思えるかもしれません。複数のスレッドがアクセスしうる同一のデータへの変更操作が加わった途端に、データ競合が発生してしまうだなんて、じゃあマルチスレッドプログラミングでは変更操作を全くする事ができないのだろうか？と思うかもしれません。しかし安心してください。そのために**排他制御**と言われるものがあります。

## 14.1.3 排他制御

データ競合が起きてしまう条件を振り返って見ましょう。

* 並列で動いている複数のスレッドの内の**1つ以上**が
* 同じメモリ位置にある**排他制御のされていないデータへのアクセス**において
* **変更を加える操作を行う**時

**排他制御のされていないデータへのアクセス**においてとあります。つまり、排他制御というものがあれば変更を加える操作を行なってもデータ競合とはならないのでしょうか？正に、その通りなのです。排他制御とはどのようなものなのか説明します。といっても考え方はとてもシンプルです。<br>未定義動作となってしまう原因の根本にあるのは、変更操作中にその変更操作が完了するまでの間に他のスレッドがそのデータを読み取ってしまうか、読み込みが完了しない間にデータが変更されてしまう事です。ならば、変更操作中にそのデータに対するアクセスを禁止してしまって、変更操作が完了してからアクセスさせれば良いわけです。それが、**排他制御**と言われるものです。このようなアクセス制限を課す動作を**ロックする**、**ロックを取得する**と言い、アクセス制限を解除する事を**アンロック**、**ロック解放**、**ロック解除**などと言います。以下に先ほどの擬似コードに対して排他制御を加えてみます。
```cpp
int main()
{
    unsigned char x = 'a';
    
    auto スレッド処理内容1 = [&x]{ロック; x = 'b'; アンロック;};
    auto スレッド処理内容2 = [&y]{ ロック; [[maybe_unused]] unsigned char a = x; アンロック;};

    スレッド スレッド1 = スレッドの処理内容1;
    スレッド スレッド2 = スレッドの処理内容2;

    スレッド1.処理待ち();
    スレッド2.処理待ち();
}
```
![](/assets/Chap14/multithread_mutualexclusion.jpeg)


このように、ロックを取得する事でアンロックするまでの間、他のスレッド処理の介入を防ぐ事ができます。これを**アトミックである**と言い、当操作を**アトミック操作**と言います。これにより、スレッド2にて`x`から取り出した値、つまり`a`で取得する値は`'a'`または、`'b'`である事が保証されるのです。しかしここでさらに問題が浮上してきました。それは、スレッド同士の順序関係は全く保証されていないという事です。

## 14.1.4 実行順序、リオーダー、メモリバリア

